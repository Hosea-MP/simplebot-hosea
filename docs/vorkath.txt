*GitHub Repository "RivaldoRiet/Vorkath"*

'''--- Main.java ---
package Vorkath;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.MouseEvent;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

import Vorkath.data.Constants;
import Vorkath.data.Supplies;
import Vorkath.data.Variables;
import Vorkath.data.Vorkath;
import Vorkath.data.utils.Utils;
import Vorkath.tasks.BankTask;
import Vorkath.tasks.NpcFighterTask;
import Vorkath.tasks.RecollectTask;
import Vorkath.tasks.WalkerTask;
import net.runelite.api.ChatMessageType;
import net.runelite.api.VarPlayer;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Magic.SpellBook;
import simple.hooks.simplebot.teleporter.Teleporter;
import simple.hooks.wrappers.SimpleNpc;
import simple.robot.utils.WorldArea;

@ScriptManifest(author = "Trester/Steganos", category = Category.COMBAT, description = "Does vorkath", name = "Zaros Vorkath", servers = {
		"Zaros" }, version = "0.1", discord = "")

public class Main extends TaskScript implements LoopingScript {
	private List<Task> tasks = new ArrayList<Task>();
	private int vorkathKills = 0;
	@Override
	public void paint(Graphics Graphs) {
		Graphics2D g = (Graphics2D) Graphs;

		g.setColor(Color.BLACK);
		g.fillRect(0, 230, 170, 75);
		g.setColor(Color.BLACK);
		g.drawRect(0, 230, 170, 75);
		g.setColor(Color.white);

		g.drawString("Private Vorkath v0.1", 7, 245);
		g.drawString("Uptime: " + Variables.START_TIME.toElapsedString(), 7, 257);
		g.drawString("Status: " + Variables.STATUS, 7, 269);

		g.drawString("Vorkath kills: " + vorkathKills + " (" + ctx.paint.valuePerHour(vorkathKills, Variables.START_TIME.getStart()) + ")",
				7, 281);
		if (Variables.vorkath != null) {
			g.drawString("Debug: Zombie: " + zombifiedExist() + " - active: " + Variables.vorkath.isZombieSpawnActive() , 7, 293);
		}
		g.drawString("Script Status: " + this.getScriptStatus(), 7, 305);

		//g.drawString("Debug: recollect items: " + Variables.RECOLLECT_ITEMS, 7, 293);
	}

	private boolean zombifiedExist() {
		SimpleNpc zombified = ctx.npcs.populate().filter("Zombified spawn").filter(n -> !n.isDead()).next();
		if (zombified != null) {
			return true;
		}
		return false;
	}

	@Override
	public boolean prioritizeTasks() {
		return true;
	}

	@Override
	public List<Task> tasks() {
		return tasks;
	}

	final String[] STOP_MESSAGES = { "be found:", "you are dead" };

	@Override
	public void onChatMessage(ChatMessage e) {
		if (e.getType() == ChatMessageType.GAMEMESSAGE) {
			if (!Variables.RECOLLECT_ITEMS) {
				Variables.RECOLLECT_ITEMS = Stream.of(STOP_MESSAGES).anyMatch(msg -> e.getMessage().contains(msg));
			}
		}
		if (e.getType() == ChatMessageType.GAMEMESSAGE) {
			if (e.getMessage().contains("kill count")) {
				vorkathKills++;
			}
		}
	}

	public boolean fightReady() {
		boolean hasAnti = false;
		boolean hasFood = false;
		boolean hasRunes = true;
		boolean hasAntiFire = true;

		return hasAnti && hasFood && hasRunes && hasAntiFire;
	}

	@Override
	public void onExecute() {
		try {
			doChecks();
			Utils.setZoom(1);
			startScript();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private void doChecks() {
		boolean stop = false;
		if (ctx.magic.spellBook() != SpellBook.MODERN) {
			ctx.log("Please switch to normal spellbook");
			stop = true;
		}
		if (!Utils.inventoryContains(true, "Chaos rune", "Earth rune", "Air rune")) {
			ctx.log("Please have required runes in inventory:\n%s, %s, %s", "Chaos rune", "Earth rune", "Air rune");
			// stop = true;
		}

		if (stop)
			ctx.stopScript();

	}

	@Override
	public void onTerminate() {
	}

	private void startScript() {
		Variables.vorkath = new Vorkath(ctx, this);
		Variables.supplies = new Supplies(ctx, this);
		Variables.teleporter = new Teleporter(ctx);

		Variables.bankTask = new BankTask(ctx, this);
		Variables.walkTask = new WalkerTask(ctx, this);
		Variables.fighterTask = new NpcFighterTask(ctx, this);
		Variables.recollectTask = new RecollectTask(ctx, this);

		Variables.RECOLLECT_ITEMS = false;

		tasks.addAll(Arrays.asList(Variables.bankTask, Variables.walkTask, Variables.fighterTask, Variables.recollectTask));
	}

	public void onMouse(MouseEvent e) {

	}

	@Override
	public int loopDuration() {
		return 150;
	}
}

'''
'''--- data/Constants.java ---
package Vorkath.data;

import net.runelite.api.ItemID;
import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

public class Constants {

	public final static int START_ROCK_ID = 31990;
	public final static int VORKATH_SLEEPING_ID = 8059;
	public final static int VORKATH_WAKING_UP_ID = 8058;
	public final static int VORKATH_ID = 8061;
	public final static int VORKATH_RANGED_ANIM_ID = 1477;
	public final static int VORKATH_MAGE_ANIM_ID = 1479;
	public final static int VORKATH_FIREBALL_ANIM_ID = 7960;
	public final static int VORKATH_FIREBALL_PROJECTILE_ID = 1481;
	public final static int VORKATH_ZOMBIE_ATTACK_PROJECTILE_ID = 1484;
	public final static int VORKATH_ACID_ATTACK_PROJECTILE_ID = 1482;
	public final static int VORKATH_ACID_ATTACK_ANIM_ID = 100000;
	public static int ACID_TILE_ID = 32000;
	public static int[] ANTI_IDS = { 2446, 177, 175, 179, 12913, 12915, 12917, 12919 };
	public static int[] ANTIFIRE_IDS = { 2452, 2454, 2458, 2456 };
	public static int[] RANGE_POT__IDS = { 2444, 173, 171, 169 };
	public static int[] PRAYER_POT_IDS = { 2434, 139, 143, 141 };
	public static final int[] DEFENCE_POT_IDS = { ItemID.SUPER_DEFENCE1, ItemID.SUPER_DEFENCE3, ItemID.SUPER_DEFENCE4,
			ItemID.SUPER_DEFENCE2 };
	public final static WorldArea EDGEVILE_AREA = new WorldArea(new WorldPoint(3078, 3504, 0),
			new WorldPoint(3101, 3486, 0));
	public final static WorldArea VORKATH_START_AREA = new WorldArea(new WorldPoint(2270, 4054, 0),
			new WorldPoint(2276, 4035, 0));

}

'''
'''--- data/Supplies.java ---

package Vorkath.data;

import Vorkath.Main;
import Vorkath.data.utils.Timer;
import Vorkath.data.utils.Utils;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.wrappers.SimpleItem;
import simple.robot.api.ClientContext;

public class Supplies {

	private ClientContext ctx;
	private Main main;

	public Supplies(ClientContext ctx, Main main) {
		this.ctx = ctx;
		this.main = main;
	}

	public boolean shouldRestock() {
		if (extremelyLowHealth()
				|| (quiteLowHealth() && ctx.inventory.populate().filterHasAction("Eat").population() == 0)) {
			return true;
		}
		if (Variables.fighterTask.extremelyLowHealth())
			return true;

		//if (!Utils.inventoryContains("shark", "anglerfish", "manta ray", "pizza", "prayer potion"))
		//	return true;
		return false;
		/*
		 * if (!Utils.inventoryContains("shark", "anglerfish", "manta ray")) { status =
		 * ("Restocking due to no food"); return true; }
		 *
		 * if (!Utils.inventoryContains("sanfew", "restore")) { status =
		 * ("Restocking due to no restores"); return true; }
		 *
		 * return false;
		 */
	}

	private boolean fullInventWithBones() {
		if (ctx.inventory.populate().population() == 28 && Utils.inventoryContains("Dragon bones")) {
			return true;
		}
		return false;
	}

	public boolean extremelyLowHealth() {
		return getPercentageHitpoints() < 20;
	}

	public boolean quiteLowHealth() {
		return getPercentageHitpoints() < 40;
	}

	private static Timer antiFireTimer = new Timer(1);

	public void drinkAntiFire() {
		SimpleItem potion = ClientContext.instance().inventory.populate().filter(Constants.ANTIFIRE_IDS).next();
		if (!antiFireTimer.isRunning() && potion != null) {
			potion.click("drink");
			antiFireTimer.setEndIn(200000);
			ClientContext.instance().sleep(150, 350);
		}
	}

	public boolean lowHealth() {
		return getPercentageHitpoints() <= 77;
	}

	public void drinkAntiPoison() {
		if (lowHealth()) {
			Variables.supplies.eatFood();
		}
		SimpleItem potion = ClientContext.instance().inventory.populate().filter(Constants.ANTI_IDS).next();
		if (potion != null) {
			Variables.STATUS = "Drinking antipoison";
			potion.click(0);
		}

	}

	public int getPercentageHitpoints() {
		// returns 50 for example
		float perc = ((float) ClientContext.instance().skills.level(Skills.HITPOINTS)
				/ ClientContext.instance().skills.realLevel(Skills.HITPOINTS));
		float perc1 = (perc * 100);
		return (int) perc1;
	}

	public void eatFood() {
		SimpleItem food = ctx.inventory.populate().filterHasAction("Eat").next();

		if (food != null) {
			Variables.STATUS = "Clicking food";
			food.click(0);
		}
	}

	public void drinkRangedPotion() {
		SimpleItem rangePot = ctx.inventory.populate().filter(Constants.RANGE_POT__IDS).next();
		if (rangePot != null) {
			Variables.STATUS = "Clicking range potion";
			rangePot.click(0);
		}
	}

	public boolean shouldDrinkRangePot() {
		int max = ctx.skills.realLevel(SimpleSkills.Skills.RANGED);
		return max + 8 > ctx.skills.level(SimpleSkills.Skills.RANGED);
	}

	public void drinkDefencePotion() {
		SimpleItem pot = ctx.inventory.populate().filter(Constants.DEFENCE_POT_IDS).next();
		if (pot != null) {
			Variables.STATUS = "Clicking defense potion";
			pot.click(0);
		}
	}

	public boolean shouldDrinkDefencePot() {
		int max = ctx.skills.realLevel(SimpleSkills.Skills.DEFENCE);
		return max + 16 > ctx.skills.level(SimpleSkills.Skills.DEFENCE);
	}
}
'''
'''--- data/Variables.java ---

package Vorkath.data;

import Vorkath.data.utils.Timer;
import Vorkath.tasks.BankTask;
import Vorkath.tasks.NpcFighterTask;
import Vorkath.tasks.RecollectTask;
import Vorkath.tasks.WalkerTask;
import simple.hooks.simplebot.teleporter.Teleporter;

public class Variables {

	public static boolean RECOLLECT_ITEMS = false;
	public static boolean FORCE_BANK = false;

	public static String STATUS = "Booting up";
	public static Timer START_TIME = new Timer();

	public static BankTask bankTask;
	public static WalkerTask walkTask;
	public static NpcFighterTask fighterTask;
	public static RecollectTask recollectTask;

	public static Vorkath vorkath;
	public static Teleporter teleporter;
	public static Supplies supplies;
}
'''
'''--- data/Vorkath.java ---
package Vorkath.data;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

import Vorkath.Main;
import Vorkath.data.utils.Utils;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.queries.SimpleEntityQuery;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;
import simple.robot.utils.WorldArea;

public class Vorkath {

	private ClientContext ctx;
	private Main main;
	public WorldPoint debugTile = null;
	public long lastFireBallMove = 0;

	public Vorkath(ClientContext ctx, Main main) {
		this.ctx = ctx;
		this.main = main;
	}

	public SimpleNpc get() {
		return get(false);
	}

	public SimpleNpc get(boolean sleeping) {
		return ctx.npcs.populate().filter(sleeping ? Constants.VORKATH_SLEEPING_ID : Constants.VORKATH_ID).next();
	}

	public boolean isActive() {
		return get() != null;
	}

	public boolean isSleeping() {
		return get(true) != null;
	}

	public boolean isSpawnActive() {
		return Utils.isProjectileActive(7960);
	}

	public boolean isZombieSpawnActive() {
		return Utils.isProjectileActive(Constants.VORKATH_ZOMBIE_ATTACK_PROJECTILE_ID);
	}

	public boolean isFireBallActive() {
		return Utils.isProjectileActive(Constants.VORKATH_FIREBALL_PROJECTILE_ID);
	}

	public boolean inInstance() {
		SimpleObject rock = ctx.objects.populate().filter(Constants.START_ROCK_ID).next();
		return rock != null && rock.getLocation().getY() < ctx.players.getLocal().getLocation().getY();
	}

	public int getVorkathHealth() {
		SimpleNpc vorkath = get(false);
		if (vorkath != null && vorkath.getHealthRatio() != -1) {
			return vorkath.getHealthRatio();
		}
		return -1;
	}

	public WorldArea getArea() {
		WorldArea w = null;
		if (inInstance()) {
			SimpleObject rock = ctx.objects.populate().filter(Constants.START_ROCK_ID).next();
			if (rock != null) {
				WorldPoint southWest = new WorldPoint(rock.getLocation().getX() - 10, rock.getLocation().getY() + 1, 0);
				WorldPoint northEast = new WorldPoint(rock.getLocation().getX() + 10, rock.getLocation().getY() + 24,
						0);
				w = new WorldArea(southWest, northEast);
			}
		}
		return w;
	}

	public WorldArea rangeAttackArea() {
		WorldArea w = null;
		if (inInstance()) {
			SimpleObject rock = ctx.objects.populate().filter(Constants.START_ROCK_ID).next();
			if (rock != null) {
				WorldPoint southWest = new WorldPoint(rock.getLocation().getX() - 1, rock.getLocation().getY() + 2, 0);
				WorldPoint northEast = new WorldPoint(rock.getLocation().getX() + 2, rock.getLocation().getY() + 3, 0);
				w = new WorldArea(southWest, northEast);
			}
		}
		return w;
	}

	private boolean isAcidLanding() {
		return ctx.objects.populate().filter(Constants.ACID_TILE_ID).size() > 0 || acidLanding();
	}

	private boolean acidLanding() {
		return ctx.projectiles.projectileActive(1483);
	}

	public WorldPoint getStartingPointAcidSingle() {
		if (!isAcidLanding()) {
			return null;
		}

		WorldArea a = Variables.vorkath.getArea();

		for (WorldPoint w : a.getWorldPoints()) {
			if (w.distanceTo(ctx.players.getLocal().getLocation()) >= 8) {
				continue;
			}

			if (containsAcid(w)) {
				continue;
			}

			WorldPoint east1 = new WorldPoint(w.getX() + 1, w.getY(), 0);
			if (containsAcid(east1)) {
				continue;
			}

			WorldPoint east2 = new WorldPoint(w.getX() + 2, w.getY(), 0);
			if (containsAcid(east2)) {
				continue;
			}

			WorldPoint east3 = new WorldPoint(w.getX() + 3, w.getY(), 0);
			if (containsAcid(east3)) {
				continue;
			}

			WorldPoint east4 = new WorldPoint(w.getX() + 4, w.getY(), 0);
			if (containsAcid(east4)) {
				continue;
			}

			WorldPoint east5 = new WorldPoint(w.getX() + 5, w.getY(), 0);
			if (containsAcid(east5)) {
				continue;
			}

			return w;

		}
		return null;
	}

	public WorldPoint getSortedPoint() {
		ArrayList<WorldPoint> wl = this.getStartingPointAcid();
		if (wl != null && wl.size() > 0) {
			Collections.sort(wl, new Comparator<WorldPoint>() {
				@Override
				public int compare(WorldPoint z1, WorldPoint z2) {
					if (z1.distanceTo(ctx.players.getLocal().getLocation()) > z2
							.distanceTo(ctx.players.getLocal().getLocation()))
						return 1;
					if (z1.distanceTo(ctx.players.getLocal().getLocation()) < z2
							.distanceTo(ctx.players.getLocal().getLocation()))
						return -1;
					return 0;
				}
			});
			return wl.get(0);
		}
		return null;
	}

	public ArrayList<WorldPoint> getStartingPointAcid() {
		if (!isAcidLanding()) {
			return null;
		}

		ArrayList<WorldPoint> safe = new ArrayList<WorldPoint>();
		WorldArea a = Variables.vorkath.getArea();

		for (WorldPoint w : a.getWorldPoints()) {
			if (w.distanceTo(ctx.players.getLocal().getLocation()) >= 8) {
				continue;
			}

			if (containsAcid(w)) {
				continue;
			}

			WorldPoint east1 = new WorldPoint(w.getX() + 1, w.getY(), 0);
			if (containsAcid(east1)) {
				continue;
			}

			WorldPoint east2 = new WorldPoint(w.getX() + 2, w.getY(), 0);
			if (containsAcid(east2)) {
				continue;
			}

			WorldPoint east3 = new WorldPoint(w.getX() + 3, w.getY(), 0);
			if (containsAcid(east3)) {
				continue;
			}

			WorldPoint east4 = new WorldPoint(w.getX() + 4, w.getY(), 0);
			if (containsAcid(east4)) {
				continue;
			}

			safe.add(w);

		}
		return safe;
	}

	public boolean containsAcid(WorldPoint w) {
		SimpleEntityQuery<SimpleObject> acids = ctx.objects.populate().filter(e -> e.getId() == Constants.ACID_TILE_ID)
				.filter(w);
		if (acids.size() > 0) {
			return true;
		}
		return false;
	}
}
'''
'''--- data/utils/Timer.java ---
package Vorkath.data.utils;

import simple.robot.util.Time;

public class Timer {
	/**
	 *
	 */
	private long start;

	public long getStart() {
		return start;
	}

	private long period;

	private long end;

	public String toElapsedString() {
		return Time.formatTime(getElapsed());
	}

	public long setEndIn(long l) {
		this.end = System.currentTimeMillis() + l;
		return this.end;
	}

	public String toRemainingString() {
		return Time.formatTime(getRemaining());
	}

	public void reset() {
		this.end = System.currentTimeMillis() + this.period;
	}

	public Timer() {
		this.period = this.start = System.currentTimeMillis();
	}

	public void restart() {
		this.period = this.start = System.currentTimeMillis();
	}

	public Timer(long l) {
		this.period = l;
		this.start = System.currentTimeMillis();
		this.end = this.start + l;
	}

	public long getElapsed() {
		return System.currentTimeMillis() - this.start;
	}

	public long getRemaining() {
		if (isRunning())
			return this.end - System.currentTimeMillis();
		return 0L;
	}

	public boolean isRunning() {
		return System.currentTimeMillis() < this.end;
	}
}
'''
'''--- data/utils/Utils.java ---
package Vorkath.data.utils;

import java.awt.Image;
import java.io.IOException;
import java.net.URL;
import java.util.Scanner;
import java.util.concurrent.TimeUnit;
import java.util.stream.Stream;

import javax.imageio.ImageIO;

import Vorkath.data.Variables;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.filters.SimplePrayers.Prayers;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.simplebot.Game.Tab;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.api.ClientContext;

public class Utils {

	private static String runescapeFormat(Integer number) {
		String[] suffix = { "K", "M", "B", "T" };
		int size = (number.intValue() != 0) ? (int) Math.log10(number.intValue()) : 0;
		if (size >= 3)
			while (size % 3 != 0)
				size--;
		return (size >= 3)
				? (String.valueOf(Math.round(number.intValue() / Math.pow(10.0D, size) * 10.0D) / 10.0D)
						+ suffix[size / 3 - 1])
				: (new StringBuilder(String.valueOf(number.intValue()))).toString();
	}

	public static Image getImage(String url) {
		try {
			return ImageIO.read(new URL(url));
		} catch (IOException e) {
			return null;
		}
	}

	public static boolean isProjectileActive(int id) {
		if (ClientContext.instance().projectiles.getActiveProjectiles().size() > 0) {
			if (ClientContext.instance().projectiles.projectileActive(id)) {
				return true;
			}
		}
		return false;
	}

	public static void disablePrayer(Prayers prayer) {
		if (ClientContext.instance().prayers.prayerActive(prayer))
			ClientContext.instance().prayers.prayer(prayer, false);
	}

	public static void disableAllPrayers() {
		Stream.of(Prayers.values()).forEach(Utils::disablePrayer);
	}

	public static void enablePrayer(Prayers prayer) {
		if (ClientContext.instance().skills.level(Skills.PRAYER) <= 0)
			return;
		if (!ClientContext.instance().prayers.prayerActive(prayer)) {
			Variables.STATUS = "Enabling prayer";
			ClientContext.instance().prayers.prayer(prayer, true);
		}
	}

	public static String get(String url) throws Exception {
		StringBuilder sb = new StringBuilder();
		for (Scanner sc = new Scanner(new URL(url).openStream()); sc.hasNext();)
			sb.append(sc.nextLine()).append('\n');
		return sb.toString();
	}

	public static boolean inventoryContains(boolean all, String... itemName) {
		if (!all)
			return inventoryContains(itemName);
		return !ClientContext.instance().inventory.populate()
				.filter(p -> Stream.of(itemName).allMatch(arr -> p.getName().toLowerCase().contains(arr.toLowerCase())))
				.isEmpty();
	}

	public static boolean inventoryContains(String... itemName) {
		return !ClientContext.instance().inventory.populate()
				.filter(p -> Stream.of(itemName).anyMatch(arr -> p.getName().toLowerCase().contains(arr.toLowerCase())))
				.isEmpty();
	}

	public static SimpleItem getItem(String... itemName) {
		return ClientContext.instance().inventory.populate()
				.filter(p -> Stream.of(itemName).anyMatch(arr -> p.getName().toLowerCase().contains(arr.toLowerCase())))
				.next();
	}

	public static boolean isItemEquiped(String name) {
		if (ClientContext.instance().equipment.getEquippedItem(EquipmentSlot.WEAPON) != null
				&& ClientContext.instance().equipment.getEquippedItem(EquipmentSlot.WEAPON).getName().toLowerCase()
						.contains(name)) {
			return true;
		}

		return false;
	}

	public static int getPercentagePrayer() {
		float perc = ((float) ClientContext.instance().skills.level(Skills.PRAYER)
				/ ClientContext.instance().skills.realLevel(Skills.PRAYER));
		float perc1 = (perc * 100);
		return (int) perc1;
	}

	public static int getPercentageHitpoints() {
		// returns 50 for example
		float perc = ((float) ClientContext.instance().skills.level(Skills.HITPOINTS)
				/ ClientContext.instance().skills.realLevel(Skills.HITPOINTS));
		float perc1 = (perc * 100);
		return (int) perc1;
	}

	public static void openTab(Tab tab) {
		if (!isTabOpen(tab))
			ClientContext.instance().game.tab(tab);
	}

	public static boolean isTabOpen(Tab tab) {
		return ClientContext.instance().game.tab().equals(tab);
	}

	public static boolean doneDelay(long ms, int delay) {
		if (ms == 0)
			return true;
		long left = (ms + delay) - System.currentTimeMillis();
		return left <= 0;
	}

	public static String delayTimer(long ms, int delay) {
		long left = (ms + delay) - System.currentTimeMillis();
		if (left <= 0)
			return "";
		return String.format("%d min, %d sec", TimeUnit.MILLISECONDS.toSeconds(left) / 60,
				TimeUnit.MILLISECONDS.toSeconds(left) % 60);
	}

	public static void drinkSinglePrayerPot(boolean check) {
		int percPrayerlvl = getPercentagePrayer();
		if (check && percPrayerlvl > 60)
			return;

		String[] restores = { "restore", "sanfew", "prayer" };
		SimpleItem restore = getItem(restores);

		if (restore != null && restore.click(0)) {
			Variables.STATUS = "Drinking prayer potion";
		}
	}

	public static void setZoom(int zoom) {
		ClientContext ctx = ClientContext.instance();
		ctx.viewport.pitch(100);
		ctx.viewport.angle(0);

		openTab(Tab.OPTIONS);

		SimpleWidget widget = ctx.widgets.getWidget(261, 8 + zoom);
		if (widget != null && widget.visibleOnScreen())
			widget.click(0);
	}

}
'''
'''--- tasks/BankTask.java ---
package Vorkath.tasks;

import Vorkath.Main;
import Vorkath.data.Constants;
import Vorkath.data.Variables;
import Vorkath.data.utils.Utils;
import net.runelite.api.VarPlayer;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.scripts.task.Task;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;

public class BankTask extends Task {
	private Main main;

	public BankTask(ClientContext ctx, Main main) {
		super(ctx);
		this.main = main;
	}

	@Override
	public boolean condition() {
		return !Variables.RECOLLECT_ITEMS && ctx.pathing.inArea(Constants.EDGEVILE_AREA)
				|| !Variables.RECOLLECT_ITEMS && Variables.supplies.shouldRestock();
	}

	@Override
	public void run() {

		if (!ctx.pathing.inArea(Constants.EDGEVILE_AREA)) {
			Variables.STATUS = "Teleporting to edgeville";
		}
		ctx.pathing.running(true);

		Utils.disableAllPrayers();
		//if (Variables.RECOLLECT_ITEMS) {
			//ctx.stopScript();
			//return;
		//}

		SimpleObject bank = ctx.objects.populate().filter(10355).nearest().next();
		if (ctx.skills.level(Skills.HITPOINTS) < ctx.skills.realLevel(Skills.HITPOINTS)
				|| ctx.skills.level(Skills.PRAYER) != ctx.skills.realLevel(Skills.PRAYER)) {
			Variables.STATUS = "Healing to full";
			SimpleObject box = ctx.objects.populate().filter(60003).nearest().next();
			if (box != null && box.validateInteractable())
				box.click("Heal");
		} else if (shouldBank() && bank != null && bank.validateInteractable()) {
			Variables.STATUS = "Getting last preset";
			bank.click("Last-preset");
			ctx.sleepCondition(() -> ctx.inventory.inventoryFull(), 1500);
			if (isPoisonedOrVenomed())
				Variables.supplies.drinkAntiPoison();
			return;
		} else if (Variables.teleporter.open()) {
			if (isPoisonedOrVenomed()) {
				Variables.supplies.drinkAntiPoison();
			} else {
				Variables.STATUS = "Teleporting to vorkath";
				Variables.teleporter.teleportStringPath("Bossing", "Vorkath");
				ctx.sleep(150, 400);
				ctx.sleepCondition(
						() -> Constants.VORKATH_START_AREA.containsPoint(ctx.players.getLocal().getLocation()), 1500);
			}
		}

	}

	public boolean isPoisonedOrVenomed() {
		return ctx.getClient().getVar(VarPlayer.IS_POISONED) >= 30;
	}

	private boolean shouldBank() {
		if (!ctx.inventory.inventoryFull()) {
			return true;
		}
		if (Utils.inventoryContains("dragon bones")) {
			return true;
		}

		return false;
	}

	@Override
	public String status() {
		return "Restocking";
	}

}

'''
'''--- tasks/NpcFighterTask.java ---
package Vorkath.tasks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import Vorkath.Main;
import Vorkath.data.Constants;
import Vorkath.data.Variables;
import Vorkath.data.utils.Utils;
import net.runelite.api.VarPlayer;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimplePrayers;
import simple.hooks.filters.SimplePrayers.Prayers;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.queries.SimpleEntityQuery;
import simple.hooks.queries.SimpleQuery;
import simple.hooks.scripts.task.Task;
import simple.hooks.wrappers.SimpleGroundItem;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;
import simple.robot.utils.WorldArea;

public class NpcFighterTask extends Task {
	private Main main;
	public WorldArea edge = new WorldArea(new WorldPoint(3074, 3466, 0), new WorldPoint(3126, 3523, 0));
	private long lastFireBallMovement = 0;
	public List<WorldPoint> acidFreePath = new ArrayList<>();
	List<WorldPoint> acidSpots = new ArrayList<>();
	WorldPoint[] walkPath1 = new WorldPoint[5];
	WorldPoint[] walkPath2 = new WorldPoint[5];
	public WorldPoint startTile = null;
	public WorldPoint endTile = null;
	public WorldPoint[] path = null;
	private boolean switchAttackArea = false;
	private int westWalk = 1;

	public NpcFighterTask(ClientContext ctx, Main main) {
		super(ctx);
		this.main = main;
	}

	@Override
	public boolean condition() {
		return !Variables.RECOLLECT_ITEMS && Variables.vorkath.inInstance();
	}

	boolean looted = false;

	@Override
	public void run() {

		SimpleNpc vorkath_sleeping = Variables.vorkath.get(true);

		if (vorkath_sleeping != null) {
			if (shouldLoot()) {
				if (!looted)
					looted = true;
				loot();
			} else if (looted) {
				Variables.STATUS = "Teleporting after loot";
				teleportOut();
			} else {
				looted = false;
				setupVorkath(vorkath_sleeping);
			}

		} else if (Variables.vorkath.isActive()) {
			Variables.STATUS = "Handling vorkath";

			respondToFireball();

			if (Variables.vorkath.isZombieSpawnActive() || this.zombifiedExist()) {
				//Variables.STATUS = "Zombified active";

				if (this.hasSlayerStaff() && !this.isWearingSlayerStaff()) {
					Variables.STATUS = "Equipping slayer staff";
					this.equipSlayerStaff();
				}
				if (ctx.players.getLocal().getInteracting() != null && ctx.players.getLocal().getInteracting().getName() != null) {
					//ctx.log("name: " + ctx.players.getLocal().getInteracting().getName());
					if (ctx.players.getLocal().getInteracting().getName().toLowerCase().contains("vorkath")) {
						// make sure the player stops ranging vorkath so the speed doesn't mess up
						ctx.pathing.step(ctx.players.getLocal().getLocation());
					}
				}
				zombified();
				return;
			}else {
				if (this.isWearingSlayerStaff()) {
					Variables.STATUS = "Equipping crossbow";
					 equipCrossbow();
				}
			}

			if (extremelyLowHealth()
					|| (quiteLowHealth() && ctx.inventory.populate().filterHasAction("Eat").population() == 0))
				teleportOut();
			respondToFireball();
			if (isPoisonedOrVenomed())
				Variables.supplies.drinkAntiPoison();
			respondToFireball();
			switchPrayerOnVorkath();
			if (lowHealth())
				Variables.supplies.eatFood();
			respondToFireball();
			if (isAcidLanding()) {
				WorldPoint w = Variables.vorkath.getSortedPoint();
				Variables.STATUS = "Handling Acid";
				handleAcidCustom(w);
			}
			if (lowPrayer())
				drinkPrayerPot();
			respondToFireball();
			if (Variables.supplies.shouldDrinkRangePot())
				Variables.supplies.drinkRangedPotion();
			if (Variables.supplies.shouldDrinkDefencePot())
				Variables.supplies.drinkDefencePotion();
			respondToFireball();
			if (!Variables.vorkath.isFireBallActive() && !isAcidLanding() && inFightArea()
					&& !zombifiedExist())
				attackVorkath();
			if (isAcidLanding()) {
				WorldPoint w = Variables.vorkath.getSortedPoint();
				Variables.STATUS = "Handling Acid";
				handleAcidCustom(w);
			}

			respondToFireball();

			switchPrayerOnVorkath();
			respondToFireball();
			switchBoltsOnVorkath();
			respondToFireball();
		}

	}

	private void equipCrossbow()
	{
		if (Utils.inventoryContains("crossbow")) {
			SimpleItem staff = ctx.inventory.populate().filter(s -> s.getName().toLowerCase().contains("crossbow")).next();
			if (staff != null) {
				staff.click(0);
				ctx.onCondition(() -> isWearingCrossbow(), 500);
			}
		}
	}

	private void equipSlayerStaff()
	{
		if (Utils.inventoryContains("slayer")) {
			SimpleItem staff = ctx.inventory.populate().filter(s -> s.getName().toLowerCase().contains("slayer")).next();
			if (staff != null) {
				staff.click(0);
				ctx.onCondition(() -> isWearingSlayerStaff(), 500);
			}
		}
	}

	private boolean hasSlayerStaff()
	{
		if(ctx.equipment.getEquippedItem(EquipmentSlot.WEAPON).getName().toLowerCase().contains("slayer"))
		{
			return true;
		}
		if (Utils.inventoryContains("slayer")) {
			return true;
		}
		return false;
	}

	private boolean isWearingCrossbow()
	{
		if(ctx.equipment.getEquippedItem(EquipmentSlot.WEAPON).getName().toLowerCase().contains("crossbow"))
		{
			return true;
		}
		return false;
	}


	private boolean isWearingSlayerStaff()
	{
		if(ctx.equipment.getEquippedItem(EquipmentSlot.WEAPON).getName().toLowerCase().contains("slayer"))
		{
			return true;
		}
		return false;
	}

	private void respondToFireball()
	{
		//if (!ctx.pathing.inMotion() && Variables.vorkath.isFireBallActive() && (System.currentTimeMillis() - Variables.vorkath.lastFireBallMove) >= 1000) {
		if (Variables.vorkath.isFireBallActive() && (System.currentTimeMillis() - Variables.vorkath.lastFireBallMove) >= 2000) {
			Variables.STATUS = "Fire ball active";
			handleFireball();
		}
	}

	private void setupVorkath(SimpleNpc vorkath_sleeping) {
		if (inventWithBones()) {
			Variables.STATUS = "Teleporting away";
			ctx.magic.castHomeTeleport();
		}else {
			Variables.STATUS = "Waking up vorkath";
			if (vorkath_sleeping.click("Poke")) {
				Utils.setZoom(1);
				WorldPoint initial = ctx.players.getLocal().getLocation();
				ctx.sleepCondition(() -> vorkath_sleeping.distanceTo(ctx.players.getLocal()) <= 5, 5000);
				ctx.sleep(1000);
				switchPrayerOnVorkath();
				Variables.supplies.drinkAntiFire();
				WorldPoint newWP = new WorldPoint(initial.getX(), initial.getY() - 5, initial.getPlane());
				WorldPoint[] path = { newWP };
				ctx.pathing.walkPath(path);
			}
		}
	}

	private boolean inventWithBones() {
		if (Utils.inventoryContains("Dragon bones")) {
			return true;
		}
		return false;
	}

	private boolean zombifiedExist() {
		SimpleNpc zombified = ctx.npcs.populate().filter("Zombified spawn").filter(n -> !n.isDead()).next();
		if (zombified != null) {
			return true;
		}
		return false;
	}

	private boolean zombified() {
		SimpleNpc zombified = ctx.npcs.populate().filter("Zombified spawn").nearest().next();
		if (zombified == null)
			return false;

		//if (!zombified.isDead()) {
			Variables.STATUS = "Zombified active";
			if (this.isWearingSlayerStaff()) {
				Variables.STATUS = "Crumble undeath w/ staff";
				zombified.click("Attack");
				return true;
			}else {
			if (ctx.magic.castSpellOnNPC("Crumble Undead", zombified)) {
				return true;
			}
			}
	//	}
		return false;
	}

	private boolean lowPrayer() {
		return ctx.skills.level(SimpleSkills.Skills.PRAYER) <= 30;
	}

	public void drinkPrayerPot() {
		SimpleItem prayerPot = ctx.inventory.populate().filter(Constants.PRAYER_POT_IDS).next();
		if (prayerPot != null) {
			Variables.STATUS = "Clicking prayer potion";
			prayerPot.click(0);
		}
	}

	public boolean shouldLoot() {
		return ctx.groundItems.populate().filter(n -> !Constants.VORKATH_START_AREA.containsPoint(n.getLocation())).size() > 0;
	}

	private boolean inFightArea() {
		return true;
		/*
		WorldArea w = Variables.vorkath.rangeAttackArea();
		if (w != null && w.containsPoint(ctx.players.getLocal().getLocation())) {
			return true;
		}
		return false;*/
	}

	private void walkBackToFightArea() {
		WorldArea w = Variables.vorkath.rangeAttackArea();
		if (w != null && w.getWorldPoints().length > 0 && !Variables.vorkath.isFireBallActive()) {
			Variables.STATUS = "Walking back to attack area";
			ctx.pathing.step(w.randomTile());
		}
	}

	private void switchPrayerOnVorkath() {
		respondToFireball();
		Utils.enablePrayer(Prayers.PROTECT_FROM_MAGIC);
		respondToFireball();
		Utils.enablePrayer(SimplePrayers.Prayers.EAGLE_EYE);
		respondToFireball();
	}

	private void switchBoltsOnVorkath() {
		int vorkathHealth = Variables.vorkath.getVorkathHealth();
		if (vorkathHealth == -1) {
			return;
		}

		// 30 is the max health ratio
		if (Utils.inventoryContains("Ruby bolts (e)") && vorkathHealth >= 35) {
			SimpleItem bolts = Utils.getItem("Ruby bolts (e)");
			if (bolts != null) {
				Variables.STATUS = "Switching bolts";
				bolts.click(0);
				ctx.sleep(501);
			}
		} else if (Utils.inventoryContains("Diamond bolts (e)") && vorkathHealth < 35) {
			SimpleItem bolts = Utils.getItem("Diamond bolts (e)");
			if (bolts != null) {
				Variables.STATUS = "Switching diamond bolts";
				bolts.click(0);
				ctx.sleep(500, 600);
			}
		}
	}

	private void handleFireball() {

		if (Variables.vorkath.isFireBallActive()) {
			Variables.STATUS = "Fire ball active";
			WorldPoint startingSpot = ctx.players.getLocal().getPlayer().getWorldLocation();
			WorldPoint westSpot = new WorldPoint(startingSpot.getX() - 2, startingSpot.getY(),
					startingSpot.getPlane());
			WorldPoint eastSpot = new WorldPoint(startingSpot.getX() + 2, startingSpot.getY(),
					startingSpot.getPlane());


			if (ctx.pathing.reachable(westSpot) && ctx.pathing.reachable(eastSpot)) {
				if (westWalk == 1 || westWalk == 2) {
					walkFireBall(westSpot);
				} else if (westWalk == 3 || westWalk == 4) {
					walkFireBall(eastSpot);
				}
				return;
			}

			if (ctx.pathing.reachable(westSpot)) {
				walkFireBall(westSpot);
			} else {
				walkFireBall(eastSpot);
			}
		}
	}

	private void walkFireBall(WorldPoint w)
	{
		if (ctx.pathing.reachable(w)) {
			ctx.pathing.step(w);
			ctx.onCondition(() -> ctx.players.getLocal().getLocation().equals(w), 500);
			if (!ctx.players.getLocal().getLocation().equals(w)) {
				ctx.pathing.step(w);
				ctx.onCondition(() -> ctx.players.getLocal().getLocation().equals(w), 500);
				if (!ctx.players.getLocal().getLocation().equals(w)) {
					ctx.pathing.step(w);
					ctx.onCondition(() -> ctx.players.getLocal().getLocation().equals(w), 500);
				}
			}
			Variables.vorkath.lastFireBallMove = System.currentTimeMillis();
			westWalk++;
			if (westWalk >= 5) {
				westWalk = 1;
			}
			attackVorkath();
			//ctx.onCondition(() -> !Variables.vorkath.isFireBallActive(), 3500);
		}
	}
	/*
	 * private void handleFireball() { if (System.currentTimeMillis() -
	 * this.lastFireBallMovement >= 5000) { if
	 * (Variables.vorkath.isFireBallActive()) { WorldPoint startingSpot =
	 * ctx.players.getLocal().getPlayer().getWorldLocation(); WorldPoint westSpot =
	 * new WorldPoint(startingSpot.getX() - 2, startingSpot.getY(),
	 * startingSpot.getPlane()); WorldPoint eastSpot = new
	 * WorldPoint(startingSpot.getX() + 2, startingSpot.getY(),
	 * startingSpot.getPlane()); Random r = new Random(); int choice = r.nextInt(2);
	 * if (choice == 0) { if (ctx.pathing.reachable(westSpot)) {
	 * ctx.pathing.step(westSpot); } else { ctx.pathing.step(eastSpot); }
	 * ctx.sleepCondition(() -> !Variables.vorkath.isFireBallActive(), 5000); } else
	 * { if (ctx.pathing.reachable(eastSpot)) { ctx.pathing.step(eastSpot); } else {
	 * ctx.pathing.step(westSpot); } ctx.sleepCondition(() ->
	 * !Variables.vorkath.isFireBallActive(), 5000); } } } }
	 */

	public void attackVorkath() {
		SimpleNpc vorkath = Variables.vorkath.get();
		if (ctx.getClient().getSpellSelected()) {
			Variables.STATUS = "Deselecting spell";
			ctx.pathing.step(ctx.players.getLocal().getLocation());
		}

		if (vorkath != null && ctx.players.getLocal().getInteracting() == null) {
			Variables.STATUS = "Attacking vorkath";
			vorkath.click("Attack");
		}
	}

	public boolean isPoisonedOrVenomed() {
		return ctx.getClient().getVar(VarPlayer.IS_POISONED) >= 30;
	}

	public void loot() {
		Variables.STATUS = "Looting";
		if (ctx.inventory.populate().population() == 28) {
			Variables.supplies.eatFood();
		}

		SimpleGroundItem loot = ctx.groundItems.populate().next();
		if (loot != null && ctx.inventory.populate().population() < 28) {
			if (loot.validateInteractable()) {
				loot.click("Take");
			}
		}
	}

	public boolean lowHealth() {
		return ctx.players.getLocal().getHealth() <= 77;
	}

	public boolean extremelyLowHealth() {
		return ctx.players.getLocal().getHealth() < 20;
	}

	public boolean quiteLowHealth() {
		return ctx.players.getLocal().getHealth() < 40;
	}

	public void teleportOut() {
		Variables.STATUS = "Low health teleporting out";
		ctx.magic.castHomeTeleport();
		looted = false;
	}

	private boolean isAcidLanding() {
		return ctx.objects.populate().filter(Constants.ACID_TILE_ID).size() > 0 || acidLanding();
	}

	public boolean isAcidPhase2() {
		if (Variables.vorkath.get() == null)
			return false;
		return ctx.objects.populate().filter(Constants.ACID_TILE_ID).size() > 0
				|| Variables.vorkath.get().getAnimation() == Constants.VORKATH_ACID_ATTACK_ANIM_ID
				|| ctx.projectiles.projectileActive(Constants.VORKATH_ACID_ATTACK_PROJECTILE_ID);
	}

	private boolean noAcidExists() {
		return ctx.objects.populate().filter(Constants.ACID_TILE_ID).size() == 0;
	}

	public void handleAcid() {
		SimpleEntityQuery acidObjects = ctx.objects.populate().filter(e -> e.getId() == Constants.ACID_TILE_ID);
		/*
		 * for(SimpleObject a : acidObjects){ } for(SimpleObject p : Sim){ }
		 * ctx.pathing.walkPath();
		 */
	}

	public boolean acidLanding() {
		return ctx.projectiles.projectileActive(1483);
	}

	public void handleAcidBrute() {
		WorldPoint startingSpot = ctx.players.getLocal().getPlayer().getWorldLocation();

		WorldPoint westSpot = new WorldPoint(startingSpot.getX() - 5, startingSpot.getY(), startingSpot.getPlane());
		WorldPoint eastSpot = new WorldPoint(startingSpot.getX() + 5, startingSpot.getY(), startingSpot.getPlane());
		WorldPoint[] west = new WorldPoint[] { westSpot };
		WorldPoint[] start = new WorldPoint[] { startingSpot };
		WorldPoint[] east = new WorldPoint[] { eastSpot };
		// ctx.pathing.running(false);
		while (!Variables.RECOLLECT_ITEMS && Variables.vorkath.inInstance() && acidLanding()) {
			if (quiteLowHealth())
				teleportOut();
			if (ctx.pathing.reachable(westSpot)) {
				if (ctx.pathing.distanceTo(startingSpot) <= 1) {
					ctx.pathing.walkPath(west);
				}
				if (ctx.pathing.distanceTo(westSpot) <= 1) {
					ctx.pathing.walkPath(start);
				}
			} else {
				if (ctx.pathing.distanceTo(startingSpot) <= 1) {
					ctx.pathing.walkPath(east);
				}
				if (ctx.pathing.distanceTo(eastSpot) <= 1) {
					ctx.pathing.walkPath(start);
				}
			}

			if (lowHealth())
				Variables.supplies.eatFood();

		}
		ctx.pathing.running(true);
	}

	private void populateAcidSpots() {
		WorldPoint vorkLoc = Variables.vorkath.get().getLocation();
		final int maxX = vorkLoc.getX() + 14;
		final int minX = vorkLoc.getX() - 8;
		final int maxY = vorkLoc.getY() - 1;
		final int minY = vorkLoc.getY() - 8;
		WorldArea pp = new WorldArea(new WorldPoint(minX, minY, vorkLoc.getPlane()),
				new WorldPoint(maxX, maxY, vorkLoc.getPlane()));
		SimpleQuery acids = ctx.objects.populate().filter(e -> e.getId() == Constants.ACID_TILE_ID).filter(pp);
		System.out.println(acids.size());
		for (Object c : acids) {
			try {
				SimpleObject b = (SimpleObject) c;
				acidSpots.add(b.getLocation());
			} catch (Exception e) {

			}
		}
	}

	private void calculateAcidFreePath() {
		acidFreePath.clear();
		if (Variables.vorkath.get() == null) {
			return;
		}

		final int[][][] directions = { { { 0, 1 }, { 0, -1 } // Positive and negative Y
				}, { { 1, 0 }, { -1, 0 } // Positive and negative X
				} };

		List<WorldPoint> bestPath = new ArrayList<>();
		double bestClicksRequired = 99;

		final WorldPoint playerLoc = ctx.players.getLocal().getLocation();
		final WorldPoint vorkLoc = Variables.vorkath.get().getLocation();
		final int maxX = vorkLoc.getX() + 14;
		final int minX = vorkLoc.getX() - 8;
		final int maxY = vorkLoc.getY() - 1;
		final int minY = vorkLoc.getY() - 8;

		// Attempt to search an acid free path, beginning at a location
		// adjacent to the player's location (including diagonals)
		for (int x = -1; x < 2; x++) {
			for (int y = -1; y < 2; y++) {
				final WorldPoint baseLocation = new WorldPoint(playerLoc.getX() + x, playerLoc.getY() + y,
						playerLoc.getPlane());

				if (acidSpots.contains(baseLocation) || baseLocation.getY() < minY || baseLocation.getY() > maxY) {
					continue;
				}

				// Search in X and Y direction
				for (int d = 0; d < directions.length; d++) {
					// Calculate the clicks required to start walking on the path
					double currentClicksRequired = Math.abs(x) + Math.abs(y);
					if (currentClicksRequired < 2) {
						currentClicksRequired += Math.abs(y * directions[d][0][0]) + Math.abs(x * directions[d][0][1]);
					}
					if (d == 0) {
						// Prioritize a path in the X direction (sideways)
						currentClicksRequired += 0.5;
					}

					List<WorldPoint> currentPath = new ArrayList<>();
					currentPath.add(baseLocation);

					// Positive X (first iteration) or positive Y (second iteration)
					for (int i = 1; i < 25; i++) {
						final WorldPoint testingLocation = new WorldPoint(baseLocation.getX() + i * directions[d][0][0],
								baseLocation.getY() + i * directions[d][0][1], baseLocation.getPlane());

						if (acidSpots.contains(testingLocation) || testingLocation.getY() < minY
								|| testingLocation.getY() > maxY || testingLocation.getX() < minX
								|| testingLocation.getX() > maxX) {
							break;
						}

						currentPath.add(testingLocation);
					}

					// Negative X (first iteration) or positive Y (second iteration)
					for (int i = 1; i < 25; i++) {
						final WorldPoint testingLocation = new WorldPoint(baseLocation.getX() + i * directions[d][1][0],
								baseLocation.getY() + i * directions[d][1][1], baseLocation.getPlane());

						if (acidSpots.contains(testingLocation) || testingLocation.getY() < minY
								|| testingLocation.getY() > maxY || testingLocation.getX() < minX
								|| testingLocation.getX() > maxX) {
							break;
						}

						currentPath.add(testingLocation);
					}

					if (currentPath.size() >= 5 && currentClicksRequired < bestClicksRequired
							|| (currentClicksRequired == bestClicksRequired && currentPath.size() > bestPath.size())) {
						bestPath = currentPath;
						bestClicksRequired = currentClicksRequired;
					}
				}
			}
		}

		if (bestClicksRequired != 99) {
			acidFreePath = bestPath;
		}
	}

	public boolean isHorizontal(List<WorldPoint> path) {
		if (path.size() < 2)
			return false;
		int currX = path.get(0).getX();
		for (int i = 1; i < path.size(); i++) {
			if (path.get(i).getX() != currX)
				return false;
			currX = path.get(i).getX();
		}
		return true;
	}

	public boolean isVertical(List<WorldPoint> path) {
		if (path.size() < 2)
			return false;
		int currY = path.get(0).getY();
		for (int i = 1; i < path.size(); i++) {
			if (path.get(i).getY() != currY)
				return false;
			currY = path.get(i).getY();
		}
		return true;
	}

	public WorldPoint[] sortVertical(List<WorldPoint> path) {

		int minY = 10000000;
		int maxY = 0;
		for (WorldPoint p : path) {
			if (p.getY() < minY)
				minY = p.getY();
			if (p.getY() > maxY)
				maxY = p.getY();
		}
		int size = path.size();
		int xCoord = path.get(0).getX();
		WorldPoint[] result = new WorldPoint[size];
		for (int i = 0; i < size; i++) {
			result[i] = new WorldPoint(xCoord, minY + i, 0);
		}
		return result;

	}

	public void handleAcidCustom(WorldPoint startingSpot) {
		if (acidLanding())
			handleAcidBrute();

		WorldPoint westSpot = new WorldPoint(startingSpot.getX() - 5, startingSpot.getY(), startingSpot.getPlane());
		WorldPoint eastSpot = new WorldPoint(startingSpot.getX() + 5, startingSpot.getY(), startingSpot.getPlane());
		WorldPoint[] west = new WorldPoint[] { westSpot };
		WorldPoint[] start = new WorldPoint[] { startingSpot };
		WorldPoint[] east = new WorldPoint[] { eastSpot };
		// ctx.pathing.running(false);
		boolean isTileSet = false;
		boolean walkedToSetTile = false;
		while (!Variables.RECOLLECT_ITEMS && Variables.vorkath.inInstance() && isAcidLanding()) {
			Variables.STATUS = "Handling acid pathing";
			if (quiteLowHealth())
				teleportOut();

			if (!isTileSet && ctx.objects.populate().filter(Constants.ACID_TILE_ID).size() > 0) {
				WorldPoint w = Variables.vorkath.getSortedPoint();
				if (w != null) {
					startingSpot = w;
					westSpot = new WorldPoint(startingSpot.getX() - 5, startingSpot.getY(), startingSpot.getPlane());
					eastSpot = new WorldPoint(startingSpot.getX() + 5, startingSpot.getY(), startingSpot.getPlane());
					west = new WorldPoint[] { westSpot };
					start = new WorldPoint[] { startingSpot };
					east = new WorldPoint[] { eastSpot };
					isTileSet = true;
					Variables.vorkath.debugTile = w;
				}
			}

			if (!walkedToSetTile && isTileSet) {
				if (ctx.players.getLocal().getLocation().equals(startingSpot)) {
					walkedToSetTile = true;

				} else {
					ctx.pathing.step(startingSpot);
				}
			}

			if (walkedToSetTile || !isTileSet) {

				if (ctx.pathing.reachable(eastSpot)) {
					if (ctx.pathing.distanceTo(startingSpot) <= 1) {
						ctx.pathing.walkPath(east);
					}
					if (ctx.pathing.distanceTo(eastSpot) <= 1) {
						ctx.pathing.walkPath(start);
					}
				} else {
					if (ctx.pathing.distanceTo(startingSpot) <= 1) {
						ctx.pathing.walkPath(west);
					}
					if (ctx.pathing.distanceTo(westSpot) <= 1) {
						ctx.pathing.walkPath(start);
					}
				}
			}

			// if (lowHealth())
			// Variables.supplies.eatFood();

		}
		Variables.vorkath.debugTile = null;
		ctx.pathing.running(true);
	}

	public WorldPoint[] sortHorizontal(List<WorldPoint> path) {

		int minX = 10000000;
		int maxX = 0;
		for (WorldPoint p : path) {
			if (p.getX() < minX)
				minX = p.getX();
			if (p.getX() > maxX)
				maxX = p.getX();
		}
		int size = path.size();
		int yCoord = path.get(0).getY();
		WorldPoint[] result = new WorldPoint[size];
		for (int i = 0; i < size; i++) {
			result[i] = new WorldPoint(minX + i, yCoord, 0);
		}
		return result;

	}

	public WorldPoint[] buildBrutePath() {
		WorldPoint startingSpot = ctx.players.getLocal().getPlayer().getWorldLocation();

		WorldPoint[] result = new WorldPoint[6];
		for (int i = 0; i < result.length; i++) {
			result[i] = new WorldPoint(startingSpot.getX() - i, startingSpot.getY(), startingSpot.getPlane());
		}
		return result;
	}

	@Override
	public String status() {
		return "Fighting vorkath";
	}

}
'''
'''--- tasks/RecollectTask.java ---
package Vorkath.tasks;

import java.util.Arrays;

import Vorkath.Main;
import Vorkath.data.Constants;
import Vorkath.data.Variables;
import Vorkath.data.utils.Utils;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.queries.SimpleItemQuery;
import simple.hooks.scripts.task.Task;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.api.ClientContext;

public class RecollectTask extends Task {
	private Main main;

	public RecollectTask(ClientContext ctx, Main main) {
		super(ctx);
		this.main = main;
	}

	@Override
	public boolean condition() {
		return Variables.RECOLLECT_ITEMS || Variables.FORCE_BANK;
	}

	@Override
	public void run() {
		Variables.STATUS = "Recollecting items";
		if (Variables.RECOLLECT_ITEMS) {
			Variables.FORCE_BANK = false;
			if (collectedAllItems()) {
				Variables.FORCE_BANK = true;
				Variables.RECOLLECT_ITEMS = false;
				return;
			}

			//ctx.log("amount of items: " + getAmountOfItemsInRecoverScreen() + " - isrecoverscreenopen: " + isRecoverScreenOpen() + " - isPayscreenOpen: " + isPayscreenOpen() );
			if (!Constants.VORKATH_START_AREA.containsPoint(ctx.players.getLocal().getLocation())) {
				if (Variables.teleporter.open()) {
					Variables.STATUS = "Recollecting: Teleport to vorkath";
					if (Variables.teleporter.teleportStringPath("Bossing", "Vorkath")) {
						ctx.sleep(150, 400);
					}
				}
			} else if (inventoryIsFull()) {
				if (this.isRecoverScreenOpen()) {
					this.clickRecoverClose();
				} else {
					dropJunk("Manta ray");
					dropJunk("Shark");
					dropJunk("Anglerfish");
					dropJunk("Pineapple pizza");
				}
			} else if (!this.isRecoverScreenOpen()) {
				ctx.log("Opening recoverscreen");
				openRecoverScreen();
			} else if (this.isRecoverScreenOpen() && getAmountOfItemsInRecoverScreen() > 0 && isPayscreenOpen()) {
				ctx.log("Confirming payment");
				// confirm payment
				confirmPayment();
			} else if (this.isRecoverScreenOpen() && getAmountOfItemsInRecoverScreen() > 0 && !isPayscreenOpen()) {
				this.clickRecoverButton();
			} else if (this.isRecoverScreenOpen() && getAmountOfItemsInRecoverScreen() == 0) {
				if (collectedAllItems()) {
					Variables.FORCE_BANK = true;
					Variables.RECOLLECT_ITEMS = false;
					return;
				}
				openRecoverScreen();

				if (ctx.inventory.populate().population() == 28) {
					dropJunk("Manta ray");
					dropJunk("Shark");
					dropJunk("Anglerfish");
					dropJunk("Pineapple pizza");
				}
			}
		} else if (Variables.FORCE_BANK) {
			if (!isGeared()) {
				if (!Constants.EDGEVILE_AREA.containsPoint(ctx.players.getLocal().getLocation())) {
					ctx.magic.castHomeTeleport();
					ctx.onCondition(() -> Constants.EDGEVILE_AREA.containsPoint(ctx.players.getLocal().getLocation()),
							2500);
				} else {
					SimpleObject bank = ctx.objects.populate().filter(10355).nearest().next();
					Variables.STATUS = "Recollecting: Getting last preset";
					bank.click("Last-preset");
					ctx.sleepCondition(() -> ctx.inventory.inventoryFull(), 1500);
				}
			} else {
				Variables.FORCE_BANK = false;
			}
		}
	}

	private void dropJunk(String name) {
		SimpleItemQuery<SimpleItem> items = ctx.inventory.populate().filter(o -> o.getName().toLowerCase().contains(name.toLowerCase()))
				.filterHasAction("Drop");
		for (SimpleItem item : items) {
			ctx.keyboard.pressKey(16);
			item.click(0);
			ctx.keyboard.pressKey(16);
		}
		ctx.sleep(100);
		ctx.keyboard.releaseKey(16);
	}


	public void eatFood() {
		SimpleItem food = ctx.inventory.populate().filterHasAction("Eat").next();

		if (food != null) {
			Variables.STATUS = "Clicking food";
			food.click(0);
		}
	}

	private boolean isGeared() {
		boolean equipped = Arrays.asList(EquipmentSlot.SHIELD, EquipmentSlot.WEAPON, EquipmentSlot.AMULET,
				EquipmentSlot.BODY, EquipmentSlot.LEGS).stream().allMatch(pos -> {
					return ctx.equipment.getEquippedItem(pos) != null;
				});

		return equipped;
	}

	private int getAmountOfItemsInRecoverScreen() {
		int amount = 0;
		if (this.isRecoverScreenOpen()) {
			SimpleWidget w = ctx.widgets.getWidget(602, 3); // container screen
			if (w != null) {
				SimpleWidget[] c = w.getChildren(); // child
				for (SimpleWidget wc : c) {
					if (wc != null && wc.visibleOnScreen()) {
						amount++;
					}
				}
			}
		}
		return amount;
	}

	private void openRecoverScreen() {
		if (this.isRecoverScreenOpen()) {
			this.clickRecoverClose();
		}
		SimpleNpc torfin = ctx.npcs.populate().filter("Torfinn").next();
		if (torfin != null) {
			if (torfin.validateInteractable()) {
				torfin.click("Collect");
				ctx.onCondition(() -> isRecoverScreenOpen(), 3500);
			}
		}
	}

	private void clickRecoverButton() {
		SimpleWidget w = ctx.widgets.getWidget(602, 6); // screen
		if (w != null) {
			Variables.STATUS = "Recovering items";
			w.click(0);
		}
	}

	private void clickRecoverClose() {
		SimpleWidget w = ctx.widgets.getWidget(602, 1); // screen
		if (w != null) {
			// text
			SimpleWidget t = ctx.widgets.getWidget(602, 1).getChild(11);
			if (t != null) {
				t.click(0);
				Variables.STATUS = "Closing screen";
				ctx.onCondition(() -> !this.isRecoverScreenOpen(), 3500);
			}
		}
	}

	private boolean isRecoverScreenOpen() {
		SimpleWidget w = ctx.widgets.getWidget(602, 1); // screen
		if (w != null) {
			// text
			SimpleWidget t = ctx.widgets.getWidget(602, 1).getChild(1);
			if (t != null && t.getText().contains("Retrieval Service")) {
				return true;
			}
		}
		return false;
	}

	private boolean collectedAllItems() {
		SimpleWidget w = ctx.widgets.getWidget(229, 1); // screen
		if (w != null) {
			// text
			if (!w.isHidden() && w.getText().contains("are no items for you")) {
				return true;
			}
		}
		return false;
	}

	private boolean isPayscreenOpen() {
		SimpleWidget w = ctx.widgets.getWidget(219, 1); // screen
		if (w != null) {
			// text
			SimpleWidget t = ctx.widgets.getWidget(219, 1).getChild(0);
			if (t != null && t.getText().contains("unlock your item")) {
				return true;
			}
		}
		return false;
	}

	private void confirmPayment() {
		SimpleWidget w = ctx.widgets.getWidget(219, 1); // screen
		if (w != null) {
			// text
			SimpleWidget c = ctx.widgets.getWidget(219, 1).getChild(1);
			if (c != null) {
				c.click(0);
			}
		}
	}

	private boolean inventoryIsFull() {
		return ctx.inventory.populate().population() == 28;
	}

	@Override
	public String status() {
		return "Restocking";
	}

}

'''
'''--- tasks/WalkerTask.java ---
package Vorkath.tasks;

import Vorkath.Main;
import Vorkath.data.Constants;
import Vorkath.data.Variables;
import simple.hooks.scripts.task.Task;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;

public class WalkerTask extends Task {

	private Main main;

	public WalkerTask(ClientContext ctx, Main main) {
		super(ctx);
		this.main = main;
	}

	@Override
	public boolean condition() {
		return !Variables.RECOLLECT_ITEMS && !Variables.vorkath.inInstance() && ctx.players.getLocal().getHealth() >= 80 && ctx.inventory.populate().population() == 28;
	}

	@Override
	public void run() {
		Variables.STATUS = "Walker task";

		if (!Constants.VORKATH_START_AREA.containsPoint(ctx.players.getLocal().getLocation())) {

			if (Variables.teleporter.open()) {
				Variables.teleporter.teleportStringPath("Bossing", "Vorkath");
				ctx.sleep(150, 400);
				ctx.sleepCondition(
						() -> Constants.VORKATH_START_AREA.containsPoint(ctx.players.getLocal().getLocation()), 1500);
			}
		} else {

			SimpleObject rock = ctx.objects.populate().filter(Constants.START_ROCK_ID).next();
			if (rock != null) {
				rock.turnTo();
				if (rock.validateInteractable())
					rock.click("Climb-over");
				ctx.sleepCondition(() -> Variables.vorkath.inInstance(), 5500);
			}

		}

	}

	@Override
	public String status() {
		return "Walking to vorkath";
	}

}

'''