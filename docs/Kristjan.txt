*GitHub Repository "KristjanPikhof/Zenyte"*

'''--- src/BotUtils/eActions.java ---
package BotUtils;

import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimplePrayers;
import simple.hooks.interfaces.SimpleLocatable;
import simple.hooks.queries.SimpleItemQuery;
import simple.hooks.simplebot.Game;
import simple.hooks.wrappers.*;
import simple.robot.api.ClientContext;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.time.Instant;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Objects;
import java.util.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.stream.Stream;

import static eApiAccess.eAutoResponser.randomSleeping;

public class eActions {

    public static boolean menuActionMode;
    public static boolean specialAttackTool;
    public static final Random random = new Random();
    public static String status = null;
    public static final WorldArea EDGE_HOME_AREA = new WorldArea(new WorldPoint(3110, 3474, 0), new WorldPoint(3074, 3516, 0));
    public static int[] randomEventItems = {7498, 6182, 6180, 6181};
    private static ClientContext ctx;

    public eActions(ClientContext ctx) {
        eActions.ctx = ctx;
    }

    // Utility
    public static void updateStatus(String newStatus) {
        status = newStatus;
        ctx.log(status);
    }

    public static String getCurrentTimeFormatted() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    public static long getCurrentTimeMilli() {
        final Instant currentTime = Instant.now();
        return currentTime.toEpochMilli();
    }

    public static int getRandomInt(int min, int max) {
        return min + random.nextInt(max - min + 1);
    }

    public enum StackableType {
        STACKABLE, NON_STACKABLE, BOTH
    }

    // Functions
    public static void interactWith(SimpleNpc interactable, String menuAction) {
        if (menuActionMode) {
            interactable.menuAction(menuAction);
        } else {
            interactable.click(menuAction);
        }
    }

    public static void interactWith(SimpleObject interactable, String menuAction) {
        if (menuActionMode) {
            interactable.menuAction(menuAction);
        } else {
            interactable.click(menuAction);
        }
    }

    public static void interactWith(SimpleGroundItem interactable, String menuAction) {
        if (menuActionMode) {
            interactable.menuAction(menuAction);
        } else {
            interactable.click(menuAction);
        }
    }

/*    public static SimpleItemQuery<SimpleItem> getItemsFiltered(StackableType type, int... itemIds) {
        return filterByStackableType(ctx.inventory.populate().filter(itemIds), type);
    }*/

    public static SimpleItemQuery<SimpleItem> getItemsFiltered(StackableType type, int... itemIds) {
        if (ctx == null || ctx.inventory == null) {
            return null;  // Return null if ctx or ctx.inventory is not initialized
        }

        SimpleItemQuery<SimpleItem> items = ctx.inventory.populate();
        if (items == null) {
            return null;
        }

        items = items.filter(itemIds);
        if (items == null) {
            return null;
        }

        return filterByStackableType(items, type);
    }

    public static SimpleItemQuery<SimpleItem> getItemsFiltered(StackableType type, String... itemName) {
        return filterByStackableType(ctx.inventory.populate().filter(itemName), type);
    }

/*    public static boolean hasItemsInInventory(StackableType type, int... itemIds) {
        return !getItemsFiltered(type, itemIds).isEmpty();
    }*/

    public static boolean hasItemsInInventory(StackableType type, int... itemIds) {
        SimpleItemQuery<SimpleItem> items = getItemsFiltered(type, itemIds);
        return items != null && !items.isEmpty();
    }

    public static boolean hasItemsInInventory(StackableType type, String... itemNames) {
        return !getItemsFiltered(type, itemNames).isEmpty();
    }

    public static boolean hasNoItemsInInventory(StackableType type, int... itemIds) {
        for (int itemId : itemIds) {
            if (hasItemsInInventory(type, itemId)) {
                return false;
            }
        }
        return true;
    }

    public static boolean hasNoItemsInInventory(StackableType type, String... itemNames) {
        for (String itemName : itemNames) {
            if (hasItemsInInventory(type, itemName)) {
                return false;
            }
        }
        return true;
    }

    public static boolean hasItemsInInventory(StackableType type, List<String> itemList) {
        for (String itemName : itemList) {
            if (hasItemsInInventory(type, itemName)) {
                return true;
            }
        }
        return false;
    }

    private static SimpleItemQuery<SimpleItem> filterByStackableType(SimpleItemQuery<SimpleItem> items, StackableType type) {
        if (type == null) {
            type = StackableType.BOTH;
        }
        switch (type) {
            case STACKABLE:
                return items.filter(SimpleItem::isStackable);
            case NON_STACKABLE:
                return items.filter(item -> !item.isStackable());
            case BOTH:
            default:
                return items;
        }
    }

    public static void handleGroundItem(String menuAction, int... itemId) {
        if (ctx.inventory.inventoryFull()) return;

        if (ctx.groundItems.populate().filter(itemId).filter((i) -> ctx.pathing.reachable(i.getLocation())).isEmpty()) {
            return;
        }

        SimpleGroundItem itemToPickup = ctx.groundItems.populate().filter(itemId).nearest().next();

        if (itemToPickup != null && itemToPickup.validateInteractable()) {
            updateStatus(getCurrentTimeFormatted() + " Picking up " + itemToPickup.getName().toLowerCase());
            eActions.interactWith(itemToPickup, menuAction);
            ctx.onCondition(() -> ctx.groundItems.populate().filter(itemId).isEmpty(), 250, 10);
        }
    }

    public static void handleGroundItem(String menuAction, String... itemName) {
        if (ctx.inventory.inventoryFull()) return;

        if (ctx.groundItems.populate().filter(itemName).filter((i) -> ctx.pathing.reachable(i.getLocation())).isEmpty()) {
            return;
        }

        SimpleGroundItem itemToPickup = ctx.groundItems.populate().filter(itemName).nearest().next();

        if (itemToPickup != null && itemToPickup.validateInteractable()) {
            updateStatus(getCurrentTimeFormatted() + " Picking up " + itemToPickup.getName().toLowerCase());
            eActions.interactWith(itemToPickup, menuAction);
            ctx.onCondition(() -> ctx.groundItems.populate().filter(itemName).isEmpty(), 250, 10);
        }
    }

    private static void changeCameraAngleOnThread(SimpleObject object) {
        // Create a ScheduledExecutorService with a single thread
        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();

        // Turn to desired object
        //ctx.viewport.turnTo(object);

        // Get the current camera orientation angle
        int currentAngle = ctx.viewport.yaw();
        //logger.info("currentAngle : " + currentAngle);

        // Generating a random number between 0 and 30
        int angleChange = randomSleeping(0, 45);
        //logger.info("angleChange : " + angleChange);

        // Getting the sign of the angle change based on the current angle
        if (currentAngle >= 329 || currentAngle <= 30) {
            angleChange = -angleChange; // Make the angle change negative for 329-359 and 0-30 range
        }

        // Calculating the new camera angle by adding the angle change
        int newAngle = (currentAngle + angleChange) % 360;
        //logger.info("newAngle : " + newAngle);

        // Setting the new camera angle
        ctx.viewport.angle(newAngle);

        // Shutting down the executor
        executor.shutdown();
    }

    public static boolean isObjectReachableOffset(WorldPoint objectLocation) {
        int[] offsets = { 0, 1, -1, 2, -2}; // Adjust these offsets as needed
        for (int offsetX : offsets) {
            for (int offsetY : offsets) {
                WorldPoint offsetLocation = new WorldPoint(objectLocation.getX() + offsetX, objectLocation.getY() + offsetY, objectLocation.getPlane());
                if (ctx.pathing.reachable(offsetLocation)) {
                    return true;
                }
            }
        }
        return false;
    }

    public static void specialAttack(int... itemIds) {
        SimplePlayer localPlayer = ctx.players.getLocal();
        int specialAttackPercentage = ctx.combat.getSpecialAttackPercentage();

        if (specialAttackPercentage != 100) {
            return;
        }

        boolean hasSpecialAttackTool = !ctx.equipment.populate()
                .filter(itemIds)
                .isEmpty();

        if (!hasSpecialAttackTool) {
            ctx.log(eActions.getCurrentTimeFormatted() + " Special attack tool: NOT FOUND");
            ctx.log(eActions.getCurrentTimeFormatted() + " Special attack: Deactivated");
            specialAttackTool = false;
            return;
        }

        if (localPlayer.isAnimating() && ctx.combat.toggleSpecialAttack(true)) {
            updateStatus(eActions.getCurrentTimeFormatted() + " Used special attack");
            ctx.game.tab(Game.Tab.INVENTORY);
        }
    }

    public static void specialAttack(String... itemNames) {
        SimplePlayer localPlayer = ctx.players.getLocal();
        int specialAttackPercentage = ctx.combat.getSpecialAttackPercentage();

        if (specialAttackPercentage != 100) {
            return;
        }

        boolean hasSpecialAttackTool = !ctx.equipment.populate()
                .filter(itemNames)
                .isEmpty();

        if (!hasSpecialAttackTool) {
            ctx.log(eActions.getCurrentTimeFormatted() + " Special attack tool: NOT FOUND");
            ctx.log(eActions.getCurrentTimeFormatted() + " Special attack: Deactivated");
            specialAttackTool = false;
            return;
        }

        if (localPlayer.isAnimating() && ctx.combat.toggleSpecialAttack(true)) {
            updateStatus(eActions.getCurrentTimeFormatted() + " Used special attack");
            ctx.game.tab(Game.Tab.INVENTORY);
        }
    }

    public static int getDistanceToPlayer(SimpleLocatable entity) {
        return entity.distanceTo(ctx.players.getLocal());
    }

    public static boolean isWithinRangeToPlayer(SimpleLocatable entity, int range) {
        return entity.distanceTo(ctx.players.getLocal()) >= range;
    }

    public static void walkPath(WorldArea toArea, WorldPoint[] walkPath, boolean reverse) {
        if (!ctx.pathing.inArea(toArea)) {
            handleRunning();
            ctx.pathing.walkPath(walkPath, reverse);
            ctx.sleep(600);
        }
    }
    public static boolean inArea(WorldArea name) {
        return ctx.pathing.inArea(name);
    }

    public static void handleRunning() {
        if (ctx.pathing.energyLevel() > 30 && !ctx.pathing.running() && ctx.pathing.inMotion()) {
            ctx.pathing.running(true);
        }
    }

    public static void handleInventoryItem(String menuAction, int... itemIds) {
        SimpleItem itemInv = ctx.inventory.populate().filter(itemIds).reverse().next();
        if (Objects.equals(menuAction, "Drop")) {
            if (ctx.inventory.shiftDroppingEnabled()) {
                ctx.inventory.dropItem(itemInv);
            }
        } else if (Objects.equals(menuAction, "Bury")) {
            ctx.inventory.populate().filter(itemIds).forEach((item) -> item.click(0));
        } else {
            ctx.inventory.populate().filter(itemIds).forEach((item) -> item.click(menuAction));
        }
    }

    public static void handleInventoryItem(String menuAction, String... itemNames) {
        SimpleItem itemInv = ctx.inventory.populate().filter(itemNames).reverse().next();
        if (Objects.equals(menuAction, "Drop")) {
            if (ctx.inventory.shiftDroppingEnabled()) {
                ctx.inventory.dropItem(itemInv);
            }
        } else if (Objects.equals(menuAction, "Bury")) {
            ctx.inventory.populate().filter(itemNames).filter(item -> !item.isStackable()).forEach(item -> item.click(0));
        } else {
            ctx.inventory.populate().filter(itemNames).forEach((item) -> item.click(menuAction));
        }
    }

    public static int getNotedItemCount(int itemId) {
        return ctx.inventory.populate().filter(itemId).population(true);
    }

    public static int getNotedItemCount(String itemName) {
        return ctx.inventory.populate().filter(itemName).population(true);
    }

    public static int getItemCountInventory(String itemName) {
        return ctx.inventory.populate().filter(itemName).population();
    }

    public static int getItemCountInventory(int itemIds) {
        return ctx.inventory.populate().filter(itemIds).population();
    }

    public static void drawTileMatrix(ClientContext ctx, Graphics2D g, WorldPoint tile, Color colorName) {
        if (ctx != null && ctx.paint != null) {
            ctx.paint.drawTileMatrix(g, tile, colorName);
        }
    }

    public static void clickOnBagWidget() {
        SimpleWidget inventoryBagWidget = ctx.widgets.getWidget(548, 58);
        if (inventoryBagWidget != null) {
            inventoryBagWidget.click(0);
        }
    }

    public static void clickWidget(int wigetId, int childId) {
        SimpleWidget widgetToClick = ctx.widgets.getWidget(wigetId, childId);
        if (widgetToClick == null || widgetToClick.isHidden()) return;
        widgetToClick.click(0);
    }

    public static void clickWidget(SimpleWidget widgetName) {
        if (widgetName == null) return;
        widgetName.click(0);

    }

    public static boolean isWidgetOpen(int wigetId, int childId) {
        SimpleWidget widgetToClick = ctx.widgets.getWidget(wigetId, childId);
        return widgetToClick != null && !widgetToClick.isHidden();
    }

    public static void openTab(Game.Tab tab) {
        if (!isTabOpen(tab))
            ClientContext.instance().game.tab(tab);
    }

    public static boolean isTabOpen(Game.Tab tab) {
        return ClientContext.instance().game.tab().equals(tab);
    }

    public static void zoomOutViewport() {
        SimpleWidget inventoryBagWidget = ctx.widgets.getWidget(548, 58);
        SimpleWidget optionsWidget = ctx.widgets.getWidget(548, 35);
        SimpleWidget displayWidget = ctx.widgets.getWidget(261, 1).getChild(1);
        SimpleWidget displayFixedSize = ctx.widgets.getWidget(263, 33);
        SimpleWidget zoomOutSlider = ctx.widgets.getWidget(261, 9);

        if (optionsWidget == null) return;
        eActions.clickWidget(optionsWidget);

        if (displayWidget == null) return;
        eActions.clickWidget(zoomOutSlider);
        ctx.onCondition(() -> !zoomOutSlider.isHidden(), 50, 20);
        ctx.sleep(50);
        eActions.clickWidget(displayFixedSize);
        ctx.sleep(50);

        eActions.clickWidget(zoomOutSlider);
        eActions.clickWidget(zoomOutSlider);
        eActions.clickWidget(inventoryBagWidget);
    }

    public static String pluralize(int count, String singular, String plural) {
        return count == 1 ? singular : plural;
    }

    public static int getNpcHealth(SimpleNpc npcName) {

        if (npcName != null && npcName.getHealthRatio() != -1) {

            return npcName.getHealthRatio();

        }
        return -1;
    }

    public static WorldPoint getPlayerLocation() {
        return ctx.players.getLocal().getLocation();
    }

    public static String getPlayerName() {
        return ctx.players.getLocal().getName();
    }

    public static void setPrayers(SimplePrayers.Prayers prayerName, boolean set)  {
        if (ClientContext.instance().prayers.prayerActive(prayerName)) {
            ClientContext.instance().prayers.prayer(prayerName, set);
        }
    }

    public static void handlePortalTeleport(String menuElement, String locationName) {
        WorldPoint NEAR_PORTAL_TILE = new WorldPoint(3096, 3502, 0);
        if (!ctx.portalTeleports.portalOpen()) {
            SimpleObject zenytePortal = ctx.objects.populate().filter("Zenyte Portal").nearest().next();
            if (zenytePortal != null) {
                if (ctx.players.getLocal().getLocation().distanceTo(NEAR_PORTAL_TILE) > 5) {
                    BotUtils.eActions.status = "Running to portal";
                    ctx.pathing.step(NEAR_PORTAL_TILE);
                    ctx.onCondition(zenytePortal::visibleOnScreen, 250, 5);
                } else {
                    BotUtils.eActions.status = "Clicking portal";
                    BotUtils.eActions.interactWith(zenytePortal, "Teleport");
                    ctx.onCondition(() -> ctx.portalTeleports.portalOpen(), 250, 5);
                }
            }
        } else {
            BotUtils.eActions.status = "Choosing destination...";
            ctx.portalTeleports.sendTeleport(menuElement, locationName);
            ctx.game.tab(Game.Tab.INVENTORY);
            ctx.onCondition(() -> ctx.players.getLocal().getGraphic() != -1, 250, 5);
        }
    }

    public static void teleportHomeSpellbook() {
        if (ctx.pathing.inArea(EDGE_HOME_AREA)) return;

        BotUtils.eActions.status = "Teleporting to home";
        BotUtils.eActions.openTab(Game.Tab.MAGIC);

        int widgetNumber;
        switch (ctx.magic.spellBook()) {
            case MODERN:
                widgetNumber = 4;
                break;
            case LUNAR:
                widgetNumber = 99;
                break;
            case ANCIENT:
                widgetNumber = 98;
                break;
            case ARCEUUS:
                widgetNumber = 143;
                break;
            default:
                widgetNumber = -1;
        }

        if (widgetNumber != -1) {
            BotUtils.eActions.clickWidget(218, widgetNumber);
        }

        ctx.onCondition(() -> ctx.players.getLocal().getGraphic() != -1 || ctx.pathing.inArea(EDGE_HOME_AREA), 500, 20);
        ctx.game.tab(Game.Tab.INVENTORY);
    }

    public static WorldPoint getRandomLocationWithinArea(int minX, int maxX, int minY, int maxY) {
        int randomX = minX + (int)(Math.random() * ((maxX - minX) + 1));
        int randomY = minY + (int)(Math.random() * ((maxY - minY) + 1));

        return new WorldPoint(randomX, randomY, 0);
    }

    public static boolean inWilderness(int lvl) {
        SimpleWidget w = ctx.widgets.getWidget(90, 67);
        if(w != null && w.visibleOnScreen() && w.getText().toLowerCase().contains("level")) {
            int wildyLevel = Integer.parseInt(w.getText().toLowerCase().split("level: ")[1]);
            return wildyLevel >= lvl;
        }
        return false;
    }

    public static boolean targetIsVisible(SimpleNpc npc, WorldPoint myLocation, ClientContext ctx) {
        if (!npc.visibleOnScreen()) {
            Random rand = new Random();

            int maxAttempts = 100;
            int attempts = 0;

            while (!npc.visibleOnScreen()) {
                //WorldPoint myLocation = ctx.players.getLocal().getLocation(); // Refreshing current location
                WorldPoint npcLocation = npc.getLocation(); // Refreshing target location

                attempts++;
                if (attempts >= maxAttempts) {
                    break;
                }

                // Recalculate the direction based on the new positions
                int directionX = Integer.compare(npcLocation.getX(), myLocation.getX());
                int directionY = Integer.compare(npcLocation.getY(), myLocation.getY());

                // Recalculate the distance to the NPC to adjust movement magnitude
                int currentDistance = myLocation.distanceTo(npc.getLocation());

                if (currentDistance <= 3) {
                    return false;
                }

                // The closer the player is, the smaller the movement magnitude
                int maxMovement = Math.min(currentDistance, 7); // Upper limit is 7
                int minMovement = Math.max(1, currentDistance / 2); // Half the distance but at least 1

                if (maxMovement <= minMovement) {
                    maxMovement = minMovement + 1;  // Ensure that maxMovement is always greater than minMovement
                }

                int movementMagnitude = rand.nextInt(maxMovement - minMovement + 1) + minMovement;

                // Calculate offsets based on the updated direction and movement magnitude
                int xOffset = directionX * movementMagnitude;
                int yOffset = directionY * movementMagnitude;

                // Move towards the target based on the new calculations
                moveToLocation(myLocation, myLocation.getX() + xOffset, myLocation.getY() + yOffset, ctx);
                ctx.sleep(600);
            }
        }

        return  true;
    }

    public static boolean targetIsVisible(SimpleObject object, WorldPoint myLocation, ClientContext ctx) {
        if (!object.visibleOnScreen()) {
            Random rand = new Random();

            int maxAttempts = 100;
            int attempts = 0;

            while (!object.visibleOnScreen()) {
                //WorldPoint myLocation = ctx.players.getLocal().getLocation(); // Refreshing current location
                WorldPoint npcLocation = object.getLocation(); // Refreshing target location

                attempts++;
                if (attempts >= maxAttempts) {
                    break;
                }

                // Recalculate the direction based on the new positions
                int directionX = Integer.compare(npcLocation.getX(), myLocation.getX());
                int directionY = Integer.compare(npcLocation.getY(), myLocation.getY());

                // Recalculate the distance to the NPC to adjust movement magnitude
                int currentDistance = myLocation.distanceTo(object.getLocation());

                if (currentDistance <= 3) {
                    return false;
                }

                ctx.log("Distance to " + object.getName() + ": " + currentDistance);

                // The closer the player is, the smaller the movement magnitude
                int maxMovement = Math.min(currentDistance, 7); // Upper limit is 7
                int minMovement = Math.max(1, currentDistance / 2); // Half the distance but at least 1

                // Check if maxMovement is equal to minMovement, and adjust if necessary
                if (maxMovement <= minMovement) {
                    maxMovement = minMovement + 1;  // Ensure that maxMovement is always greater than minMovement
                }

                int movementMagnitude = rand.nextInt(maxMovement - minMovement + 1) + minMovement;

                // Calculate offsets based on the updated direction and movement magnitude
                int xOffset = directionX * movementMagnitude;
                int yOffset = directionY * movementMagnitude;

                // Move towards the target based on the new calculations
                moveToLocation(myLocation, myLocation.getX() + xOffset, myLocation.getY() + yOffset, ctx);
                ctx.sleep(600);
            }
        }

        return  true;
    }

    public static boolean targetIsVisible(SimpleGroundItem item, WorldPoint myLocation, ClientContext ctx) {
        if (!item.visibleOnScreen()) {
            Random rand = new Random();

            int maxAttempts = 100;
            int attempts = 0;

            while (!item.visibleOnScreen()) {
                //WorldPoint myLocation = ctx.players.getLocal().getLocation(); // Refreshing current location
                WorldPoint npcLocation = item.getLocation(); // Refreshing target location

                attempts++;
                if (attempts >= maxAttempts) {
                    break;
                }

                // Recalculate the direction based on the new positions
                int directionX = Integer.compare(npcLocation.getX(), myLocation.getX());
                int directionY = Integer.compare(npcLocation.getY(), myLocation.getY());

                // Recalculate the distance to the NPC to adjust movement magnitude
                int currentDistance = myLocation.distanceTo(item.getLocation());

                if (currentDistance <= 3) {
                    return false;
                }

                ctx.log("Distance to " + item.getName() + ": " + currentDistance);

                // The closer the player is, the smaller the movement magnitude
                int maxMovement = Math.min(currentDistance, 7); // Upper limit is 7
                int minMovement = Math.max(1, currentDistance / 2); // Half the distance but at least 1

                // Check if maxMovement is equal to minMovement, and adjust if necessary
                if (maxMovement <= minMovement) {
                    maxMovement = minMovement + 1;  // Ensure that maxMovement is always greater than minMovement
                }

                int movementMagnitude = rand.nextInt(maxMovement - minMovement + 1) + minMovement;

                // Calculate offsets based on the updated direction and movement magnitude
                int xOffset = directionX * movementMagnitude;
                int yOffset = directionY * movementMagnitude;

                // Move towards the target based on the new calculations
                moveToLocation(myLocation, myLocation.getX() + xOffset, myLocation.getY() + yOffset, ctx);
                ctx.sleep(600);
            }
        }

        return  true;
    }

    public static void moveToLocation(WorldPoint playerLocation, int x, int y, ClientContext ctx) {
        WorldPoint targetSpot = new WorldPoint(x, y, playerLocation.getPlane());
        ctx.pathing.step(targetSpot);
    }

}

'''
'''--- src/BotUtils/eBanking.java ---
package BotUtils;

import simple.hooks.filters.SimpleBank;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;

import java.util.List;

public class eBanking {
    private static ClientContext ctx;

    public eBanking(ClientContext ctx) {
        eBanking.ctx = ctx;
    }

    //// Bank task methods ////
    public static void bankTask(boolean canUseDepositBox,
                                int bankChestPreferenceOffset,
                                int minItemsInv,
                                boolean withdrawItems,
                                String withdrawItemName,
                                int withdrawAmount,
                                String... notToDepositItemNames) {

        int inventoryPopulation = ctx.inventory.populate().population();

        if (bankIsOpen() && inventoryPopulation >= minItemsInv) {
            eActions.status = "Depositing items";
            ctx.bank.depositAllExcept(notToDepositItemNames);
            if (withdrawItems && !BotUtils.eActions.hasItemsInInventory(null, withdrawItemName)) {
                eActions.status = "Withdrawing items";
                withdrawItem(withdrawItemName, withdrawAmount);
            }
            eActions.status = "Closing bank";
            ctx.bank.closeBank();
            return;
        }

        if (!bankIsOpen()) {
            openClosestBank(canUseDepositBox, bankChestPreferenceOffset);
        }
    }

    public static void bankTask(boolean canUseDepositBox,
                                int bankChestPreferenceOffset,
                                int minItemsInv,
                                boolean withdrawItems,
                                int withdrawItemId,
                                int withdrawAmount,
                                int... notToDepositItemIds) {

        int inventoryPopulation = ctx.inventory.populate().population();

        if (bankIsOpen() && inventoryPopulation >= minItemsInv) {
            eActions.status = "Depositing items";
            ctx.bank.depositAllExcept(notToDepositItemIds);
            if (withdrawItems && !BotUtils.eActions.hasItemsInInventory(eActions.StackableType.BOTH, withdrawItemId)) {
                eActions.status = "Withdrawing items";
                withdrawItem(withdrawItemId, withdrawAmount);
            }
            eActions.status = "Closing bank";
            ctx.bank.closeBank();
            return;
        }

        if (!bankIsOpen()) {
            openClosestBank(canUseDepositBox, bankChestPreferenceOffset);
        }
    }

    public static void bankTask(boolean canUseDepositBox,
                                int bankChestPreferenceOffset,
                                int minItemsInv,
                                boolean withdrawItems,
                                List<String> withdrawItemNames,
                                int withdrawAmount,
                                String... notToDepositItemNames) {

        int inventoryPopulation = ctx.inventory.populate().population();

        if (bankIsOpen() && inventoryPopulation >= minItemsInv) {
            eActions.status = "Depositing items";
            ctx.bank.depositAllExcept(notToDepositItemNames);

            if (withdrawItems) {
                for(String itemName : withdrawItemNames) {
                    if(!BotUtils.eActions.hasItemsInInventory(null, itemName)) {
                        eActions.status = "Withdrawing items";
                        withdrawItem(itemName, withdrawAmount);
                    }
                }
            }
            eActions.status = "Closing bank";
            ctx.bank.closeBank();
            return;
        }

        if (!bankIsOpen()) {
            openClosestBank(canUseDepositBox, bankChestPreferenceOffset);
        }
    }

    public static void bankTask(boolean canUseDepositBox,
                                int bankChestPreferenceOffset,
                                int minItemsInv,
                                boolean withdrawItems,
                                List<Integer> withdrawItemIds,
                                int withdrawAmount,
                                int... notToDepositItemIds) {

        int inventoryPopulation = ctx.inventory.populate().population();

        if (bankIsOpen() && inventoryPopulation >= minItemsInv) {
            eActions.status = "Depositing items";
            ctx.bank.depositAllExcept(notToDepositItemIds);

            if (withdrawItems) {
                for(int itemId : withdrawItemIds) {
                    if(!BotUtils.eActions.hasItemsInInventory(null, itemId)) {
                        eActions.status = "Withdrawing items";
                        withdrawItem(itemId, withdrawAmount);
                    }
                }
            }
            eActions.status = "Closing bank";
            ctx.bank.closeBank();
            return;
        }

        if (!bankIsOpen()) {
            openClosestBank(canUseDepositBox, bankChestPreferenceOffset);
        }
    }
    //// Bank task methods ////

    public static void openClosestBank(boolean canUseDepositBox, int bankChestPreferenceOffset) {

        SimpleObject bankChest = getClosestBankChest();
        SimpleNpc banker = getClosestBanker();
        SimpleObject depositBox = getClosestDepositBox();

        double distToBankChest = (bankChest != null) ? ctx.players.getLocal().getLocation().distanceTo(bankChest.getLocation()) : Double.MAX_VALUE;
        double distToBanker = (banker != null) ? ctx.players.getLocal().getLocation().distanceTo(banker.getLocation()) : Double.MAX_VALUE;
        double distToDepositBox = (depositBox != null) ? ctx.players.getLocal().getLocation().distanceTo(depositBox.getLocation()) : Double.MAX_VALUE;

        // Introduce a preference offset for the bank chest.
        distToBankChest -= bankChestPreferenceOffset;

        // Determine the closest banking method
        double minDistance = Math.min(distToBankChest, Math.min(distToBanker, distToDepositBox));

        if (minDistance == distToBankChest) {
            useBankObject(bankChest);
        } else if (minDistance == distToBanker) {
            useBanker(banker);
        } else if (minDistance == distToDepositBox && canUseDepositBox) {
            useBankObject(depositBox);
        } else {
            eActions.updateStatus("No bank found nearby");
        }
    }

    public static void useBankObject(SimpleObject objectName) {
        if (objectName == null) return;

        if (!objectName.visibleOnScreen()) {
            if (ctx.players.getLocal().getLocation().getRegionID() == 6198) {
                ctx.pathing.step(1591, 3477);
            } else {
                ctx.pathing.step(objectName.getLocation());
            }
        } else {
            if (BotUtils.eActions.menuActionMode) {
                objectName.menuAction("Bank");
            } else {
                objectName.click(0);
            }
            ctx.onCondition(eBanking::bankIsOpen, 250, 20);
        }

/*        if (eActions.targetIsVisible(objectName, eActions.getPlayerLocation(), ctx)) {
            if (BotUtils.eActions.menuActionMode) {
                objectName.menuAction("Bank");
            } else {
                objectName.click(0);
            }
            ctx.onCondition(eBanking::bankIsOpen, 250, 20);
        }*/
    }

    public static void useBanker(SimpleNpc bankerNpc) {
        if (bankerNpc == null) return;

        if (!bankerNpc.visibleOnScreen()) {
            ctx.pathing.step(bankerNpc.getLocation());
        } else {
            BotUtils.eActions.interactWith(bankerNpc, "Bank");
            ctx.onCondition(eBanking::bankIsOpen, 250, 20);
        }
/*        if (eActions.targetIsVisible(bankerNpc, eActions.getPlayerLocation(), ctx)) {
            BotUtils.eActions.interactWith(bankerNpc, "Bank");
            ctx.onCondition(eBanking::bankIsOpen, 250, 20);
        }*/

    }

    public static SimpleObject getClosestDepositBox() {
        return ctx.objects.populate().filter(eData.Banking.DEPOSIT_BOX).nearest().next();
    }

    public static SimpleObject getClosestBankChest() {
        return ctx.objects.populate().filter(eData.Banking.BANK_NAMES).nearest().next();
    }

    public static SimpleNpc getClosestBanker() {
        return ctx.npcs.populate().filter(eData.Banking.BANKER_NAMES).nearest().next();
    }

    public static boolean bankIsOpen() {
        SimpleBank bank = ctx.bank;
        return bank.bankOpen() || bank.depositBoxOpen();
    }

    public static void withdrawItem(String itemName, int withdrawAmount) {
        if (ctx.bank.bankOpen() && !ctx.bank.populate().filter(itemName).isEmpty()){
            ctx.bank.withdraw(itemName, withdrawAmount);
            ctx.onCondition(() -> BotUtils.eActions.hasItemsInInventory(null, itemName), 250, 10);
        }
    }

    public static void withdrawItem(int itemId, int withdrawAmount) {
        if (ctx.bank.bankOpen() && !ctx.bank.populate().filter(itemId).isEmpty()){
            ctx.bank.withdraw(itemId, withdrawAmount);
            ctx.onCondition(() -> BotUtils.eActions.hasItemsInInventory(null, itemId), 250, 10);
        }
    }
}

'''
'''--- src/BotUtils/eData.java ---
package BotUtils;

import simple.robot.api.ClientContext;

public class eData {

    public static ClientContext ctx;

    public eData(ClientContext ctx) {
        eData.ctx = ctx;
    }

    public static class Banking {
        public static final String[] BANK_NAMES = {"Bank booth", "Bank chest", "Bank counter"};
        public static final String DEPOSIT_BOX = "Bank Deposit Box";
        public static final String[] BANKER_NAMES = {
                "Banker", "Arnold Lydspor", "Banker tutor", "Cornelius", "Emerald Benedict", "Eniola", "Fadli", "Financial Wizard", "Financial Seer", "Ghost banker", "Gnome banker", "Gundai", "Jade", "Jumaane", "Magnus Gram", "Nardah Banker", "Odovacar", "Peer the Seer", "Sirsal Banker", "Squire", "TzHaar-Ket-Yil", "TzHaar-Ket-Zuh", "Yusuf"
        };
    }

    public static class Woodcutting {
        public static final String[] SPECIAL_ATTACK_TOOL = {
                "Dragon axe (or)",
                "Infernal axe",
                "Dragon axe"
        };

        public static final String[] WOODCUTTING_AXE = {
                "Bronze axe",
                "Iron axe",
                "Steel axe",
                "Blessed axe",
                "Gilded axe",
                "3rd age axe",
                "Black axe",
                "Mithril axe",
                "Adamant axe",
                "Rune axe",
                "Dragon axe",
                "Infernal axe",
                "Crystal axe"
        };
    }

    public static class Fishing {
        public static final String[] SPECIAL_ATTACK_TOOL = {
                "Dragon harpoon",
        };

        public static final String[] EQUIPMENT = {
                "Fishing rod",
                "Sandworms",
        };

        //public static final int[] EQUIPMENT = {307, 13431};
    }

    public static class Mining {
        public static final String[] SPECIAL_ATTACK_TOOL = {
                "Dragon pickaxe",
        };

        public static final int[] EQUIPMENT_NOT_TO_BANK = {30742, 20014, 13243, 12797, 12297, 11920, 1275, 1273, 1271, 1269, 1267, 1265};
    }

}

'''
'''--- src/BotUtils/eImpCatcher.java ---
package BotUtils;

import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.task.Task;
import simple.hooks.wrappers.SimpleNpc;
import simple.robot.api.ClientContext;

public class eImpCatcher extends Task {

    public eImpCatcher(ClientContext ctx) {
        super(ctx);
    }

    public enum Impling {
        NINJA("Ninja impling", 84),
        CRYSTAL("Crystal impling", 90),
        DRAGON("Dragon impling", 93),
        LUCKY("Lucky impling", 99);

        private final String name;
        private final int level;

        Impling(String name, int level) {
            this.name = name;
            this.level = level;
        }

        public String getName() {
            return name;
        }

        public int getHunterLevel() {
            return level;
        }
    }

    @Override
    public boolean condition() {
        return !ctx.inventory.inventoryFull() && validImplingExists(ctx.skills.realLevel(SimpleSkills.Skills.HUNTER));
    }

    private boolean validImplingExists(int hunterLevel) {
        for (Impling impling : Impling.values()) {
            if (hunterLevel >= impling.getHunterLevel() && npcIsValid(impling.getName())) {
                return true;
            }
        }
        return false;
    }

    @Override
    public void run() {
        int hunterLevel = ctx.skills.realLevel(SimpleSkills.Skills.HUNTER);

        // Find the highest-level impling that can be catched
        Impling targetImpling = null;
        for (Impling impling : Impling.values()) {
            if (hunterLevel >= impling.getHunterLevel()) {
                targetImpling = impling;
            }
        }

        if (targetImpling != null) {
            SimpleNpc npc = ctx.npcs.populate().filter(targetImpling.getName()).filterHasAction("Catch").next();
            if (npc != null && npc.validateInteractable() && ctx.pathing.reachable(npc.getLocation())) {
                eActions.status = "Catching " + npc.getName();
                eActions.interactWith(npc, "Catch");
                ctx.onCondition(() -> npc == null, 250, 12);
                ctx.log(eActions.getCurrentTimeFormatted() + " I got " + npc.getName());
            }
        }
    }

    public boolean npcIsValid(String name) {
        SimpleNpc npc = ctx.npcs.populate().filter(name).filterHasAction("Catch").next();
        return npc != null && ctx.pathing.reachable(npc.getLocation());
    }

    @Override
    public String status() {
        return "Catching Impling";
    }

}

'''
'''--- src/BotUtils/eLogGenius.java ---
package BotUtils;

import net.runelite.api.ChatMessageType;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.*;
import simple.robot.api.ClientContext;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

public class eLogGenius {

    private final ClientContext ctx;
    private long previousTime;

    private String getCurrentTimeFormatted() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm:ss"));
    }

    public eLogGenius(ClientContext ctx) {
        this.ctx = ctx;
        previousTime = System.currentTimeMillis();
    }

    // Print functions
    public void print(String message) {
        System.out.println(getCurrentTimeFormatted() + " | " + message);
    }
    public void log(String formattedMessage) { // Will log String message to a file
        logToFile(formattedMessage);
    }

    public void updateStatus(String message) {
        ctx.log(getCurrentTimeFormatted() + " | " + message);
    }

    public void printElapsedTime(String functionName) { // Add to the start and finish of your function / add in flow at the end of code each block to track elapsed time
        long currentTime = System.currentTimeMillis();
        long elapsedTime = currentTime - previousTime;
        previousTime = currentTime;
        System.out.println("Elapsed time (ms): " + elapsedTime + " at " + functionName);
    }

    // isValid check functions - these will return boolean and System.out.println as colored message.
    public boolean isValid(SimpleNpc npc) {
        boolean isValid = npc != null && npc.validateInteractable();
        String message = (isValid ? npc.getName() : "npc") + " is " + (isValid ? "valid" : "not valid");
        printColoredMessage(message, isValid);
        return isValid;
    }

    public boolean isValid(SimpleObject object) {
        boolean isValid = object != null && object.validateInteractable();
        String message = (isValid ? object.getName() : "object") + " is " + (isValid ? "valid" : "not valid");
        printColoredMessage(message, isValid);
        return isValid;
    }

    public boolean isValid(SimpleGroundItem groundItem) {
        boolean isValid = groundItem != null && groundItem.validateInteractable();
        String message = (isValid ? groundItem.getName() : "ground object") + " is " + (isValid ? "valid" : "not valid");
        printColoredMessage(message, isValid);
        return isValid;
    }

    public boolean isValid(SimpleItem item) {
        boolean isValid = item != null && item.getId() != -1;
        String message = (isValid ? item.getName() : "item") + " is " + (isValid ? "valid" : "not valid");
        printColoredMessage(message, isValid);
        return isValid;
    }

    public boolean isValid(SimpleWidget widget) {
        boolean isValid = widget != null && !widget.isHidden();
        String message = (isValid ? widget.getName() : "widget") + " is " + (isValid ? "valid" : "not valid");
        printColoredMessage(message, isValid);
        return isValid;
    }

    // ChatMessages functions
    public void printAllChats(ChatMessage m, boolean logMessage) { // Will print all chat types and messages / boolean logMessage will log message to a file.
        ChatMessageType messageType = m.getType();
        String sender = m.getChatEvent().getName();
        String message = m.getChatEvent().getMessage();
        String formattedMessage = formatChatMessage(messageType, sender, message);
        if (logMessage) {
            log(formattedMessage);
        }
        System.out.println(formattedMessage);
    }

    public boolean printChatType(ChatMessage m, ChatMessageType targetType, boolean logMessage) { // Will print selected chat type messages / boolean logMessage will log message to a file.
        ChatMessageType messageType = m.getType();
        if (messageType == targetType) {
            printAllChats(m, logMessage);
            return true;
        }
        return false;
    }

    public boolean printChatContaining(ChatMessage m, String searchString, boolean logMessage) { // Will return boolean and print messages containing String / boolean logMessage will log message to a file.
        String message = m.getMessage().toLowerCase();
        searchString = searchString.toLowerCase();
        if (message.contains(searchString)) {
            printAllChats(m, logMessage);
            return true;
        }
        return false;
    }

    // Utility - Do not change
    private void printColoredMessage(String message, boolean isValid) { // to change color for isValid() messages
        if (isValid) {
            System.out.println("\u001B[32m" + getCurrentTimeFormatted() + " | " + message + "\u001B[0m"); // Red text
        } else {
            System.out.println("\u001B[31m" + getCurrentTimeFormatted() + " | " + message + "\u001B[0m"); // Green text
        }
    }

    private String formatChatMessage(ChatMessageType messageType, String sender, String message) {
        StringBuilder formattedMessage = new StringBuilder();
        formattedMessage.append(getCurrentTimeFormatted()).append(" | ");
        formattedMessage.append("Message via ").append(messageType).append(" ");

        if (sender != null && !sender.isEmpty()) {
            sender = sender.replaceAll("\\[|\\]", "");
            sender = sender.replaceAll("<[^>]*>", "");
            formattedMessage.append("by ").append(sender).append(" ");
        }

        message = message.replaceAll("<[^>]*>", "");
        formattedMessage.append("says: ").append(message);

        return formattedMessage.toString();
    }

    private void logToFile(String message) {
        String fileName = "eLogGenius_Logs.txt";
        try {
            FileWriter fileWriter = new FileWriter(fileName, true); // 'true' for append mode
            PrintWriter printWriter = new PrintWriter(fileWriter);
            printWriter.println(message);
            printWriter.close();
        } catch (IOException e) {
            print("There has been problem with logging to text file: " + e);
        }
    }

}
'''
'''--- src/BotUtils/eWildyTeleport.java ---
package BotUtils;

import net.runelite.api.coords.WorldPoint;
import simple.hooks.scripts.task.Task;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimplePlayer;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.api.ClientContext;

public class eWildyTeleport extends Task {

    private static ClientContext ctx;
    private final WorldPoint GNOME_TILE = new WorldPoint(2465, 3495, 0);

    public eWildyTeleport(ClientContext ctx) {
        super(ctx);
        eWildyTeleport.ctx = ctx;
    }

    @Override
    public boolean condition() {
        return eActions.inWilderness(1) && gettingAttackedByPlayer();
    }

    @Override
    public void run() {
        if (eActions.inWilderness(31)) {
            runningSouth();
        } else {
            gettingAttackedGTFO();
        }
    }

    public void gettingAttackedGTFO() {
        SimpleItem pod = ctx.inventory.populate().filter("Royal seed pod").next();

        if (!ctx.pathing.onTile(GNOME_TILE)) {
            if (pod != null) {
                pod.click(0);
                pod.click(0);
                pod.click(0);
                pod.click(0);
                pod.click(0);
                pod.click(0);
            } else {
                alternativeGTFOMethod();
            }
        } else {
            ctx.sendLogout();
            ctx.stopScript();
        }
    }

    public boolean gettingAttackedByPlayer() {
        String localPlayerName = ctx.players.getLocal().getName();

        for (SimplePlayer p : ctx.players.populate().filter(p -> !p.getName().equals(localPlayerName))) {
            if (p.getInteracting() != null &&
                    p.getInteracting().getName() != null &&
                    p.getInteracting().getName().equals(localPlayerName)) {
                return true;
            }
        }
        return false;
    }

    private void runningSouth() {
        WorldPoint startingSpot = ctx.players.getLocal().getPlayer().getWorldLocation();
        WorldPoint southSpot = new WorldPoint(startingSpot.getX(), startingSpot.getY() - 5, startingSpot.getPlane());
        ctx.pathing.step(southSpot);
    }

    private void alternativeGTFOMethod() {
        if (eActions.inWilderness(21)) {
            runningSouth();
        } else {
            usingTeleportTabToGTFO();
        }
    }

    public void usingTeleportTabToGTFO() {
        SimpleItem tab = ctx.inventory.populate().filter(22721).next();

        if (!ctx.pathing.onTile(GNOME_TILE)) {
            if (tab != null) {
                tab.click(0);
                tab.click(0);
                tab.click(0);
                tab.click(0);
                tab.click(0);
                tab.click(0);
            }
        } else {
            ctx.sendLogout();
            ctx.stopScript();
        }
    }

    @Override
    public String status() {
        return "Getting Attacked! " + "Teleporting!";
    }
}

'''
'''--- src/MyHelpers/Threads/eMain.java ---
package MyHelpers.Threads;

import BotUtils.eActions;
import BotUtils.eBanking;
import BotUtils.eData;
import BotUtils.eLogGenius;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimplePlayer;

import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;

import static eApiAccess.eAutoResponser.botStarted;
import static eApiAccess.eAutoResponser.gptDeactivation;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.OTHER,
        description = "<html>"
                + "<p>The most effective bot on Zenyte!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>---</li>"
                + "<li>---</li>"
                + "<li>Chat GPT answering is integrated.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eScriptName",
        servers = {"Zenyte"},
        version = "0.1"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final String eBotName = "eScriptName";
    private static final String ePaintText = "Actions made";
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.THIEVING;

    // Variables
    private int count;
    private static eAutoResponderGui guiGpt;
    public static boolean hidePaint = false;
    private long startTime = 0L;
    private long startingSkillExp;
    private long startingSkillLevel;
    eLogGenius elog = new eLogGenius(ctx);

    // Gui GPT
    private void initializeGptGui() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        eBanking bankingUtils = new eBanking(ctx);
        eActions actionUtils = new eActions(ctx);
        eData dataUtils = new eData(ctx);
        eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx)));
        initializeMethods(); // BotUtils
        initializeGptGui(); // GPT
        eAutoResponser.scriptPurpose = "you're just playing. ";
        gptDeactivation();

        // Other vars
        ctx.log("--------------- " + eActions.getCurrentTimeFormatted() + " ---------------");
        ctx.log("-------------------------------------");
        ctx.log("            " + eBotName + "         ");
        ctx.log("-------------------------------------");

        // Vars
        eActions.updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        count = 0;
        ctx.viewport.angle(180);
        ctx.viewport.pitch(true);
        eActions.zoomOutViewport();
    }

    @Override
    public void onProcess() {
        super.onProcess();

        final SimplePlayer localPlayer = ctx.players.getLocal();

        if (!botStarted) {
            eActions.status = "Please start the bot!";
            return;
        }

        eActions.handleRunning();

    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log(ePaintText + ": " + count);
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        String senderName = m.getChatEvent().getName();
        String gameMessage = m.getChatEvent().getMessage();

        if (m.getMessage() == null) {
            return;
        }

        if (elog.printChatContaining(m,"successfully pick the", false)) {
            count += 1;
        }

        eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        eTriviaInfo.handleBroadcastMessage(getType, gameMessage);
    }

    @Override
    public int loopDuration() {
        return 600;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePaintText + ": " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + eActions.status, 15, 225);

        }
    }
}

'''
'''--- src/MyHelpers/Threads/eThreads.java ---
package MyHelpers.Threads;

public class eThreads {

    // how to use:
    //logger.info("Number of threads running: " + eThreads.getActiveThreadCount());
    public static int getActiveThreadCount() {
        ThreadGroup rootGroup = Thread.currentThread().getThreadGroup();
        int activeCount = rootGroup.activeCount();
        int threadCount = activeCount;
        Thread[] threads = new Thread[activeCount];
        rootGroup.enumerate(threads, false);
        for (Thread thread : threads) {
            if (thread == null)
                continue;
            ThreadGroup group = thread.getThreadGroup();
            while (group != null && group.getParent() != null) {
                group = group.getParent();
            }
            if (group == rootGroup) {
                threadCount++;
            }
        }
        return threadCount;
    }
}

'''
'''--- src/Utility/Trivia/eTriviaInfo.java ---
package Utility.Trivia;

import BotUtils.eActions;
import java.util.logging.Logger;

import net.runelite.api.ChatMessageType;
import simple.robot.api.ClientContext;

import static eApiAccess.eAutoResponser.randomSleeping;

public class eTriviaInfo {

    public static ClientContext ctx;
    public eTriviaInfo(ClientContext ctx) {
        eTriviaInfo.ctx = ctx;
    }
    public static String triviaAnswer;
    private static final Logger logger = Logger.getLogger(eTriviaInfo.class.getName());

    // Trivia action
    public static void sendAnswer(String answer) {
        if (answer == null) {
            return;
        }

        if (ctx.dialogue.dialogueOpen()) {
            ctx.dialogue.clickContinue();
        }

        StringBuilder writeAnswer = new StringBuilder("::ans ");
        writeAnswer.append(answer);

        Thread thread = new Thread(() -> {
            try {
                int sleepTime = randomSleeping(5000, 10000);
                eActions.updateStatus(eActions.getCurrentTimeFormatted() + " [Trivia] Sleeping for " + sleepTime + "ms");
                Thread.sleep(sleepTime); // Randomized delay
                ctx.keyboard.sendKeys(writeAnswer.toString());
                triviaAnswer = null;
                eActions.updateStatus(eActions.getCurrentTimeFormatted() + " [Trivia] Question answered!");
                eActions.updateStatus(eActions.getCurrentTimeFormatted() + " [Trivia] A: " + answer);
            } catch (InterruptedException e) {
                logger.severe("Error while sending answer: " + e.getMessage());
            }
        });
        thread.start();
    }

    public static void handleBroadcastMessage(ChatMessageType type, String message) {
        if (type == ChatMessageType.BROADCAST) {
            String gameMessageTrimmed = message.replaceAll("<[^>]+>", "").trim();
            if (gameMessageTrimmed.contains("Trivia")) {
                handleTriviaQuestion(gameMessageTrimmed);
            }
        }
    }

    public static void handleTriviaQuestion(String gameMessageTrimmed) {
        for (eTriviaInfo.TriviaQuestion triviaQuestion : eTriviaInfo.TriviaQuestion.values()) {
            if (gameMessageTrimmed.contains(triviaQuestion.getQuestion())) {
                triviaAnswer = triviaQuestion.getAnswer();
                sendAnswer(triviaAnswer);
                break;
            }
        }
    }

    public enum TriviaQuestion {
        FALADOR_MASSACRE("year did the Falador Massacre originally occur", "2006"),
        DWARHAMMER_DROPRATE("dragon warhammer is a 1 in", "2000"),
        MAX_COMBAT("is the maximum combat level", "126"),
        MYTH_GUILD("boss slayer master located", "Myth guild"),
        DRAMEN_STAFF("need to travel by Fairy Ring", "Dramen"),
        KALPHITE_QUEEN("is combat level of the Kalphite Queen", "333"),
        WYSON("discovered giant moles", "Wyson"),
        ARDY_COURSE("highest level rooftop Agility course", "Ardougne"),
        STEAM_RUNES("Steam runes are a combination of water and which other rune", "Fire"),
        SLAY_MASTERS("slayer masters are there in zenyte", "9"),
        DRAGON_WHAMMER_SPEC("stat does the dragon warhammer special attack decrease", "defence"),
        CORP_WILDY_LVL("Wilderness level is the Corporal Beasts lair", "21"),
        ELY_DROP_RATE("lysian sigil is a 1 in ????", "2304"),
        DRAGON_MACE("special attack energy does the Dragon mace special attack use", "25%"),
        INFERNAL_EELS("fishing level is required to fish Infernal eels", "80"),
        ANDREW_GOWER("one of the original creators of Runescape", "Andrew Gower"),
        KARAMBWANJI("is the name of the stackable fish that", "Karambwanji"),
        THIEVING_MASTER_FARMER("level is required to pickpocket Master farmers", "38"),
        FIGHT_CAVES("wave number do donators start the fight caves at", "31"),
        DRAGON_HARPOON("combine a smouldering stone to a dragon harpoon", "85"),
        WESTERN_ACHIEVEMENT("Achievement Diary gives you Unlimited Teleports to the Piscatoris Fishing Colony", "Western province"),
        ENCHANT_DCROSSBOW_BOLT("dragonstone crossbow bolts cost 1 cosmic, 10 soul, and 15 of", "Earth"),
        LUCKY_IMPLING("99 Hunter to catch barehanded", "Lucky"),
        MAX_ITEMS("max limit for a single item stack in Runescape", "2147483647"),
        POISON_BOLTS("type of enchanted bolt can inflict poison damage", "Emerald"),
        INCREDIBLE_REFLEXES("activate the Incredible Reflexes", "34"),
        MINE_CRYSTAL_LVL("mining level to be able to mine crystal shards", "94"),
        LUNAR_SPIN_FLAX("spin per cast of the Lunar Spin Flax", "5"),
        ALI_RESCUE("OSRS quest can you complete to pass through the gates to Al Kharid for free", "Prince Ali Rescue"),
        KYLIE_MINNOW("the fish you can trade to an NPC named Kylie","Minnow"),
        GRAIN_PLENTY("floor is the Grain of Plenty located on","Second"),
        CONVERT_VOID("many points is it to upgrade a SINGLE piece of void into elite", "40"),
        FIRELIGHTERS_TYPES("many types of firelighters are", "5"),
        JATIZSO_ORES("Jatizso contains adamantite, tin, coal, and which other", "Mithril"),
        WINTERTODT_CONTINENT("continent is Wintertodt located on", "Zeah"),
        ZENYTE_HOME("name of the town where Zenyte's home is", "Edgeville"),
        CERBERUS_RED_DROP("name of the red crystal dropped by Cerberus", "Primordial"),
        FAIRY_MISCELLANIA("is the fairy ring code for Miscellania", "cip"),
        CERBERUS_PURPLE_DROP("name of the purple crystal dropped by Cerberus", "Eternal"),
        TOAD_LEGS("??? legs are used in Gnome cooking", "Toad"),
        BARROWS_GLOVES("defense level is required to wear Barrows gloves", "40"),
        PICKPOCKET_ELF("thieving level is required to pickpocket an elf", "85"),
        INFERNO_WAVES("many inferno waves are there", "69"),
        SKILLING_OUTFIT_RATE("drop rate of any skilling outfit piece whilst", "1/1000"),
        SANDSTONE_WEIGHT("largest weight of sandstone you can mine", "10kg"),
        SMOKE_DUNGEON("equipment is required to survive the Smoke Dungeon", "Face mask"),
        TORN_SCROLL("do you obtain a torn prayer scroll", "Cox"),
        KRAKEN_ENHANCE("you need 10 of to enchant the trident of the", "Kraken"),
        THIRDAGE_CLOAK("3rd age cloak is obtained from which tier clues", "Elite"),
        FULL_GRACE("Marks of Grace does full Graceful cost on Zenyte", "104"),
        ZENYTE_MAX_TOTAL("is the current max total level in Zenyte", "2179"),
        DS2_FINAL_BOSS("final boss you defeat in Dragon Slayer II", "Galvek"),
        COMBAT_ARCHIEVEMENTS("you the jad slayer helmet recolour", "Elite"),
        CRYSTAL_MINE("is the required mining level to be able to mine crystal", "94"),
        UPGRADE_VOID("many points is it to upgrade a SINGLE piece of void into elite", "40"),
        WHITE_CASTLE("what city is the White Knights castle located", "Falador"),
        SUPER_DEFENCE_MIX("level to make super defense mix", "71"),
        DRAGON_MACE_SPEC("does the Dragon mace special attack use", "25%"),
        NPC_NIEVE("NPC to be found wearing an Elysian Spirit Shield", "Nieve"),
        DARK_CORE_PET("drops the pet Dark core", "Corp"),
        SAILING_SKILL("Name one skill that was polled in OSRS but didn", "Sailing"),
        ZULRAH_LVL("combat level of Zulrah", "725"),
        MORE_VOTE_REWARDS("can earn more vote rewards by having what", "2fa"),
        MAGIC_TREE("tree requires 75 Woodcutting to cut", "Magic"),
        MAGIC_ECCENCE("level is required to make a Magic Essence mix", "61"),
        TWISTED_BOW("s damage is scaled based on the targets", "Twisted bow"),
        HUNTER_TRAPS("hunter level is required to lay 5 traps", "80"),
        CRYSTAL_EQUIPMENT("agility level is required to use crystal equipment", "50"),
        B0ATY_NUMBER("is the famous 'b0aty' number", "73"),
        WILD_PIE("A Wild Pie is made from raw rabbit,", "Chompy"),
        DRAGON_DAGGER("one of the items unlocked upon completion of The Lost City", "Dragon dagger"),
        ZENYTE_YEAR("zenyte released to the public?", "2019"),
        TOB_ZENYTE("Theatre of Blood release to the public on Zenyte?", "2022"),
        ZENYTE_JACKIE("person that sells various skilling tools at home", "Jackie"),
        SLAYER_CHAELDAR("name of the Fairy Slayer Master", "Chaeldar"),
        BALLISTA_AMMMO("type of ammunition is used in the ballista", "Javelins"),
        GODS_ALE("do you obtain an ale of the gods", "clue scroll reward"),
        GUTHIX_BOOK("name of the completed god book of Guthix", "Balance"),
        INJURE_CERBERUS("Slayer level do you need to be able to injure Cerberus", "91"),
        RUNES_IN_RUNEPACK("many runes are inside of a rune pack", "100"),
        GOD_HIDE_SETS("hide sets are there in game?", "6"),
        ADAMANT_BAR("smithing an Adamant bar in a regular furnace", "6"),
        HUNTER_SIREN("Hunter level is required in order to catch a Greater Siren", "87"),
        SUPERCOMPOST_MADEOF("type of compost do coconut shells produce when placed into a composting", "supercompost"),
        WILDY_BOSS_DRAGON("considered a Wilderness boss", "King Black Dragon"),
        COOKING_SHARKS("cooking level do you need to be able to cook sharks", "80"),
        RUBY_AMULET("magic level is required to enchant a ruby", "49"),
        JAD_HELMET("tier completion unlocks you the jad slayer helmet recolour", "Elite"),
        AVERIC_DEFENDER("is the best defender in the game called", "Avernic defender"),
        DROP_DWH("is the rarest unique drop from Lizardman Shamans", "Dragon warhammer"),
        CRAFT_ONYX("Crafting level is required to be able to cut Onyx", "67"),
        BOB_MERCHANT("is Bob the axe merchant located", "Lumbridge"),
        GRAIN_OF_PLENTY("Grain of Plenty located on in the Stronghold of Security", "Second"),
        BARROWS_REPAIR("NPC that will repair your Barrows armor for fee", "Bob"),
        GRAVEYARD_TELE("spellbook do you need to be on to teleport to the Salve Graveyard", "Arceuus"),
        GRAATOR_RACE("race of monster is General Graardor", "Ourg"),
        REV_CAVES("Rev caves, this wilderness dungeons actual", "Forinthry"),
        SARA_BREW("level is required to be able to make a Saradomin brew", "81"),
        GOD_BANDOS("Bandos is the god of .", "War"),
        XARPUS_BOSS("second to last boss in the Theatre of Blood", "Xarpus"),
        DURADER_SLAYER("slayer level is required to use Duradel", "50"),
        BLACK_CHIN("required to catch a black chinchompa", "73"),
        VESTA_ITEM("ancient warriors whose armour you can get from Wilderness drops", "Vesta"),
        WOODCUTTING_PET("kind of animal is the Woodcutting pet", "Beaver"),
        NEWSPAPERS_VARROCK("NPC that sells newspapers in Varrock", "Benny"),
        THIEVING_PET("name of the Thieving pet", "Rocky"),
        HARD_CLUE_VOTE("does a hard clue bottle cost in the", "9"),
        MAX_CAPE_MAC("in order to buy a skill cape in Zenyte", "Mac"),
        DRAGON_FH("monster drops the Dragon full helm", "Mithril dragon"),
        ZAHUR("NPC that can crush your herblore secondaries", "Zahur"),
        SUPERIOR_MINING_GLOVES("mining level is required to wear Superior mining gloves", "55"),
        SPECTRAL_SHIELD("shield reduces the effectiveness of all Prayer draining", "Spectral spirit shield"),
        CANOE_TRANSPORTATION("method of transport can take you all the way along the River Lum", "Canoe"),
        DEFENDERS_ZENYTE("many different types of defenders are there in Zenyte", "9"),
        QP_NEEDED_BGLOVES("quest points do you need to be able to defeat the Culiniromancer", "175"),
        RING_WDISCOUNT("name of the ring that can charm certain", "Charos"),
        HIGHEST_CLUES("name of the highest tier of clue scroll", "Master"),
        TREE_LIKE_YAK("tree smells of yak", "Arctic pine"),
        WOAD_SEED("farming level is required to plant a woad seed", "25"),
        GOD_ARMADYL("Armadyl is the god of ...", "Justice"),
        VARROCK_TOBY("Taskmaster for the Varrock", "Toby"),
        T10_EMBLEM_POINTS("for selling a T10", "5,000,000"),
        SARA_BREW_HERB("herb do you need to make a Saradomin brew", "Toadflax"),
        LOWEST_RATE_ON_ZENYTE("is the lowest XP rate you can have on Zenyte", "5x"),
        HYDRA_COMBAT("combat level is the Alchemical Hydra", "426"),
        HEAVIEST_ITEM("heaviest item you can carry in the Weapon slot", "Barrelchest anchor"),
        BARRELCHEST_ANCHOR_COST("a Barrelchest Anchor cost in the slayer reward shop", "200"),
        TYPES_OF_WANDS("types of wands are there", "6"),
        OVERLOAD_DAMAGE("name of the potion that boosts your stats but damages you", "Overload");

        private final String question;
        private final String answer;

        TriviaQuestion(String question, String answer) {
            this.question = question;
            this.answer = answer;
        }

        public String getQuestion() {
            return question;
        }
        public String getAnswer() {
            return answer;
        }
    }

}

'''
'''--- src/eAIOItemClicker/eMain.java ---
package eAIOItemClicker;

import BotUtils.eActions;
import BotUtils.eBanking;
import BotUtils.eData;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ItemID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimplePlayer;
import simple.hooks.wrappers.SimpleWidget;

import java.awt.*;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;

import static eApiAccess.eAutoResponser.botStarted;
import static eApiAccess.eAutoResponser.gptDeactivation;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.OTHER,
        description = "<html>"
                + "<p>The most effective item clicker on Zenyte!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li></li>"
                + "<li></li>"
                + "<li>Chat GPT answering is integrated.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eAIOItemClicker",
        servers = {"Zenyte"},
        version = "0.1"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final String eBotName = "eAIOItemClicker";
    private static final String ePaintText = "Products made: ";
    private static SimpleSkills.Skills CHOSEN_SKILL = null;
    private static final Logger logger = Logger.getLogger(eAnglerFisherBot.eMain.class.getName());
    private static final String[] TOOLS_NAME = {"Knife", "Chisel"};

    // Variables
    private int count;
    private long lastAnimation = -1;
    private static eAutoResponderGui guiGpt;
    public static boolean hidePaint = false;
    private long startTime = 0L;
    private long startingSkillExp;
    private long startingSkillLevel;

    // Gui GPT
    private void initializeGptGui() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        eBanking bankingUtils = new eBanking(ctx);
        eActions actionUtils = new eActions(ctx);
        eData dataUtils = new eData(ctx);
        eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx)));
        initializeMethods(); // BotUtils
        initializeGptGui(); // GPT
        eAutoResponser.scriptPurpose = "you're amethyst darts. ";
        gptDeactivation();
        checkInvForTool();

        // Other vars
        ctx.log("--------------- " + eActions.getCurrentTimeFormatted() + " ---------------");
        ctx.log("-------------------------------------");
        ctx.log("            " + eBotName + "         ");
        ctx.log("-------------------------------------");

        // Vars
        eActions.updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        count = 0;
        ctx.viewport.angle(180);
        ctx.viewport.pitch(true);
        lastAnimation = System.currentTimeMillis();
    }

    @Override
    public void onProcess() {
        super.onProcess();

        final SimplePlayer localPlayer = ctx.players.getLocal();

        if (!botStarted) {
            eActions.status = "Please start the bot!";
            return;
        }

        eActions.handleRunning();

        if (!eActions.hasItemsInInventory(eActions.StackableType.NON_STACKABLE, ItemID.CHISEL)) eBanking.bankTask(false, -1, -1, true, ItemID.CHISEL, 1, -1);

        if (eActions.hasItemsInInventory(eActions.StackableType.NON_STACKABLE, ItemID.AMETHYST)) {
            if (localPlayer.getAnimation() == -1 && (eActions.getCurrentTimeMilli() > (lastAnimation + eActions.getRandomInt(3000, 4000)))) {
                useItemOnItem();
            } else if (localPlayer.getAnimation() != -1) {
                lastAnimation = eActions.getCurrentTimeMilli();
            }
        } else {
            eBanking.bankTask(false, -1, 1, true, ItemID.AMETHYST, 27, ItemID.CHISEL);
        }
    }

    // Making cannonballs
    private void useItemOnItem() {
        SimpleItem itemInv = ctx.inventory.populate().filter(ItemID.AMETHYST).reverse().next();
        SimpleItem toolInv = ctx.inventory.populate().filter(TOOLS_NAME).next();

        if (eBanking.bankIsOpen()) ctx.bank.closeBank();

        if (itemInv == null || toolInv == null) {
            return;
        }

        BotUtils.eActions.updateStatus("Using " + itemInv.getName().toLowerCase() + " on " + toolInv.getName().toLowerCase());
        toolInv.click("Use");
        ctx.sleep(50, 100);
        itemInv.click(0);
        ctx.onCondition(this::widgetVisible, 250, 12);

        if (widgetVisible()) {
            int itemsCached = eActions.getItemCountInventory(ItemID.AMETHYST);
            eActions.clickWidget(270, 17); // 270, 17 for darts, 14 for bolts
            ctx.onCondition(() -> itemsCached > eActions.getItemCountInventory(ItemID.AMETHYST), 50, 20);
            BotUtils.eActions.updateStatus("Cutting " + itemInv.getName().toLowerCase());
        }
    }

    private void checkInvForTool() {
        SimpleItem toolInv = ctx.inventory.populate().filter(TOOLS_NAME).next();
        if (CHOSEN_SKILL != null) {
            return;
        }

        if (toolInv.getName().equals("Knife")) {
            CHOSEN_SKILL = SimpleSkills.Skills.FLETCHING;
        } else if (toolInv.getName().equals("Chisel")) {
            CHOSEN_SKILL = SimpleSkills.Skills.CRAFTING;
        } else {
            CHOSEN_SKILL = SimpleSkills.Skills.OVERALL;
            eActions.updateStatus("Please start with knife / chisel");
            eActions.updateStatus("No tool in inventory");
            ctx.stopScript();
        }
    }

    private boolean widgetVisible() {
        SimpleWidget widgetToClick = ctx.widgets.getWidget(270, 17); // 270, 17 for darts, 14 for bolts

        if (widgetToClick == null) {
            return false;
        }
        ctx.keyboard.pressKey(KeyEvent.VK_4);
        return true;
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log(ePaintText + count);
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        if (getType == ChatMessageType.SPAM) {
            String gameMessageTrimmed = gameMessage.replaceAll("<[^>]+>", "").trim();
            if (gameMessageTrimmed.contains("cut the")) {
                count += 8;
            }
        }

        eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        eTriviaInfo.handleBroadcastMessage(getType, gameMessage);
    }

    @Override
    public int loopDuration() {
        return 600;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePaintText + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + eActions.status, 15, 225);

        }
    }
}

'''
'''--- src/eAgilityBotZenyte/Areas/eDataAlKharid.java ---
package eAgilityBotZenyte.Areas;

import eAgilityBotZenyte.eObstaclesListing;
import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

import java.util.Arrays;
import java.util.List;

public class eDataAlKharid {
    // Areas
    public static final WorldArea startArea = new WorldArea(new WorldPoint[]{
            new WorldPoint(3268, 3213, 0),
            new WorldPoint(3257, 3167, 0),
            new WorldPoint(3284, 3135, 0),
            new WorldPoint(3331, 3137, 0),
            new WorldPoint(3334, 3193, 0),
            new WorldPoint(3318, 3213, 0)
    });
    private static final WorldArea firstHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3270, 3194, 3),
            new WorldPoint(3270, 3189, 3),
            new WorldPoint(3272, 3189, 3),
            new WorldPoint(3272, 3183, 3),
            new WorldPoint(3271, 3183, 3),
            new WorldPoint(3271, 3179, 3),
            new WorldPoint(3276, 3179, 3),
            new WorldPoint(3276, 3184, 3),
            new WorldPoint(3279, 3184, 3),
            new WorldPoint(3279, 3189, 3),
            new WorldPoint(3277, 3189, 3),
            new WorldPoint(3277, 3194, 3)
    });

    private static final WorldArea secondHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3274, 3175, 3),
            new WorldPoint(3274, 3160, 3),
            new WorldPoint(3264, 3160, 3),
            new WorldPoint(3264, 3175, 3)
    });

    private static final WorldArea thirdHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3282, 3177, 3),
            new WorldPoint(3282, 3159, 3),
            new WorldPoint(3304, 3159, 3),
            new WorldPoint(3304, 3170, 3),
            new WorldPoint(3294, 3170, 3),
            new WorldPoint(3294, 3168, 3),
            new WorldPoint(3288, 3168, 3),
            new WorldPoint(3288, 3177, 3)
    });

    private static final WorldArea thirdHouseSmall = new WorldArea (new WorldPoint[] {
            new WorldPoint(3304, 3159, 3),
            new WorldPoint(3294, 3159, 3),
            new WorldPoint(3294, 3169, 3),
            new WorldPoint(3304, 3169, 3)
    });
    private static final WorldArea fourthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3312, 3167, 1),
            new WorldPoint(3312, 3159, 1),
            new WorldPoint(3320, 3159, 1),
            new WorldPoint(3320, 3167, 1)
    });

    private static final WorldArea fifthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3319, 3180, 2),
            new WorldPoint(3311, 3180, 2),
            new WorldPoint(3313, 3173, 2),
            new WorldPoint(3319, 3173, 2)
    });

    private static final WorldArea sixthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3319, 3188, 3),
            new WorldPoint(3311, 3188, 3),
            new WorldPoint(3311, 3179, 3),
            new WorldPoint(3319, 3179, 3)
    });

    private static final WorldArea seventhHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3307, 3189, 3),
            new WorldPoint(3302, 3184, 3),
            new WorldPoint(3295, 3191, 3),
            new WorldPoint(3300, 3196, 3)
    });

    // Cordinates
    public static WorldPoint startPoint = new WorldPoint(3273, 3195, 0);
    public static WorldPoint firstPoint = new WorldPoint(3272, 3182, 3);
    public static WorldPoint secondPoint = new WorldPoint(3268, 3166, 3);
    public static WorldPoint thirdPoint = new WorldPoint(3301, 3163, 3);
    public static WorldPoint fourthPoint = new WorldPoint(3318, 3165, 1);
    public static WorldPoint fifthPoint = new WorldPoint(3316, 3179, 2);
    public static WorldPoint sixthPoint = new WorldPoint(3314, 3186, 3);
    public static WorldPoint seventhPoint = new WorldPoint(3300, 3192, 3);

    // Obstacles
    public static List<eObstaclesListing> obstaclesALKharid = Arrays.asList(
            new eObstaclesListing(startArea, startPoint, "Climb", "Rough wall"),
            new eObstaclesListing(firstHouse, firstPoint, "Cross", "Tightrope"),
            new eObstaclesListing(secondHouse, secondPoint, "Swing-across", "Cable"),
            new eObstaclesListing(thirdHouse, thirdPoint, "Teeth-grip", "Zip line"),
            new eObstaclesListing(fourthHouse, fourthPoint, "Swing-across", "Tropical tree"),
            new eObstaclesListing(fifthHouse, fifthPoint, "Climb", "Roof top beams"),
            new eObstaclesListing(sixthHouse, sixthPoint, "Cross", "Tightrope"),
            new eObstaclesListing(seventhHouse, seventhPoint, "Jump", "Gap")
    );
}

'''
'''--- src/eAgilityBotZenyte/Areas/eDataAlRellekka.java ---
package eAgilityBotZenyte.Areas;

import eAgilityBotZenyte.eObstaclesListing;
import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

import java.util.Arrays;
import java.util.List;

public class eDataAlRellekka {
    // Areas
    public static final WorldArea startArea = new WorldArea(new WorldPoint[]{
            new WorldPoint(2692, 3740, 0),
            new WorldPoint(2691, 3712, 0),
            new WorldPoint(2693, 3703, 0),
            new WorldPoint(2689, 3697, 0),
            new WorldPoint(2693, 3689, 0),
            new WorldPoint(2689, 3675, 0),
            new WorldPoint(2691, 3668, 0),
            new WorldPoint(2689, 3661, 0),
            new WorldPoint(2693, 3654, 0),
            new WorldPoint(2693, 3649, 0),
            new WorldPoint(2682, 3644, 0),
            new WorldPoint(2632, 3645, 0),
            new WorldPoint(2618, 3652, 0),
            new WorldPoint(2605, 3655, 0),
            new WorldPoint(2593, 3666, 0),
            new WorldPoint(2636, 3742, 0)
    });
    private static final WorldArea firstHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(2621, 3677, 3),
            new WorldPoint(2621, 3671, 3),
            new WorldPoint(2628, 3671, 3),
            new WorldPoint(2627, 3677, 3)
    });

    private static final WorldArea secondHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(2614, 3669, 3),
            new WorldPoint(2614, 3657, 3),
            new WorldPoint(2623, 3657, 3),
            new WorldPoint(2623, 3669, 3)
    });

    private static final WorldArea thirdHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(2625, 3656, 3),
            new WorldPoint(2625, 3651, 3),
            new WorldPoint(2631, 3651, 3),
            new WorldPoint(2631, 3656, 3)
    });

    private static final WorldArea fourthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(2642, 3654, 3),
            new WorldPoint(2645, 3654, 3),
            new WorldPoint(2645, 3648, 3),
            new WorldPoint(2638, 3649, 3),
            new WorldPoint(2634, 3661, 3),
            new WorldPoint(2641, 3660, 3)
    });

    private static final WorldArea fifthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(2651, 3664, 3),
            new WorldPoint(2651, 3656, 3),
            new WorldPoint(2641, 3656, 3),
            new WorldPoint(2641, 3664, 3)
    });

    private static final WorldArea sixthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(2662, 3682, 3),
            new WorldPoint(2654, 3682, 3),
            new WorldPoint(2654, 3664, 3),
            new WorldPoint(2663, 3664, 3),
            new WorldPoint(2663, 3680, 3),
            new WorldPoint(2667, 3682, 3),
            new WorldPoint(2667, 3687, 3),
            new WorldPoint(2662, 3687, 3)
    });

    // Cordinates
    public static WorldPoint startPoint = new WorldPoint(2625, 3677, 0);
    public static WorldPoint firstPoint = new WorldPoint(2622, 3672, 3);
    public static WorldPoint secondPoint = new WorldPoint(2622, 3658, 3);
    public static WorldPoint thirdPoint = new WorldPoint(2630, 3655, 3);
    public static WorldPoint fourthPoint = new WorldPoint(2643, 3653, 3);
    public static WorldPoint fifthPoint = new WorldPoint(2647, 3662, 3);
    public static WorldPoint sixthPoint = new WorldPoint(2655, 3676, 3);

    // Obstacles
    public static List<eObstaclesListing> obstaclesRellekka = Arrays.asList(
            new eObstaclesListing(startArea, startPoint, "Climb", "Rough wall"),
            new eObstaclesListing(firstHouse, firstPoint, "Leap", "Gap"),
            new eObstaclesListing(secondHouse, secondPoint, "Cross", "Tightrope"),
            new eObstaclesListing(thirdHouse, thirdPoint, "Leap", "Gap"),
            new eObstaclesListing(fourthHouse, fourthPoint, "Hurdle", "Gap"),
            new eObstaclesListing(fifthHouse, fifthPoint, "Cross", "Tightrope"),
            new eObstaclesListing(sixthHouse, sixthPoint, "Jump-in", "Pile of fish")
    );
}

'''
'''--- src/eAgilityBotZenyte/Areas/eDataArdougne.java ---
package eAgilityBotZenyte.Areas;

import eAgilityBotZenyte.eObstaclesListing;
import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

import java.util.Arrays;
import java.util.List;

public class eDataArdougne {
    // Areas
    public static final WorldArea startArea = new WorldArea(new WorldPoint[]{
            new WorldPoint(2600, 3343, 0),
            new WorldPoint(2690, 3342, 0),
            new WorldPoint(2689, 3264, 0),
            new WorldPoint(2587, 3259, 0)
    });
    public static final WorldArea firstHouse = new WorldArea(new WorldPoint[]{
            new WorldPoint(2669, 3311, 3),
            new WorldPoint(2669, 3298, 3),
            new WorldPoint(2674, 3298, 3),
            new WorldPoint(2674, 3311, 3)
    });
    public static final WorldArea secondHouse = new WorldArea(new WorldPoint[]{
            new WorldPoint(2666, 3317, 3),
            new WorldPoint(2660, 3317, 3),
            new WorldPoint(2660, 3320, 3),
            new WorldPoint(2666, 3320, 3)
    });
    public static final WorldArea thirdHouse = new WorldArea(new WorldPoint[]{
            new WorldPoint(2658, 3320, 3),
            new WorldPoint(2658, 3317, 3),
            new WorldPoint(2653, 3317, 3),
            new WorldPoint(2653, 3320, 3)
    });
    public static final WorldArea fourthHouse = new WorldArea(new WorldPoint[]{
            new WorldPoint(2651, 3315, 3),
            new WorldPoint(2651, 3310, 3),
            new WorldPoint(2655, 3310, 3),
            new WorldPoint(2655, 3315, 3)
    });
    public static final WorldArea fifthHouse = new WorldArea(new WorldPoint[]{
            new WorldPoint(2649, 3310, 3),
            new WorldPoint(2652, 3310, 3),
            new WorldPoint(2652, 3306, 3),
            new WorldPoint(2654, 3305, 3),
            new WorldPoint(2655, 3303, 3),
            new WorldPoint(2657, 3302, 3),
            new WorldPoint(2652, 3299, 3)
    });
    public static final WorldArea sixthHouse = new WorldArea(new WorldPoint[]{
            new WorldPoint(2659, 3295, 3),
            new WorldPoint(2659, 3300, 3),
            new WorldPoint(2656, 3300, 3),
            new WorldPoint(2654, 3299, 3),
            new WorldPoint(2655, 3295, 3)
    });

    // Cordinates
    public static WorldPoint startPoint = new WorldPoint(2673, 3297, 0);
    public static WorldPoint firstPoint = new WorldPoint(2671, 3309, 3);
    public static WorldPoint secondPoint = new WorldPoint(2662, 3318, 3);
    public static WorldPoint thirdPoint = new WorldPoint(2654, 3318, 3);
    public static WorldPoint fourthPoint = new WorldPoint(2653, 3310, 3);
    public static WorldPoint fifthPoint = new WorldPoint(2653, 3300, 3);
    public static WorldPoint sixthPoint = new WorldPoint(2656, 3297, 3);

    // Obstacles
    public static List<eObstaclesListing> obstaclesArdougne = Arrays.asList(
            new eObstaclesListing(startArea, startPoint, "Climb-up", "Wooden Beams"),
            new eObstaclesListing(firstHouse, firstPoint, "Jump", "Gap"),
            new eObstaclesListing(secondHouse, secondPoint, "Walk-on", "Plank"),
            new eObstaclesListing(thirdHouse, thirdPoint, "Jump", "Gap"),
            new eObstaclesListing(fourthHouse, fourthPoint, "Jump", "Gap"),
            new eObstaclesListing(fifthHouse, fifthPoint, "Balance-across", "Steep roof"),
            new eObstaclesListing(sixthHouse, sixthPoint, "Jump", "Gap")
    );
}

'''
'''--- src/eAgilityBotZenyte/Areas/eDataCanifis.java ---
package eAgilityBotZenyte.Areas;

import eAgilityBotZenyte.eObstaclesListing;
import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

import java.util.Arrays;
import java.util.List;

public class eDataCanifis {
    // Areas
    public static final WorldArea startArea = new WorldArea(new WorldPoint[]{
            new WorldPoint(3457, 3515, 0),
            new WorldPoint(3459, 3464, 0),
            new WorldPoint(3528, 3465, 0),
            new WorldPoint(3524, 3518, 0)
    });
    private static final WorldArea firstHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3504, 3490, 2),
            new WorldPoint(3504, 3494, 2),
            new WorldPoint(3503, 3499, 2),
            new WorldPoint(3509, 3499, 2),
            new WorldPoint(3512, 3496, 2),
            new WorldPoint(3512, 3494, 2),
            new WorldPoint(3509, 3493, 2),
            new WorldPoint(3509, 3490, 2)
    });

    private static final WorldArea secondHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3505, 3503, 2),
            new WorldPoint(3505, 3507, 2),
            new WorldPoint(3503, 3508, 2),
            new WorldPoint(3496, 3508, 2),
            new WorldPoint(3495, 3506, 2),
            new WorldPoint(3495, 3503, 2)
    });

    private static final WorldArea thirdHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3493, 3506, 2),
            new WorldPoint(3488, 3506, 2),
            new WorldPoint(3488, 3503, 2),
            new WorldPoint(3485, 3503, 2),
            new WorldPoint(3484, 3501, 2),
            new WorldPoint(3484, 3497, 2),
            new WorldPoint(3493, 3498, 2),
            new WorldPoint(3494, 3500, 2),
            new WorldPoint(3494, 3506, 2)
    });

    private static final WorldArea fourthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3481, 3501, 3),
            new WorldPoint(3481, 3490, 3),
            new WorldPoint(3473, 3491, 3),
            new WorldPoint(3473, 3500, 3),
            new WorldPoint(3475, 3500, 3),
            new WorldPoint(3476, 3501, 3)
    });

    private static final WorldArea fifthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3476, 3488, 2),
            new WorldPoint(3485, 3488, 2),
            new WorldPoint(3485, 3484, 2),
            new WorldPoint(3482, 3484, 2),
            new WorldPoint(3482, 3480, 2),
            new WorldPoint(3476, 3481, 2)
    });

    private static final WorldArea sixthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3490, 3480, 3),
            new WorldPoint(3489, 3478, 3),
            new WorldPoint(3487, 3478, 3),
            new WorldPoint(3487, 3467, 3),
            new WorldPoint(3500, 3468, 3),
            new WorldPoint(3503, 3471, 3),
            new WorldPoint(3505, 3471, 3),
            new WorldPoint(3505, 3478, 3),
            new WorldPoint(3498, 3478, 3),
            new WorldPoint(3498, 3480, 3)
    });

    private static final WorldArea seventhHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3508, 3484, 2),
            new WorldPoint(3517, 3484, 2),
            new WorldPoint(3517, 3477, 2),
            new WorldPoint(3513, 3475, 2),
            new WorldPoint(3513, 3473, 2),
            new WorldPoint(3509, 3474, 2),
            new WorldPoint(3508, 3478, 2),
            new WorldPoint(3507, 3479, 2),
            new WorldPoint(3507, 3482, 2)
    });

    // Cordinates
    public static WorldPoint startPoint = new WorldPoint(3507, 3488, 0);
    public static WorldPoint firstPoint = new WorldPoint(3505, 3496, 2);
    public static WorldPoint secondPoint = new WorldPoint(3498, 3504, 2);
    public static WorldPoint thirdPoint = new WorldPoint(3487, 3499, 2);
    public static WorldPoint fourthPoint = new WorldPoint(3478, 3493, 3);
    public static WorldPoint fifthPoint = new WorldPoint(3479, 3484, 2);
    public static WorldPoint sixthPoint = new WorldPoint(3503, 3475, 3);
    public static WorldPoint seventhPoint = new WorldPoint(3510, 3482, 2);

    // Obstacles
    public static List<eObstaclesListing> obstaclesCanifis = Arrays.asList(
            new eObstaclesListing(startArea, startPoint, "Climb", "Tall tree"),
            new eObstaclesListing(firstHouse, firstPoint, "Jump", "Gap"),
            new eObstaclesListing(secondHouse, secondPoint, "Jump", "Gap"),
            new eObstaclesListing(thirdHouse, thirdPoint, "Jump", "Gap"),
            new eObstaclesListing(fourthHouse, fourthPoint, "Jump", "Gap"),
            new eObstaclesListing(fifthHouse, fifthPoint, "Vault", "Pole-vault"),
            new eObstaclesListing(sixthHouse, sixthPoint, "Jump", "Gap"),
            new eObstaclesListing(seventhHouse, seventhPoint, "Jump", "Gap")
    );
}

'''
'''--- src/eAgilityBotZenyte/Areas/eDataPollnivneach.java ---
package eAgilityBotZenyte.Areas;

import eAgilityBotZenyte.eObstaclesListing;
import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

import java.util.Arrays;
import java.util.List;

public class eDataPollnivneach {
    // Areas
    public static final WorldArea startArea = new WorldArea(new WorldPoint[]{
            new WorldPoint(3323, 3021, 0),
            new WorldPoint(3357, 3021, 0),
            new WorldPoint(3382, 2988, 0),
            new WorldPoint(3381, 2962, 0),
            new WorldPoint(3345, 2925, 0),
            new WorldPoint(3302, 2917, 0)
    });
    private static final WorldArea firstHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3345, 2969, 1),
            new WorldPoint(3345, 2963, 1),
            new WorldPoint(3349, 2962, 1),
            new WorldPoint(3353, 2963, 1),
            new WorldPoint(3352, 2970, 1),
            new WorldPoint(3345, 2970, 1)
    });

    private static final WorldArea secondHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3356, 2977, 1),
            new WorldPoint(3356, 2972, 1),
            new WorldPoint(3351, 2972, 1),
            new WorldPoint(3351, 2977, 1),
            new WorldPoint(3356, 2977, 1)
    });

    private static final WorldArea thirdHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3359, 2980, 1),
            new WorldPoint(3363, 2980, 1),
            new WorldPoint(3363, 2976, 1),
            new WorldPoint(3359, 2976, 1)
    });

    private static final WorldArea fourthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3365, 2977, 1),
            new WorldPoint(3365, 2973, 1),
            new WorldPoint(3371, 2973, 1),
            new WorldPoint(3371, 2977, 1)
    });

    private static final WorldArea fifthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3364, 2984, 1),
            new WorldPoint(3364, 2987, 1),
            new WorldPoint(3371, 2987, 1),
            new WorldPoint(3371, 2984, 1),
            new WorldPoint(3370, 2981, 1),
            new WorldPoint(3365, 2981, 1),
            new WorldPoint(3365, 2983, 1),
            new WorldPoint(3366, 2983, 1),
            new WorldPoint(3366, 2984, 1)
    });

    private static final WorldArea sixthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3366, 2987, 2),
            new WorldPoint(3354, 2987, 2),
            new WorldPoint(3354, 2979, 2),
            new WorldPoint(3366, 2979, 2)
    });

    private static final WorldArea seventhHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3355, 2996, 2),
            new WorldPoint(3356, 2990, 2),
            new WorldPoint(3371, 2989, 2),
            new WorldPoint(3371, 2996, 2)
    });

    private static final WorldArea eightHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3355, 3006, 2),
            new WorldPoint(3355, 2999, 2),
            new WorldPoint(3363, 2999, 2),
            new WorldPoint(3363, 3006, 2)
    });

    // Cordinates
    public static WorldPoint startPoint = new WorldPoint(3352, 2962, 0);
    public static WorldPoint firstPoint = new WorldPoint(3350, 2968, 1);
    public static WorldPoint secondPoint = new WorldPoint(3355, 2976, 1);
    public static WorldPoint thirdPoint = new WorldPoint(3362, 2977, 1);
    public static WorldPoint fourthPoint = new WorldPoint(3368, 2976, 1);
    public static WorldPoint fifthPoint = new WorldPoint(3365, 2982, 1);
    public static WorldPoint sixthPoint = new WorldPoint(3358, 2984, 2);
    public static WorldPoint seventhPoint = new WorldPoint(3360, 2995, 2);
    public static WorldPoint eightPoint = new WorldPoint(3362, 3002, 2);

    // Obstacles
    public static List<eObstaclesListing> obstaclesPollnivneach = Arrays.asList(
            new eObstaclesListing(startArea, startPoint, "Climb-on", "Basket"),
            new eObstaclesListing(firstHouse, firstPoint, "Jump-on", "Market stall"),
            new eObstaclesListing(secondHouse, secondPoint, "Grab", "Banner"),
            new eObstaclesListing(thirdHouse, thirdPoint, "Leap", "Gap"),
            new eObstaclesListing(fourthHouse, fourthPoint, "Jump-to", "Tree"),
            new eObstaclesListing(fifthHouse, fifthPoint, "Climb", "Rough wall"),
            new eObstaclesListing(sixthHouse, sixthPoint, "Cross", "Monkeybars"),
            new eObstaclesListing(seventhHouse, seventhPoint, "Jump-on", "Tree"),
            new eObstaclesListing(eightHouse, eightPoint, "Jump-to", "Drying line")
    );
}

'''
'''--- src/eAgilityBotZenyte/Areas/eDataSeers.java ---
package eAgilityBotZenyte.Areas;

import eAgilityBotZenyte.eObstaclesListing;
import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

import java.util.Arrays;
import java.util.List;

public class eDataSeers {
    // Areas
    public static final WorldArea startArea = new WorldArea (new WorldPoint[] {
            new WorldPoint(2683, 3514, 0),
            new WorldPoint(2743, 3513, 0),
            new WorldPoint(2744, 3482, 0),
            new WorldPoint(2774, 3482, 0),
            new WorldPoint(2774, 3451, 0),
            new WorldPoint(2681, 3452, 0)
    });
    private static final WorldArea firstHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(2731, 3498, 3),
            new WorldPoint(2731, 3489, 3),
            new WorldPoint(2720, 3489, 3),
            new WorldPoint(2720, 3498, 3)
    });

    private static final WorldArea secondHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(2702, 3499, 2),
            new WorldPoint(2702, 3486, 2),
            new WorldPoint(2714, 3486, 2),
            new WorldPoint(2716, 3500, 2)
    });

    private static final WorldArea thirdHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(2708, 3483, 2),
            new WorldPoint(2708, 3475, 2),
            new WorldPoint(2717, 3475, 2),
            new WorldPoint(2717, 3483, 2)
    });

    private static final WorldArea fourthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(2697, 3478, 3),
            new WorldPoint(2697, 3468, 3),
            new WorldPoint(2718, 3468, 3),
            new WorldPoint(2718, 3474, 3),
            new WorldPoint(2706, 3474, 3),
            new WorldPoint(2706, 3478, 3)
    });

    private static final WorldArea fifthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(2689, 3467, 2),
            new WorldPoint(2689, 3457, 2),
            new WorldPoint(2704, 3457, 2),
            new WorldPoint(2704, 3467, 2)
    });

    // Cordinates
    public static WorldPoint startPoint = new WorldPoint(2729, 3489, 0);
    public static WorldPoint firstPoint = new WorldPoint(2721, 3493, 3);
    public static WorldPoint secondPoint = new WorldPoint(2710, 3490, 2);
    public static WorldPoint thirdPoint = new WorldPoint(2710, 3477, 2);
    public static WorldPoint fourthPoint = new WorldPoint(2702, 3470, 3);
    public static WorldPoint fifthPoint = new WorldPoint(2702, 3464, 2);

    // Obstacles
    public static List<eObstaclesListing> obstaclesSeers = Arrays.asList(
            new eObstaclesListing(startArea, startPoint, "Climb-up", "Wall"),
            new eObstaclesListing(firstHouse, firstPoint, "Jump", "Gap"),
            new eObstaclesListing(secondHouse, secondPoint, "Cross", "Tightrope"),
            new eObstaclesListing(thirdHouse, thirdPoint, "Jump", "Gap"),
            new eObstaclesListing(fourthHouse, fourthPoint,  "Jump", "Gap"),
            new eObstaclesListing(fifthHouse, fifthPoint, "Jump", "Edge")
    );
}

'''
'''--- src/eAgilityBotZenyte/Areas/eDataVarrock.java ---
package eAgilityBotZenyte.Areas;

import eAgilityBotZenyte.eObstaclesListing;
import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

import java.util.Arrays;
import java.util.List;

public class eDataVarrock {
    // Areas
    public static final WorldArea startArea = new WorldArea(new WorldPoint[]{
            new WorldPoint(3174, 3447, 0),
            new WorldPoint(3175, 3380, 0),
            new WorldPoint(3284, 3378, 0),
            new WorldPoint(3285, 3448, 0)
    });
    private static final WorldArea firstHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3221, 3409, 3),
            new WorldPoint(3213, 3409, 3),
            new WorldPoint(3213, 3421, 3),
            new WorldPoint(3221, 3421, 3)
    });

    private static final WorldArea secondHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3209, 3413, 3),
            new WorldPoint(3209, 3416, 3),
            new WorldPoint(3210, 3418, 3),
            new WorldPoint(3208, 3421, 3),
            new WorldPoint(3202, 3421, 3),
            new WorldPoint(3199, 3416, 3),
            new WorldPoint(3203, 3412, 3)
    });

    private static final WorldArea thirdHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3199, 3418, 1),
            new WorldPoint(3199, 3415, 1),
            new WorldPoint(3191, 3415, 1),
            new WorldPoint(3191, 3418, 1)
    });

    private static final WorldArea fourthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3199, 3407, 3),
            new WorldPoint(3190, 3407, 3),
            new WorldPoint(3190, 3401, 3),
            new WorldPoint(3199, 3401, 3)
    });

    private static final WorldArea fifthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3190, 3387, 3),
            new WorldPoint(3190, 3381, 3),
            new WorldPoint(3181, 3381, 3),
            new WorldPoint(3181, 3400, 3),
            new WorldPoint(3201, 3400, 3),
            new WorldPoint(3201, 3405, 3),
            new WorldPoint(3210, 3405, 3),
            new WorldPoint(3210, 3395, 3),
            new WorldPoint(3196, 3387, 3)
    });

    private static final WorldArea sixthHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3217, 3404, 3),
            new WorldPoint(3217, 3392, 3),
            new WorldPoint(3234, 3392, 3),
            new WorldPoint(3234, 3404, 3),
            new WorldPoint(3220, 3406, 3)
    });

    private static final WorldArea seventhHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3241, 3410, 3),
            new WorldPoint(3235, 3410, 3),
            new WorldPoint(3235, 3402, 3),
            new WorldPoint(3241, 3402, 3)
    });

    private static final WorldArea eightHouse = new WorldArea (new WorldPoint[] {
            new WorldPoint(3241, 3410, 3),
            new WorldPoint(3235, 3410, 3),
            new WorldPoint(3235, 3418, 3),
            new WorldPoint(3241, 3418, 3)
    });

    // Cordinates
    public static WorldPoint startPoint = new WorldPoint(3221, 3414, 0);
    public static WorldPoint firstPoint = new WorldPoint(3214, 3414, 3);
    public static WorldPoint secondPoint = new WorldPoint(3201, 3417, 3);
    public static WorldPoint thirdPoint = new WorldPoint(3194, 3416, 1);
    public static WorldPoint fourthPoint = new WorldPoint(3193, 3402, 3);
    public static WorldPoint fifthPoint = new WorldPoint(3208, 3398, 3);
    public static WorldPoint sixthPoint = new WorldPoint(3232, 3402, 3);
    public static WorldPoint seventhPoint = new WorldPoint(3238, 3408, 3);
    public static WorldPoint eightPoint = new WorldPoint(3237, 3415, 3);

    // Obstacles
    public static List<eObstaclesListing> obstaclesVarrock = Arrays.asList(
            new eObstaclesListing(startArea, startPoint, "Climb", "Rough wall"),
            new eObstaclesListing(firstHouse, firstPoint, "Cross", "Clothes line"),
            new eObstaclesListing(secondHouse, secondPoint, "Leap", "Gap"),
            new eObstaclesListing(thirdHouse, thirdPoint, "Balance", "Wall"),
            new eObstaclesListing(fourthHouse, fourthPoint, "Leap", "Gap"),
            new eObstaclesListing(fifthHouse, fifthPoint, "Leap", "Gap"),
            new eObstaclesListing(sixthHouse, sixthPoint, "Leap", "Gap"),
            new eObstaclesListing(seventhHouse, seventhPoint, "Hurdle", "Ledge"),
            new eObstaclesListing(eightHouse, eightPoint, "Jump-off", "Edge")
    );
}

'''
'''--- src/eAgilityBotZenyte/eMain.java ---
package eAgilityBotZenyte;

import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import eAgilityBotZenyte.Areas.*;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Game;
import simple.hooks.simplebot.Pathing;
import simple.hooks.wrappers.SimpleGroundItem;
import simple.hooks.wrappers.SimpleObject;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.List;
import java.util.logging.Logger;

import static eApiAccess.eAutoResponser.*;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.AGILITY,
        description = "<html>"
                + "<p>The most effective agility bot on Zenyte!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>Always start the bot <b>at the beginning of agility course!</b>.</li>"
                + "<li>The bot will recognize location and start running to first obstacle.</b>.</li>"
                + "<li>You can reset the bot to new course location by typing <b>\"---\"</b> in chat.</li>"
                + "<li>Bot will pick up marks of grace.</li>"
                + "<li>Chat GPT answering is integrated.</li>"
                + "<li><b>Supported courses:</b> Al-Kharid, Varrock, Canafis, Seers, Pollniveach, Rellekka, Ardougne.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eAgilityBotZenyte",
        servers = {"Zenyte"},
        version = "1"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.AGILITY;
    public static eAutoResponderGui guiGpt;
    private static final Logger logger = Logger.getLogger(eMain.class.getName());
    private static final int MARK_OF_GRACE = 11849;

    // Variables
    private int count;
    private static WorldPoint currentArea;
    private List<eObstaclesListing> currentObstacles;  // Variable to store the obstacles for the current area
    public static boolean hidePaint = false;
    public static boolean sleepToPickup = false;
    private long startTime = 0L;
    private long startingSkillExp;
    private long startingSkillLevel;
    static String status = null;
    private static int startMarks;
    private static int totalMarks;

    // GPT gui
    public void initializeGptGUI() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eApiAccess.eAutoResponser(ctx)));// Adds tasks to our {task} list for execution

        // Setting up GPT Gui
        eAutoResponser.scriptPurpose = "you're grinding to get agility pet.";
        eAutoResponser.gptStarted = false;
        initializeGptGUI();
        gptDeactivation();

        // Intro
        System.out.println("Started eAgilityBot!");
        this.ctx.log("--------------- " + getCurrentTimeFormatted() + " ---------------");
        this.ctx.log("------------------------------------");
        this.ctx.log("               eAgilityBot          ");
        this.ctx.log("------------------------------------");

        // Vars
        updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        count = 0;
        startMarks = getCountStacked();
        currentArea = null;
        ctx.viewport.pitch(true);
    }

    @Override
    public void onProcess() {
        super.onProcess();

        final Pathing pathing = ctx.pathing;
        final boolean inMotion = ctx.pathing.inMotion();
        final boolean isAnimating = ctx.players.getLocal().isAnimating();

        if (!botStarted) {
            return;
        }

        if (pathing.energyLevel() > 30 && !pathing.running() && inMotion) {
            pathing.running(true);
        }

        if (!ctx.groundItems.populate().filter(MARK_OF_GRACE).filter((i) -> pathing.reachable(i.getLocation())).isEmpty()) {
            handleGroundItem();
        } else {

            if (currentArea == null) {
                currentArea = getPlayerLocation();
                currentObstacles = null;
            }

            if (currentArea != null) {

                if (currentObstacles == null) {
                    currentObstacles = getObstaclesForArea(currentArea).getObstacles();  // Retrieve obstacles
                    updateStatus(eObstaclesResult.getStatusMessage());
                }

                if (currentObstacles != null && !currentObstacles.isEmpty()) {
                    for (eObstaclesListing obstacle : currentObstacles) {
                        if (pathing.inArea(obstacle.obstacleArea)) {
                            if (pathing.reachable(obstacle.obstaclePoint)) {
                                status = obstacle.actionName + " " + obstacle.objectName.toLowerCase();
                                SimpleObject object = ctx.objects.populate().filter(obstacle.objectName).
                                        filter((location) -> location.getLocation().distanceTo(obstacle.obstaclePoint) <= 3).
                                        filterHasAction(obstacle.actionName).nearest().next();

                                if (object != null && object.validateInteractable()) {

                                    if (!object.visibleOnScreen()) {
                                        ctx.viewport.turnTo(object);
                                        ctx.pathing.step(object.getLocation());
                                        ctx.onCondition(object::visibleOnScreen, 250, 8);
                                    }
                                    object.menuAction(obstacle.actionName);
                                    ctx.onCondition(() -> inMotion || isAnimating, 250, 10);
                                }
                            }
                            break;
                        }
                    }

                } else {
                    updateStatus("No obstacles found nearby");
                    currentArea = null;
                    currentObstacles = null;
                }
            }
        }
    }

    // Setting specific obstacles
    private WorldPoint getPlayerLocation() {
        return ctx.players.getLocal().getLocation();
    }

    private eObstaclesResult getObstaclesForArea(WorldPoint playerLocation) {
        Pathing pathing = ctx.pathing;
        if (pathing.inArea(eDataArdougne.startArea, playerLocation)) {
            return new eObstaclesResult("Chosen: Ardougne Rooftops", true, eDataArdougne.obstaclesArdougne);
        } else if (pathing.inArea(eDataPollnivneach.startArea, playerLocation)) {
            return new eObstaclesResult("Chosen: Pollnivneach Rooftops", false, eDataPollnivneach.obstaclesPollnivneach);
        } else if (pathing.inArea(eDataSeers.startArea, playerLocation)) {
            return new eObstaclesResult("Chosen: Seers Rooftops", false, eDataSeers.obstaclesSeers);
        } else if (pathing.inArea(eDataAlKharid.startArea, playerLocation)) {
            return new eObstaclesResult("Chosen: Al-Kharid Rooftops", false, eDataAlKharid.obstaclesALKharid);
        } else if (pathing.inArea(eDataCanifis.startArea, playerLocation)) {
            return new eObstaclesResult("Chosen: Canifis Rooftops", false, eDataCanifis.obstaclesCanifis);
        } else if (pathing.inArea(eDataVarrock.startArea, playerLocation)) {
            return new eObstaclesResult("Chosen: Varrock Rooftops", false, eDataVarrock.obstaclesVarrock);
        } else if (pathing.inArea(eDataAlRellekka.startArea, playerLocation)) {
            return new eObstaclesResult("Chosen: Rellekka Rooftops", false, eDataAlRellekka.obstaclesRellekka);
        }

        return new eObstaclesResult("Not familiar area. Write: \"---\"", false, null);
    }

    // Picking up ground item
    private void handleGroundItem() {
        SimpleGroundItem itemToPickup = ctx.groundItems.populate().filter(eMain.MARK_OF_GRACE).nearest().next();

        if (itemToPickup != null && itemToPickup.validateInteractable()) {
            if (eObstaclesResult.sleepToPickupCheck() && gameType().equals("Zenyte")) {
                if (ctx.pathing.inMotion()) {
                    ctx.sleep(2000);
                }
            }
            int countInv = ctx.inventory.populate().filter(eMain.MARK_OF_GRACE).population(true);
            itemToPickup.menuAction("Take");
            ctx.onCondition(() -> ctx.groundItems.populate().filter(eMain.MARK_OF_GRACE).isEmpty(), 250, 8);
            if (countInv < ctx.inventory.populate().filter(eMain.MARK_OF_GRACE).population(true)) {
                updateStatus(getCurrentTimeFormatted() + " Picked up " + itemToPickup.getName().toLowerCase());
            }
        }
    }

    // MOG
    private int getCountStacked() {
        return ctx.inventory.populate().filter(eMain.MARK_OF_GRACE).population(true);
    }

    //Utility
    public static String getCurrentTimeFormatted() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    private void updateStatus(String newStatus) {
        status = newStatus;
        ctx.updateStatus(status);
        System.out.println(status);
    }

    private String gameType() {
        Game.ClientType clientType = ctx.game.clientType();

        switch (clientType) {
            case ALORA:
                return "Alora";
            case ATLAS:
                return "Atlas";
            case BATTLESCAPE:
                return "Battlescape";
            case KODAI:
                return "Kodai";
            case NOVEA:
                return "Novea";
            case OSRSPS:
                return "Osrsp";
            case VITALITY:
                return "Vitality";
            case ZENYTE:
                return "Zenyte";
            default:
                return "Normal";
        }
    }

    private String getPlayerLocationUtility() {
        WorldPoint location = ctx.players.getLocal().getLocation();
        return "new WorldPoint(" + location.getX() + ", " + location.getY() + ", " + location.getPlane() + ");";
    }

    @Override
    public void onTerminate() {

        this.ctx.log("-------------- " + getCurrentTimeFormatted() + " --------------");
        this.ctx.log("We have done " + count + " laps.");
        this.ctx.log("We collected " + totalMarks + " MOGs.");
        this.ctx.log("-----------------------------------");
        this.ctx.log("----- Thank You & Good Luck! ------");
        this.ctx.log("-----------------------------------");

        // Other vars
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        totalMarks = 0;
        startMarks = 0;
        guiGpt.setVisible(false);
        gptDeactivation();
        currentArea = null;
        currentObstacles = null;
        sleepToPickup = false;
    }

    @Override
    public void onChatMessage(ChatMessage m) {

        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        if (getType == ChatMessageType.PUBLICCHAT) {

            senderName = senderName.replaceAll("<[^>]+>", "").trim();

            if (senderName.contains(getPlayerName(ctx))) {
                if (formattedMessage.toLowerCase().contains("---")) {
                    currentArea = null;
                    currentObstacles = null;
                } else if (formattedMessage.toLowerCase().contains("1")) {
                    logger.info(getPlayerLocationUtility());
                }
            }
        }

        if (getType == ChatMessageType.GAMEMESSAGE) {
            if (gameMessage.contains("laps on the")) {
                count++;
            }
        }

        if (gptStarted && botStarted) eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        eTriviaInfo.handleBroadcastMessage(getType, gameMessage);
    }

    @Override
    public int loopDuration() {
        return 150;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get MOG count
        totalMarks = getCountStacked() - startMarks;

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 205, 125, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 205, 125, 20, 20);

            g.setColor(philippineRed);
            g.drawString("eAgilityBot by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString("MOG collected: " + totalMarks + " (" + ctx.paint.valuePerHour(totalMarks, startTime) + " per/h)", 15, 210);
            g.drawString("Laps completed: " + count + " (" + actionsPerHour + " per/h)", 15, 225);
            g.drawString("Status: " + status, 15, 240);

        }
    }
}

'''
'''--- src/eAgilityBotZenyte/eObstaclesListing.java ---
package eAgilityBotZenyte;
import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

public class eObstaclesListing {
    WorldArea obstacleArea;
    WorldPoint obstaclePoint;
    String objectName;
    String actionName;

    public eObstaclesListing(WorldArea obstacleArea, WorldPoint obstaclePoint, String actionName, String objectName) {
        this.obstacleArea = obstacleArea;
        this.obstaclePoint = obstaclePoint;
        this.objectName = objectName;
        this.actionName = actionName;
    }

}

'''
'''--- src/eAgilityBotZenyte/eObstaclesResult.java ---
package eAgilityBotZenyte;

import java.util.List;

public class eObstaclesResult {
    public static String statusMessage;
    public static boolean sleepToPickup;
    public final List<eObstaclesListing> obstacles;

    public eObstaclesResult(String statusMessage, boolean sleepToPickup, List<eObstaclesListing> obstacles) {
        eObstaclesResult.statusMessage = statusMessage;
        eObstaclesResult.sleepToPickup = sleepToPickup;
        this.obstacles = obstacles;
    }

    public static String getStatusMessage() {
        return statusMessage;
    }

    public static boolean sleepToPickupCheck() {
        return sleepToPickup;
    }

    public List<eObstaclesListing> getObstacles() {
        return obstacles;
    }
}

'''
'''--- src/eAmethystMinerProZenyte/eMain.java ---
package eAmethystMinerProZenyte;

import BotUtils.eActions;
import BotUtils.eBanking;
import Utility.Trivia.eTriviaInfo;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleObjects;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.queries.SimplePlayerQuery;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Game;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimplePlayer;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;

import static eRandomEventSolver.eRandomEventForester.forestArea;

@ScriptManifest(author = "Esmaabi", category = Category.MINING,
        description = "<br>Most effective amethyst crystal mining bot on Zenyte! <br><br><b>Features & recommendations:</b><br><br>" +
                "<ul>" +
                "<li>You must start with pickaxe </b>equipped</b> or in <b>inventory</b>;</li>" +
                "<li>You must start at mining guild bank near amethyst crystals;</li>" +
                "<li>Do not zoom out <b>to maximum</b>;</li>" +
                "<li>Dragon pickaxe special attack supported;</li>" +
                "<li>Random sleeping included!</li></ul>",
        discord = "Esmaabi#5752",
        name = "eAmethystMinerProZenyte", servers = { "Zenyte" }, version = "2.3")

public class eMain extends TaskScript implements LoopingScript {

    // Coordinates
    private final WorldArea miningArea = new WorldArea (new WorldPoint(3043, 9695, 0), new WorldPoint(2993, 9729, 0));
    private final WorldArea amethArea = new WorldArea (new WorldPoint(3016, 9708, 0), new WorldPoint(3030, 9698, 0));
    private final WorldArea bankArea = new WorldArea (new WorldPoint(3011, 9720, 0), new WorldPoint(3015, 9716, 0));

    // Vars
    private static final String eBotName = "eAmethystMinerPro";
    private static final String ePaintText = "Crystals mined";
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.MINING;
    private long startTime = 0L;
    private long startingSkillLevel;
    private long startingSkillExp;
    private int count;
    static String status = null;
    private int currentExp;
    private long lastAnimation = -1;
    private int comradesInt;

    boolean specialDone = false;
    private final int[] inventoryPickaxe = {30742, 20014, 13243, 12797, 12297, 11920, 1275, 1273, 1271, 1269, 1267, 1265};
    private final String[] names = {"Kristjan", "Hosmann", "Sleeper", "Kristjan Jr"}; // names to ba added to work
    private static boolean hidePaint = false;
    private static String playerGameName;
    private int[] lastCoordinates;
    private boolean maxXpReached;
    private String objectName;
    private String actionName;

    public static int randomSleeping(int minimum, int maximum) {
        return (int)(Math.random() * (maximum - minimum)) + minimum;
    }

    public static String currentTime() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    private void initializeMethods() {
        eBanking bankingUtils = new eBanking(ctx);
        eActions actionUtils = new eActions(ctx);
        BotUtils.eData dataUtils = new BotUtils.eData(ctx);
        eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    //Tasks
    List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList());

        System.out.println("Started eAmethystMiner Pro!");

        this.ctx.updateStatus("--------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " ---------------");
        this.ctx.updateStatus("-------------------------------");
        this.ctx.updateStatus("        " + eBotName + "       ");
        this.ctx.updateStatus("-------------------------------");

        status = "Setting up bot";
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        currentExp = this.ctx.skills.experience(CHOSEN_SKILL);// for actions counter by xp drop
        count = 0;
        ctx.viewport.angle(270);
        ctx.viewport.pitch(true);
        specialDone = false;
        comradesInt = 0;
        lastCoordinates = null;
        maxXpReached = false;
        objectName = "Crystals";
        actionName = "Mine";
    }

    @Override
    public void onProcess() {
        super.onProcess();

        handeCount();
        handleRunning();

        if (ctx.players.populate().population() > 1) {
            if (comradesInArea()) {
                if (playerPopulationCheck()) {
                    System.out.println("Using method population == comradesInt");
                    activeMiningScript();
                    return;
                }

                if (!playerPopulationCheck()) {
                    int sleepTime = randomSleeping(6000, 120000);
                    status = "Anti-ban: sleep for " + convertToSec(sleepTime) + "sec";
                    System.out.println("Using method population > comradesInt");
                    ctx.sleep(sleepTime);
                    activeMiningScript();
                    return;
                }
            }
        }

        if (ctx.players.populate().population() == 1) {
            System.out.println("Using method population == 1");
            activeMiningScript();
        }
    }

    private void activeMiningScript() {
        if (ctx.combat.getSpecialAttackPercentage() == 100
                && ctx.equipment.populate().filter("Dragon pickaxe").population() == 1
                && ctx.players.getLocal().getAnimation() == 6758) {
            int sleep = randomSleeping(2000, 8000);
            status = "Using special attack in " + convertToSec(sleep) + "sec";
            ctx.sleep(sleep);
            if (ctx.players.getLocal().getAnimation() == 6758) {
                ctx.combat.toggleSpecialAttack(true);
                status = "Continuing mining";
                ctx.game.tab(Game.Tab.INVENTORY);
                specialDone = true;
            } else {
                status = "Special attack cancelled";
                if (ctx.inventory.inventoryFull()) {
                    openingBank();
                } else {
                    specialDone = true;
                    miningTask();

                }
            }
        }

        if (miningArea.containsPoint(ctx.players.getLocal().getLocation()) || forestArea.containsPoint(ctx.players.getLocal().getLocation())) {

            if (ctx.inventory.inventoryFull()) {
                openingBank();
            }

            if (!ctx.inventory.inventoryFull() && !ctx.bank.bankOpen()) {
                if (!ctx.players.getLocal().isAnimating() && (System.currentTimeMillis() > (lastAnimation + randomSleeping(1200, 6000)))) {
                    miningTask();
                } else if (ctx.players.getLocal().isAnimating()) {
                    lastAnimation = System.currentTimeMillis();
                }
            }

        } else {
            status = "Player not in mining area";
            ctx.updateStatus(currentTime() + " Player not in mining area");
            ctx.updateStatus(currentTime() + " Stopping script");
            ctx.sleep(2400);
            ctx.stopScript();
        }
    }

    public void openingBank() {
        SimpleObject bankChest = ctx.objects.populate().filter("Bank chest").filterHasAction("Use").nearest().next();
        if (amethArea.containsPoint(ctx.players.getLocal().getLocation()) && !ctx.pathing.inMotion()) {
            status = "Running to bank";
            ctx.pathing.step(3021, 9714);
        }
        if (!ctx.bank.bankOpen()) {
            if (bankChest != null && bankChest.validateInteractable()) {
                status = "Opening bank";
                bankChest.click("Use", "Bank chest");
                ctx.onCondition(() -> ctx.bank.bankOpen(), randomSleeping(2000, 5000));
            }
        }
        if (ctx.bank.bankOpen()) {
            status = "Banking";
            if (ctx.inventory.inventoryFull()) {
                lastCoordinates = null; // reset lastCoordinates for the next run
                status = "Depositing inventory";
                int amethystInv = ctx.inventory.populate().filter("Amethyst").population(); // get population of amethyst ore in inventory
                ctx.bank.depositAllExcept(inventoryPickaxe);
                int inventorySpaceBefore = getInventoryPopulation();
                ctx.onCondition(() -> getInventoryPopulation() < inventorySpaceBefore, 250, 10);
                if (maxXpReached) count += amethystInv;
            }
        }
        if (ctx.bank.bankOpen() && !ctx.inventory.inventoryFull()) {
            status = "Closing bank";
            ctx.bank.closeBank();
            ctx.onCondition(() -> !ctx.bank.bankOpen(), 5000);
        }
    }

    private void handeCount() {
        if (ctx.skills.experience(CHOSEN_SKILL) != 200000000) {
            if (currentExp != this.ctx.skills.experience(CHOSEN_SKILL)) {
                count++;
                currentExp = this.ctx.skills.experience(CHOSEN_SKILL);
            }
        } else {
            maxXpReached = true;
        }
    }

    private int convertToSec(long ms) {
        return (int) TimeUnit.MILLISECONDS.toSeconds(ms);
    }

    private void handleRunning() {
        if (ctx.pathing.energyLevel() > 30 && !ctx.pathing.running() && ctx.pathing.inMotion()) {
            ctx.pathing.running(true);
        }
    }

/*    public void miningTask() {
        if (bankArea.containsPoint(ctx.players.getLocal().getLocation()) && !ctx.pathing.inMotion()) {
            status = "Going to mining area";
            takingStepsRMining();
        }

        SimpleObjects crystalsNearby = (SimpleObjects) ctx.objects.populate().filter("Crystals").filterHasAction("Mine");

        while (!crystalsNearby.isEmpty()) {
            SimpleObject nearestCrystal = crystalsNearby.nearest().next();
            WorldPoint crystalLocation = nearestCrystal.getLocation();

            // Check if there are other players mining the same crystal
            boolean isOtherPlayerMining = !ctx.players.populate().filterWithin(crystalLocation, 1).filter(otherPlayer -> !otherPlayer.getName().equals(ctx.players.getLocal().getName())).isEmpty();

            if (crystalsNearby.size() >= 2 && isOtherPlayerMining) {
                ctx.log("Another player is mining the nearest crystal. Looking for another crystal.");
                crystalsNearby = (SimpleObjects) crystalsNearby.filter(otherCrystal -> !otherCrystal.equals(nearestCrystal));
            } else {
                if (nearestCrystal.validateInteractable()) {
                    if (getInventoryPopulation() > 1) {
                        int sleepTime = randomSleeping(0, 6400);
                        status = "Sleeping for " + sleepTime + "ms";
                        ctx.viewport.turnTo(nearestCrystal);
                        ctx.sleep(sleepTime);
                    }
                    status = "Mining amethyst crystals";
                    nearestCrystal.click("Mine", "Crystals");
                    specialDone = false;
                    ctx.onCondition(() -> ctx.players.getLocal().isAnimating(), 5000);
                    return;
                } else {
                    ctx.log("No suitable crystals found nearby.");
                    return;
                }
            }
        }
    }*/

    private void miningTask() {
        final SimplePlayer localPlayer = ctx.players.getLocal();

        if (bankArea.containsPoint(ctx.players.getLocal().getLocation()) && !ctx.pathing.inMotion()) {
            status = "Going to mining area";
            takingStepsRMining();
        }

        SimpleObjects nearestSpot = (SimpleObjects) ctx.objects.populate().filter(objectName);
        ctx.log("Looking for " + objectName.toLowerCase() + " mining spots...");

        while (!nearestSpot.isEmpty()) {
            SimpleObject nearestObject = nearestSpot.filterHasAction(actionName).nearest().next();
            WorldPoint theTreeLocation = nearestObject.getLocation();
            boolean isOtherPlayerMining = !ctx.players.populate().filterWithin(theTreeLocation, 2).filter(otherPlayer -> !otherPlayer.getName().equals(ctx.players.getLocal().getName())).isEmpty();

            if (nearestSpot.size() >= 2 && isOtherPlayerMining) {
                ctx.log("Another player is mining the nearest " + objectName.toLowerCase() + ".");
                ctx.log("Looking for another spot...");
                nearestSpot = (SimpleObjects) nearestSpot.filter(other -> !other.equals(nearestObject));
                continue;
            } else {
                if (nearestObject.validateInteractable()) {
                    WorldPoint objectLocation = nearestObject.getLocation();
                    boolean objectReachable = isObjectReachable(objectLocation);

                    if (objectReachable) {
                        ctx.log(objectName + " found " + (objectLocation.distanceTo(ctx.players.getLocal().getLocation())) + " tile(s) away");
                        nearestObject.menuAction(actionName);
                        status = "Mining " + objectName.toLowerCase();
                        ctx.log(status);
                        ctx.onCondition(localPlayer::isAnimating, 250, 10);
                        return;
                    } else {
                        ctx.log("Next " + objectName.toLowerCase() + " spot is not reachable.");
                        nearestSpot = (SimpleObjects) nearestSpot.filter(otherTree -> !otherTree.equals(nearestObject));
                    }
                } else {
                    ctx.log("No " + objectName.toLowerCase() + " found in the vicinity.");
                    return;
                }
            }
        }
        ctx.log("No suitable " + objectName.toLowerCase() + " spot found nearby.");
    }

    private boolean isObjectReachable(WorldPoint objectLocation) {
        int[] offsets = { 0, 1, -1}; // Adjust these offsets as needed
        for (int offsetX : offsets) {
            for (int offsetY : offsets) {
                WorldPoint offsetLocation = new WorldPoint(objectLocation.getX() + offsetX, objectLocation.getY() + offsetY, objectLocation.getPlane());
                if (ctx.pathing.reachable(offsetLocation)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean comradesInArea() {
        SimplePlayerQuery<SimplePlayer> comrades = ctx.players.populate().filter(this.names);
        comradesInt = 0;
        if(!comrades.isEmpty()) {
            for(SimplePlayer i : comrades) {
                //ctx.log("Found: " + i.getName() );
                comradesInt ++;
            }
            return true;
        }
        return false;
    }

    private boolean playerPopulationCheck() {
        int population = ctx.players.populate().population();
        System.out.println("Population = " + population + ", comradesInt = " + comradesInt);
        return population == comradesInt;
    }

    public void takingStepsRMining() {
        int max = 6;
        int min = 1;
        int[][] coordinates = {{3024, 9708}, {3018, 9704}, {3022, 9707}, {3028, 9704}, {3019, 9706}, {3027, 9705}};

        if (lastCoordinates == null) {
            // first time running the function, generate a new random location
            int randomNum = ThreadLocalRandom.current().nextInt(min, max + min);
            lastCoordinates = coordinates[randomNum - 1];
        }
        ctx.pathing.step(lastCoordinates[0], lastCoordinates[1]);
    }

    public int getInventoryPopulation() {
        return ctx.inventory.populate().population();
    }

    public String getPlayerName() {
        if (playerGameName == null) {
            playerGameName = ctx.players.getLocal().getName();
        }
        return playerGameName;
    }

    @Override
    public void onTerminate() {
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        count = 0;

        this.ctx.updateStatus("-------------- " + currentTime() + " --------------");
        this.ctx.updateStatus("----------------------");
        this.ctx.updateStatus("Thank You & Good Luck!");
        this.ctx.updateStatus("----------------------");
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        playerGameName = getPlayerName();
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        //eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        eTriviaInfo.handleBroadcastMessage(getType, gameMessage);

        if (getType == ChatMessageType.PUBLICCHAT) {

            // Remove any text within angle brackets and trim
            senderName = senderName.replaceAll("<[^>]+>", "").trim();

            if (senderName.contains(playerGameName) && !getEvent.getMessage().toLowerCase().contains("smashing")) {
                ctx.updateStatus(currentTime() + " Someone asked from you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }

            if (!senderName.contains(playerGameName) && getEvent.getMessage().toLowerCase().contains(playerGameName.toLowerCase())) {
                ctx.updateStatus(currentTime() + " Someone asked for you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }
        }
    }

    @Override
    public int loopDuration() {
        return 200;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        long runTime = System.currentTimeMillis() - this.startTime;
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = skillExpGained * 3600000L / runTime;
        long actionsPerHour = count * 3600000L / (System.currentTimeMillis() - this.startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString("eAmethystMinerPro by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + formatTime(runTime), 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString("Crystals mined: " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + status, 15, 225);

        }
    }

    private String formatTime(long ms) {
        long s = ms / 1000L;
        long m = s / 60L;
        long h = m / 60L;
        s %= 60L;
        m %= 60L;
        h %= 24L;
        return String.format("%02d:%02d:%02d", h, m, s);
    }

}
'''
'''--- src/eAmethystMinerZenyte/eMain.java ---
package eAmethystMinerZenyte;

import BotUtils.eActions;
import BotUtils.eBanking;
import BotUtils.eData;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ItemID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleObjects;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.*;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.util.*;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.logging.Logger;
import java.util.stream.IntStream;

import static eApiAccess.eAutoResponser.*;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.MINING,
        description = "<html>"
                + "<p>The most effective Volcanic Ash miner Bot!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>Start near 3 ash piles (in same area).</li>"
                + "<li><strong>Have any pickaxe equipped or in inventory.</strong>.</li>"
                + "<li>Dragon pickaxe special attack is supported.</li>"
                + "<li>Chat GPT answering is integrated.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eAmethystMinerBot",
        servers = {"Zenyte"},
        version = "1"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final WorldArea BANK_AREA = new WorldArea (new WorldPoint(3011, 9720, 0), new WorldPoint(3015, 9716, 0));
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.MINING;
    private static final String eBotName = "eAmethystMinerBot";
    private static final String ePaintText = "Crystals mined";
    private static final Logger logger = Logger.getLogger(eAnglerFisherBot.eMain.class.getName());
    private static final WorldArea MINING_AREA = new WorldArea (new WorldPoint(3043, 9695, 0), new WorldPoint(2993, 9729, 0));

    // Variables
    private int count;
    private int currentExp;
    private long lastAnimation = -1;
    private int[] lastCoordinates = null;
    private boolean maximumXpReached;
    private static eAutoResponderGui guiGpt;
    public static boolean hidePaint = false;
    private final int[] inventoryPickaxes = {30742, 20014, 13243, 12797, 12297, 11920, 1275, 1273, 1271, 1269, 1267, 1265};
    private long startTime = 0L;
    private long startingSkillExp;
    private long startingSkillLevel;

    // Gui GPT
    private void initializeGptGui() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        BotUtils.eBanking bankingUtils = new eBanking(ctx);
        BotUtils.eActions actionUtils = new eActions(ctx);
        BotUtils.eData dataUtils = new eData(ctx);
        Utility.Trivia.eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx)));
        initializeMethods(); // BotUtils
        initializeGptGui(); // GPT
        eAutoResponser.scriptPurpose = "you're mining some amethyst. ";
        botStarted = false;
        gptStarted = false;

        // Other vars
        ctx.log("--------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " ---------------");
        ctx.log("-------------------------------------");
        ctx.log("            " + eBotName + "         ");
        ctx.log("-------------------------------------");

        // Vars
        BotUtils.eActions.updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        this.currentExp = this.ctx.skills.experience(CHOSEN_SKILL);
        maximumXpReached = ctx.skills.experience(CHOSEN_SKILL) == 200000000;
        count = 0;
        ctx.viewport.angle(180);
        ctx.viewport.pitch(true);
        lastAnimation = System.currentTimeMillis();
        BotUtils.eActions.specialAttackTool = true;
    }

    @Override
    public void onProcess() {
        super.onProcess();

        final SimplePlayer localPlayer = ctx.players.getLocal();

        if (!botStarted) {
            BotUtils.eActions.status = "Please start the bot!";
            return;
        }

        BotUtils.eActions.handleRunning();

        handleCount();

        if (!BotUtils.eActions.inArea(MINING_AREA)) {
            BotUtils.eActions.status = "Searching for mining area...";
            takingStepsRMining();
            return;
        }

        if (ctx.inventory.inventoryFull()) {
            BotUtils.eBanking.bankTask(true, 8, 1, false, -1, -1, inventoryPickaxes);
        } else {
            if (!localPlayer.isAnimating() && (System.currentTimeMillis() > (lastAnimation + BotUtils.eActions.getRandomInt(1200, 12000)))) {
                miningTask();
            } else if (localPlayer.isAnimating()) {
                lastAnimation = System.currentTimeMillis();
            }
        }

        if (localPlayer.isAnimating()) {
            if (BotUtils.eActions.specialAttackTool) {
                BotUtils.eActions.specialAttack(ItemID.DRAGON_PICKAXE);
            }
        }

        int[] combinedItems = IntStream.concat(Arrays.stream(eActions.randomEventItems), IntStream.of(21347))
                .toArray();
        BotUtils.eActions.handleGroundItem("Take", combinedItems);
    }

    private void miningTask() {
        final SimplePlayer localPlayer = ctx.players.getLocal();

        if (BANK_AREA.containsPoint(ctx.players.getLocal().getLocation()) && !ctx.pathing.inMotion()) {
            BotUtils.eActions.updateStatus("Heading to mining area");
            takingStepsRMining();
        }

        String objectName = "Crystals";
        SimpleObjects nearestSpot = (SimpleObjects) ctx.objects.populate().filter(objectName);
        BotUtils.eActions.updateStatus("Looking for nearest mining spot...");

        while (!nearestSpot.isEmpty()) {
            String actionName = "Mine";
            SimpleObject nearestObject = nearestSpot.filterHasAction(actionName).nearest().next();
            WorldPoint theTreeLocation = nearestObject.getLocation();
            boolean isOtherPlayerMining = !ctx.players.populate().filterWithin(theTreeLocation, 2).filter(otherPlayer -> !otherPlayer.getName().equals(ctx.players.getLocal().getName())).isEmpty();

            if (nearestSpot.size() >= 2 && isOtherPlayerMining) {
                BotUtils.eActions.updateStatus("Spot take... Looking for another one...");
                nearestSpot = (SimpleObjects) nearestSpot.filter(other -> !other.equals(nearestObject));
                continue;
            } else {
                if (nearestObject.validateInteractable()) {
                    WorldPoint objectLocation = nearestObject.getLocation();
                    boolean objectReachable = isObjectReachable(objectLocation);

                    if (objectReachable) {
                        int distance = objectLocation.distanceTo(ctx.players.getLocal().getLocation());
                        ctx.log(objectName + " found " + distance + " " + BotUtils.eActions.pluralize(distance, "tile", "tiles") + " away");
                        BotUtils.eActions.interactWith(nearestObject, actionName);
                        BotUtils.eActions.updateStatus("Mining " + objectName.toLowerCase());
                        ctx.onCondition(localPlayer::isAnimating, 250, 10);
                        return;
                    } else {
                        BotUtils.eActions.updateStatus("Next " + objectName.toLowerCase() + " spot is not reachable.");
                        nearestSpot = (SimpleObjects) nearestSpot.filter(otherTree -> !otherTree.equals(nearestObject));
                    }
                } else {
                    BotUtils.eActions.updateStatus("No " + objectName.toLowerCase() + " found in the vicinity.");
                    return;
                }
            }
        }
        BotUtils.eActions.updateStatus("No suitable " + objectName.toLowerCase() + " spot found nearby.");
    }

    private boolean isObjectReachable(WorldPoint objectLocation) {
        int[] offsets = { 0, 1, -1}; // Adjust these offsets as needed
        for (int offsetX : offsets) {
            for (int offsetY : offsets) {
                WorldPoint offsetLocation = new WorldPoint(objectLocation.getX() + offsetX, objectLocation.getY() + offsetY, objectLocation.getPlane());
                if (ctx.pathing.reachable(offsetLocation)) {
                    return true;
                }
            }
        }
        return false;
    }

    public void takingStepsRMining() {
        int max = 6;
        int min = 1;
        int[][] coordinates = {{3024, 9708}, {3018, 9704}, {3022, 9707}, {3028, 9704}, {3019, 9706}, {3027, 9705}};

        if (lastCoordinates == null) {
            int randomNum = ThreadLocalRandom.current().nextInt(min, max + min);
            lastCoordinates = coordinates[randomNum - 1];
        }
        ctx.pathing.step(lastCoordinates[0], lastCoordinates[1]);
    }

    private void handleCount() {
        if (currentExp != this.ctx.skills.experience(CHOSEN_SKILL)) {
            count++;
            currentExp = this.ctx.skills.experience(CHOSEN_SKILL);
        }
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log(ePaintText + ": " + count);
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        guiGpt.setVisible(false);
        gptStarted = false;
        messageSaved = null;
        BotUtils.eActions.specialAttackTool = false;
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        eApiAccess.eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        Utility.Trivia.eTriviaInfo.handleBroadcastMessage(getType, gameMessage);
    }

    @Override
    public int loopDuration() {
        return 600;
    }

    @Override
    public void paint(Graphics g) {

        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePaintText + ": " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + BotUtils.eActions.status, 15, 225);
        }
    }
}
'''
'''--- src/eAnglerFisherBot/eMain.java ---
package eAnglerFisherBot;

import BotUtils.eActions;
import BotUtils.eBanking;
import BotUtils.eData;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ItemID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleInventory;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.*;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.util.*;
import java.util.List;
import java.util.logging.Logger;

import static eApiAccess.eAutoResponser.*;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.FISHING,
        description = "<html>"
                + "<p>The most effective Anglers Fishing bot!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>Start anywhere near trees and bank.</li>"
                + "<li><strong>Examine the tree you want to cut to select it</strong>.</li>"
                + "<li>Bot will bank at any nearby location.</li>"
                + "<li>Bot will chop any tree <strong>you examine</strong>.</li>"
                + "<li>Axe in inventory is supported.</li>"
                + "<li>Dragon harpoon special attack is supported.</li>"
                + "<li>Picking up anglers is supported.</li>"
                + "<li>Auto wearing Anglers outfit pieces is supported.</li>"
                + "<li>Chat GPT answering is integrated.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eAnglerFisherBot with GPT",
        servers = {"Zenyte"},
        version = "0.1"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final String eBotName = "eAnglerFisherBot";
    private static final String ePaintText = "Fish caught";
    private static eAutoResponderGui guiGpt;
    private static final Logger logger = Logger.getLogger(eMain.class.getName());
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.FISHING;
    private final WorldArea ANGLERS_AREA = new WorldArea(new WorldPoint(1841, 3799, 0), new WorldPoint(1792, 3767, 0));

    private static final WorldArea BANK_AREA = new WorldArea(
            new WorldPoint(1815, 3784, 0),
            new WorldPoint(1815, 3779, 0),
            new WorldPoint(1792, 3779, 0),
            new WorldPoint(1792, 3798, 0),
            new WorldPoint(1815, 3798, 0));

    private static final WorldArea FISHING_AREA = new WorldArea(
            new WorldPoint(1815, 3796, 0),
            new WorldPoint(1815, 3778, 0),
            new WorldPoint(1805, 3778, 0),
            new WorldPoint(1805, 3767, 0),
            new WorldPoint(1835, 3767, 0),
            new WorldPoint(1844, 3782, 0),
            new WorldPoint(1837, 3796, 0));

    private final WorldPoint[] WALKING_TO_ANGLER_SPOT = {
            new WorldPoint(1810, 3781, 0),
            new WorldPoint(1818, 3779, 0),
            new WorldPoint(1824, 3775, 0),
    };

    // Variables
    private long startTime = 0L;
    private long startingSkillLevel;
    private long startingSkillExp;
    private int count;
    public static boolean hidePaint = false;
    private long lastAnimation = -1;

    // Gui GPT
    private void initializeGptGui() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        BotUtils.eBanking bankingUtils = new eBanking(ctx);
        BotUtils.eActions actionUtils = new eActions(ctx);
        BotUtils.eData dataUtils = new eData(ctx);
        Utility.Trivia.eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx)));

        initializeMethods(); // BotUtils
        initializeGptGui(); // GPT
        eAutoResponser.scriptPurpose = "you're grinding anglers. ";
        gptDeactivation();

        // Other vars
        ctx.log("--------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " ---------------");
        ctx.log("-------------------------------------");
        ctx.log("            " + eBotName + "         ");
        ctx.log("-------------------------------------");

        // Vars
        BotUtils.eActions.updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        count = 0;
        ctx.viewport.angle(0);
        ctx.viewport.pitch(true);
        lastAnimation = System.currentTimeMillis();
        BotUtils.eActions.specialAttackTool = true;
    }

    @Override
    public void onProcess() {
        super.onProcess();

        final SimplePlayer localPlayer = ctx.players.getLocal();
        final SimpleInventory myInventory = ctx.inventory;

        if (!botStarted) {
            BotUtils.eActions.status = "Please start the bot!";
            return;
        }

        if (!ctx.pathing.inArea(ANGLERS_AREA)) return;

        if (!myInventory.inventoryFull() && !BotUtils.eBanking.bankIsOpen()) {

            if (!localPlayer.isAnimating() && (System.currentTimeMillis() > (lastAnimation + BotUtils.eActions.getRandomInt(1000, 5000)))) {
                fishingTask();
                BotUtils.eActions.status = "Fishing...";
            } else if (localPlayer.isAnimating()) {
                lastAnimation = System.currentTimeMillis();
            }

        } else {
            bankingTask();
        }

        if (BotUtils.eActions.hasItemsInInventory(null, ItemID.ANGLER_HAT, ItemID.ANGLER_TOP, ItemID.ANGLER_WADERS, ItemID.ANGLER_BOOTS)) {
            BotUtils.eActions.updateStatus("Wearing Anglers piece");
            BotUtils.eActions.handleInventoryItem("Wear", ItemID.ANGLER_HAT, ItemID.ANGLER_TOP, ItemID.ANGLER_WADERS, ItemID.ANGLER_BOOTS);
        }

        BotUtils.eActions.handleGroundItem("Take", ItemID.RAW_ANGLERFISH, ItemID.ANTIQUE_LAMP_7498);

        BotUtils.eActions.handleRunning();

        if (localPlayer.isAnimating()) {
            if (BotUtils.eActions.specialAttackTool) {
                BotUtils.eActions.specialAttack(BotUtils.eData.Fishing.SPECIAL_ATTACK_TOOL);
            }
        }
    }

    // Fishing
    private void fishingTask() {
        final SimplePlayer localPlayer = ctx.players.getLocal();
        SimpleNpc fishingSpot = ctx.npcs.populate().filter(6825).filterHasAction("Bait").nearest().next();

        BotUtils.eActions.walkPath(FISHING_AREA, WALKING_TO_ANGLER_SPOT, false);

        if (fishingSpot == null) return;

        if (!fishingSpot.visibleOnScreen()) {
            ctx.pathing.step(fishingSpot.getLocation());
        }
        BotUtils.eActions.interactWith(fishingSpot, "Bait");
        ctx.onCondition(localPlayer::isAnimating, 250, 10);
    }

    private void bankingTask() {
        BotUtils.eActions.walkPath(BANK_AREA, WALKING_TO_ANGLER_SPOT, true);
        BotUtils.eBanking.bankTask(true, 8, 1, false, -1, -1, ItemID.FISHING_ROD, ItemID.SANDWORMS);
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log(ePaintText + ": " + count);
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();
        messageSaved = null;
        BotUtils.eActions.specialAttackTool = false;
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        if (gptStarted && botStarted) eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        Utility.Trivia.eTriviaInfo.handleBroadcastMessage(getType, gameMessage);

        if (getType == ChatMessageType.SPAM) {
            String spamMessage = getEvent.getMessage().toLowerCase();

            if (spamMessage.contains("you catch an")) {
                count++;
            }
        }
    }

    @Override
    public int loopDuration() {
        return 600;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePaintText + ": " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + BotUtils.eActions.status, 15, 225);

        }
    }
}

'''
'''--- src/eAnvilSmitherZenyte/eGui.java ---
package eAnvilSmitherZenyte;

import javax.swing.*;
import java.awt.*;
import java.util.Objects;

public class eGui {
    public static String returnItem;
    public static Component f;

    public static void eGuiDialogueTarget() {
        String[] smithingItems = {"Sword", "Platebody", "Dart tips", "Bolts"};

        ImageIcon eIcon = new ImageIcon(Objects.requireNonNull(eGui.class.getResource("Smithing_cape_logo.png")));

        returnItem = (String) JOptionPane.showInputDialog(f,
                "<html>"
                        + "<b>Select item you want to smith:</b><br><br>"
                        + "<p><strong>Features & recommendations:</strong></p>"
                        + "<ul>"
                        + "<li>Start with a <strong>hammer</strong> in your inventory.</li>"
                        + "<li>Start <strong>with bars in your inventory</strong>.</li>"
                        + "<li>Start at Varrock West Bank or Port Khazard Bank.</li>"
                        + "<li>Zoom out to <strong>see both the anvil and the bank</strong>.</li>"
                        + "<li>Incorporates random sleep times for a more natural behavior.</li>"
                        + "</ul>"
                        + "</html>",
                "Select item you want to smith - eAnvilSmither by Esmaabi",
                JOptionPane.WARNING_MESSAGE, eIcon, smithingItems, smithingItems[2]);
    }

    public static void main(String[] args) {
        eGuiDialogueTarget();
    }
}

'''
'''--- src/eAnvilSmitherZenyte/eMain.java ---
package eAnvilSmitherZenyte;

import eRandomEventSolver.eRandomEventForester;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleBank;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimplePlayer;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.api.ClientContext;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.stream.Collectors;
import java.awt.Graphics;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.SMITHING,
        description = "<html>"
                + "<p>The most effective anvil smithing bot on Zenyte!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>Start with a <strong>hammer</strong> in your inventory.</li>"
                + "<li>Start <strong>with bars in your inventory</strong>.</li>"
                + "<li>Start at Varrock West Bank or Port Khazard Bank.</li>"
                + "<li>Zoom out to <strong>see both the anvil and the bank</strong>.</li>"
                + "<li>Incorporates random sleep times for a more natural behavior.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eAnvilSmitherZenyte",
        servers = {"Zenyte"},
        version = "0.3"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final int HAMMER_ID = 2347;
    private static final String[] BANK_NAME = {"Bank booth", "Bank chest"};

    // Coordinates
    private final WorldArea smithingAreaKhazard = new WorldArea(new WorldPoint(2664, 3157, 0), new WorldPoint(1371, 8982, 0));
    private final WorldArea smithingAreaVarrock = new WorldArea(new WorldPoint(3177, 3449, 0), new WorldPoint(3196, 3418, 0));
    private final WorldPoint anvilLocationKhazard = new WorldPoint(2652, 3164, 0);
    private final WorldPoint anvilLocationVarrock = new WorldPoint(3188, 3426, 0);
    private final WorldPoint bankBoothVarrock = new WorldPoint(3186, 3436, 0);
    private final WorldPoint bankChestKhazard = new WorldPoint(2661, 3163, 0);

    // Variables
    private long startTime = 0L;
    private long startingSkillLevel;
    private long startingSkillExp;
    private int count;
    private int smithingWidget;
    private int barsInInv;
    public static String status = null;
    private static String nameOfItem = null;
    public int minBarsRequired;
    private long lastAnimation = -1;
    private boolean botStarted = false;
    private static boolean hidePaint = false;
    private Runnable lastSmithingTask, lastBankingTask = null;
    private static String playerGameName;

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList());// Adds tasks to our {task} list for execution

        // Other vars
        System.out.println("Started eAnvilSmither!");
        this.ctx.updateStatus("--------------- " + currentTime() + " ---------------");
        this.ctx.updateStatus("-------------------------------");
        this.ctx.updateStatus("       eAnvilSmitherZenyte     ");
        this.ctx.updateStatus("-------------------------------");

        // Vars
        updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(SimpleSkills.Skills.SMITHING);
        this.startingSkillExp = this.ctx.skills.experience(SimpleSkills.Skills.SMITHING);
        lastAnimation = System.currentTimeMillis();
        botStarted = false;
        minBarsRequired = 0;
        count = 0;
        ctx.viewport.angle(270);
        ctx.viewport.pitch(true);

        // Choosing bars and items to smith
        barsInInv = getItemFunction(); //checking which bars to use
        if (barsInInv != -1) {
            eGui.eGuiDialogueTarget();
            String returnItem = eGui.returnItem;
            switch (returnItem) {
                case "Sword":
                    nameOfItem = "swords";
                    updateStatus("Smithing " + nameOfItem);
                    smithingWidget = 3;
                    minBarsRequired = 1;
                    botStarted = true;
                    break;
                case "Platebody":
                    nameOfItem = "platebodies";
                    updateStatus("Smithing " + nameOfItem);
                    smithingWidget = 15;
                    minBarsRequired = 5;
                    botStarted = true;
                    break;
                case "Dart tips":
                    nameOfItem = "dart tips";
                    updateStatus("Smithing " + nameOfItem);
                    smithingWidget = 23;
                    minBarsRequired = 1;
                    botStarted = true;
                    break;
                case "Bolts":
                    nameOfItem = "bolts";
                    updateStatus("Smithing " + nameOfItem);
                    smithingWidget = 28;
                    minBarsRequired = 1;
                    botStarted = true;
                    break;
                default:
                    updateStatus("Waiting for GUI options");
                    botStarted = false;
            }
        }
    }

    @Override
    public void onProcess() {
        super.onProcess();

        if (!botStarted) {
            if (!getHammer()) {
                updateStatus("Hammer not found");
                startBankingTask();
            }
            return;
        }

        if (ctx.pathing.energyLevel() > 30 && !ctx.pathing.running()) {
            ctx.pathing.running(true);
        }

        SimplePlayer localPlayer = ctx.players.getLocal();
        WorldPoint localPlayerLocation = localPlayer.getLocation();
        boolean playerIsAnimating = localPlayer.isAnimating();

        if (smithingAreaVarrock.containsPoint(localPlayerLocation) || smithingAreaKhazard.containsPoint(localPlayerLocation)) {

            int barsInInventoryCount = ctx.inventory.populate().filter(barsInInv).population();

            if (barsInInventoryCount < minBarsRequired) {
                startBankingTask();
            } else {
                if (ctx.bank.bankOpen()) {
                    updateStatus("Closing bank task");
                    ctx.bank.closeBank();
                }

                if (!playerIsAnimating && (System.currentTimeMillis() > (lastAnimation + 6000))) {
                    startingSmithingTask();
                } else if (playerIsAnimating) {
                    lastAnimation = System.currentTimeMillis();
                }
            }
        }
    }

    // Banking
    private void startBankingTask() {
        Runnable bankingTask = getBankingLocation();
        updateStatus("Banking task");
        if (bankingTask != null) {
            bankingTask.run();
        }
    }

    private void openingBank(WorldPoint bankLocation, String bankAction) {
        if (ctx.bank.bankOpen()) {
            updateStatus("Depositing items");
            ctx.bank.depositAllExcept(HAMMER_ID, barsInInv);
            handleHammer();
            updateStatus("Withdrawing bars");
            ctx.bank.withdraw(barsInInv, SimpleBank.Amount.ALL);
            ctx.onCondition(() -> ctx.inventory.populate().filter(barsInInv).population() >= minBarsRequired, 3000);
            updateStatus("Closing bank");
            ctx.bank.closeBank();
            return;
        }

        SimpleObject bankChest = ctx.objects.populate().filter(BANK_NAME).nearest(bankLocation).next();
        if (!ctx.bank.bankOpen() && !ctx.pathing.inMotion()) {
            if (bankChest != null && bankChest.validateInteractable()) {
                int sleepTime = randomSleeping(0, 6000);
                updateStatus("Sleeping to bank (" + sleepTime + "ms)");
                ctx.sleep(sleepTime);
                updateStatus("Refilling supplies");
                bankChest.click(bankAction);
                ctx.onCondition(() -> ctx.bank.bankOpen(), 5000);
            }
        }
    }

    private void openingBankKhazard() {
        openingBank(bankChestKhazard, "Use");
    }

    private void openingBankVarrock() {
        openingBank(bankBoothVarrock, "Bank");
    }

    private Runnable getBankingLocation() {
        if (lastBankingTask != null) {
            return lastBankingTask;
        }

        if (smithingAreaVarrock.containsPoint(ctx.players.getLocal().getLocation())) {
            lastBankingTask = this::openingBankVarrock;
        } else if (smithingAreaKhazard.containsPoint(ctx.players.getLocal().getLocation())) {
            lastBankingTask = this::openingBankKhazard;
        }

        return lastBankingTask;
    }

    private boolean getHammer() {
        SimpleItem hammer = ctx.inventory.populate().filter(HAMMER_ID).next();
        return hammer != null;
    }

    private void handleHammer() {
        boolean hammerInInv = getHammer();
        if (hammerInInv) {
            return;
        }

        SimpleItem hammerInBank = ctx.bank.populate().filter(HAMMER_ID).next();
        if (hammerInBank == null) {
            updateStatus("No hammer in bank");
            ctx.updateStatus("Stopping script");
            ctx.sleep(10000);
            ctx.stopScript();
        } else {
            withdrawHammer();
            clearBankSearch();
        }
    }

    private void withdrawHammer() {
        updateStatus("Withdrawing hammer");
        SimpleWidget quantityOne = ctx.widgets.getWidget(12, 29);
        if (quantityOne != null && !quantityOne.isHidden()) {
            quantityOne.click(0);
        }
        ctx.bank.withdraw(HAMMER_ID, SimpleBank.Amount.ONE);
    }

    private void clearBankSearch() {
        SimpleWidget searchButton = ctx.widgets.getWidget(12, 40);
        if (searchButton != null && !searchButton.isHidden()) {
            searchButton.click(0);
        }
    }

    // Smithing
    private void startingSmithingTask() {
        Runnable smithingTask = getSmithingLocation();
        if (smithingTask != null) {
            smithingTask.run();
        }
    }

    private void smithingTask(WorldPoint anvilLocation) {
        SimpleObject anvil = ctx.objects.populate().filter("Anvil").nearest(anvilLocation).next();
        SimpleWidget smithingItem = ctx.widgets.getWidget(312, smithingWidget);
        boolean widgetScreenVisible = smithingItem != null && !smithingItem.isHidden();

        if (ctx.players.getLocal().isAnimating()) {
            return;
        }

        if (!widgetScreenVisible) {
            if (anvil != null && anvil.validateInteractable() && !ctx.pathing.inMotion()) {
                updateStatus("Clicking anvil");
                anvil.menuAction("Smith");
                ctx.sleepCondition(() -> smithingItem == null, 5000);
            }
        } else {
            updateStatus("Making " + nameOfItem);
            smithingItem.click(5); // menu element 5
            lastAnimation = System.currentTimeMillis();
            ctx.onCondition(smithingItem::isHidden, 250, 10);
            lastAnimation = System.currentTimeMillis();
        }
    }

    private void smithingTaskKhazard() {
        smithingTask(anvilLocationKhazard);
    }

    private void smithingTaskVarrock() {
        smithingTask(anvilLocationVarrock);
    }

    private Runnable getSmithingLocation() {
        if (lastSmithingTask != null) {
            return lastSmithingTask;
        }

        if (smithingAreaVarrock.containsPoint(ctx.players.getLocal().getLocation())) {
            lastSmithingTask = this::smithingTaskVarrock;
        } else if (smithingAreaKhazard.containsPoint(ctx.players.getLocal().getLocation())) {
            lastSmithingTask = this::smithingTaskKhazard;
        }

        return lastSmithingTask;
    }

    //Getting bars ID onExecute
    private static int getItemId(String... itemName) {
        HashSet<String> lowerCaseItemNames = Arrays.stream(itemName)
                .map(String::toLowerCase)
                .collect(Collectors.toCollection(HashSet::new));

        SimpleItem optionalItem = ClientContext.instance().inventory.populate()
                .filter(p -> {
                    String lowerCaseItemName = p.getName().toLowerCase();
                    return lowerCaseItemNames.stream().anyMatch(lowerCaseItemName::contains);
                })
                .next();

        return optionalItem != null ? optionalItem.getId() : -1;
    }

    private int getItemFunction() {
        int barsInventory = getItemId("bar");
        if (barsInventory == -1) {
            updateStatus("No bars in inventory to learn!");
            ctx.updateStatus("Please start with bars in inventory");
            ctx.sleep(5000);
            updateStatus("Stopping script");
            ctx.stopScript();
        } else {
            updateStatus("Bars in inventory found");
        }
        return barsInventory;
    }

    //Utility
    public static int randomSleeping(int minimum, int maximum) {
        return (int)(Math.random() * (maximum - minimum)) + minimum;
    }

    public static String currentTime() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    private void updateStatus(String newStatus) {
        status = newStatus;
        ctx.updateStatus(status);
        System.out.println(status);
    }

    public String getPlayerName() {
        if (playerGameName == null) {
            playerGameName = ctx.players.getLocal().getName();
        }
        return playerGameName;
    }

    @Override
    public void onTerminate() {

        // Other vars
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;

        this.ctx.updateStatus("-------------- " + currentTime() + " --------------");
        this.ctx.updateStatus("----------------------");
        this.ctx.updateStatus("Thank You & Good Luck!");
        this.ctx.updateStatus("----------------------");
    }

    @Override
    public void onChatMessage(ChatMessage m) {

        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        playerGameName = getPlayerName();
        String message = m.getMessage().toLowerCase();

        if (m.getMessage() == null) {
            return;
        }

        if (m.getMessage() != null) {
            if (message.contains("you hammer the")) {
                count++;
            }
        }

        if (getType == ChatMessageType.PUBLICCHAT) {
            String senderName = getEvent.getName();

            // Remove any text within angle brackets and trim
            senderName = senderName.replaceAll("<[^>]+>", "").trim();

            if (senderName.contains(playerGameName)) {
                ctx.updateStatus(currentTime() + " Someone asked for you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }

        }
    }

    @Override
    public int loopDuration() {
        return 150;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        long runTime = System.currentTimeMillis() - this.startTime;
        long currentSkillLevel = this.ctx.skills.realLevel(SimpleSkills.Skills.SMITHING);
        long currentSkillExp = this.ctx.skills.experience(SimpleSkills.Skills.SMITHING);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = skillExpGained * 3600000L / runTime;
        long actionsPerHour = count * 3600000L / (System.currentTimeMillis() - this.startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString("eAnvilSmithingBot by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + formatTime(runTime), 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString("Items smithed: " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + status, 15, 225);

        }
    }

    private String formatTime(long ms) {
        long s = ms / 1000L;
        long m = s / 60L;
        long h = m / 60L;
        s %= 60L;
        m %= 60L;
        h %= 24L;
        return String.format("%02d:%02d:%02d", h, m, s);
    }

}
'''
'''--- src/eApiAccess/eAutoResponderGui.java ---
package eApiAccess;

import BotUtils.eActions;
import org.json.JSONObject;
import simple.robot.api.ClientContext;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.*;
import java.security.spec.KeySpec;
import java.util.Base64;
import java.util.Objects;
import java.util.logging.Level;
import java.util.logging.Logger;

public class eAutoResponderGui extends JFrame {
    public static final String[] ACTIVITY = {"Script purpose", "PVM", "Chilling", "Skilling", "Money making"};
    private static final String API_KEY_FILE_PATH = "esmaabi_gpt_api_key_data.enc";
    public static final String[] GPT_MODELS = {"GPT 3.5 Turbo", "GPT 4"};
    private static final Logger logger = Logger.getLogger(eAutoResponderGui.class.getName());
    static JPasswordField apiKeyPasswordField;
    private JComboBox<String> chatActivityComboBox;
    private JComboBox<String> selectGptModelComboBox;
    private JCheckBox properGrammar;
    private JCheckBox gptActiveAtHomeArea;
    private JCheckBox useMouseActions;
    private JCheckBox activateChatGPT;
    private JButton startButton;
    private JButton pauseButton;
    private JButton saveButton;
    private JButton loadButton;
    private ClientContext ctx;

    /// Encryption
    private static final String ENCRYPTION_ALGO = "AES/CBC/PKCS5Padding";
    private static final String SECRET_KEY_ALGO = "PBKDF2WithHmacSHA256";
    private static final String SALT = "aRandomSaltForPBE"; // Change this to a long random string!
    private static final int ITERATION_COUNT = 65536;
    private static final int KEY_LENGTH = 256;
    JPasswordField passphraseField = new JPasswordField();

    public eAutoResponderGui() {
        setTitle("Bot settings by Esmaabi");
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        Point mouseLocation = MouseInfo.getPointerInfo().getLocation();
        setLocation(mouseLocation.x, mouseLocation.y);
        setIconImage(new ImageIcon(Objects.requireNonNull(getClass().getResource("esmaabi-icon.png"))).getImage());

        initGUI();

        pack();
    }

    private void initGUI() {
        JPanel contentPane = new JPanel(new GridBagLayout());
        contentPane.setBackground(Color.DARK_GRAY);
        setContentPane(contentPane);

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.insets = new Insets(5, 5, 5, 5);

        // Add title
        constraints.gridy = 0;
        constraints.gridx = 0;
        constraints.gridwidth = 2;
        constraints.anchor = GridBagConstraints.CENTER;
        addLabel("Please choose options below!", contentPane, constraints, true);

        constraints.gridwidth = 1; // Resetting gridwidth
        constraints.anchor = GridBagConstraints.WEST; // Resetting anchor

        constraints.gridy++; // Moving to next row
        constraints.gridx = 0; // Resetting x-axis position to 0

        // Activate ChatGPT checkbox
        addLabel("Activate ChatGPT: ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        activateChatGPT = addCheckBox(contentPane, constraints);
        activateChatGPT.setToolTipText("Enable or disable ChatGPT answering.");

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row

        // Choose GPT model
        addLabel("Select GPT model: ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        selectGptModelComboBox = addComboBox(contentPane, constraints, GPT_MODELS);
        selectGptModelComboBox.setPreferredSize(new Dimension(150, selectGptModelComboBox.getPreferredSize().height));
        selectGptModelComboBox.setToolTipText("What GPT model you'd like to use?");

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row

        // Activity type
        addLabel("Select activity: ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        chatActivityComboBox = addComboBox(contentPane, constraints, ACTIVITY);
        chatActivityComboBox.setPreferredSize(new Dimension(150, chatActivityComboBox.getPreferredSize().height));
        chatActivityComboBox.setToolTipText("Choose what you want the bot to answer");

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row

        // GPT active at home checkbox
        addLabel("GPT active at home? ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        gptActiveAtHomeArea = addCheckBox(contentPane, constraints);
        gptActiveAtHomeArea.setToolTipText("Select if you want GPT to be active at home area.");

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row

        // Grammar checkbox
        addLabel("Use proper grammar? ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        properGrammar = addCheckBox(contentPane, constraints);
        properGrammar.setToolTipText("Click if you don't want to use abbreviations, etc.");

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row

        // MenuActions checkbox
        addLabel("Use mouse clicking? ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        useMouseActions = addCheckBox(contentPane, constraints);
        useMouseActions.setToolTipText("Do not check if you wish to use menu actions instead of mouse.");

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row

        // API Key
        addLabel("Insert API key:", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        apiKeyPasswordField = addPasswordField(contentPane, constraints);
        apiKeyPasswordField.setPreferredSize(new Dimension(150, apiKeyPasswordField.getPreferredSize().height));
        apiKeyPasswordField.setEchoChar('\u2022'); // Set the echo character as a dot or asterisk
        apiKeyPasswordField.setToolTipText("Supported: GPT 3.5-turbo"); // Set the tooltip text for the API key field

        // Save Button
        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row
        constraints.anchor = GridBagConstraints.CENTER;
        saveButton = addButton("Save", contentPane, constraints);
        saveButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                saveApiKeyToFile(true);
            }
        });
        saveButton.setToolTipText("Save the API key to a file"); // Set the tooltip text for the Save button

        // Load Button
        constraints.gridx = 1; // Setting x-axis position to 1
        loadButton = addButton("Load", contentPane, constraints);
        loadButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                loadApiKeyFromFile(true);
            }
        });
        loadButton.setToolTipText("Load the API key from a file"); // Set the tooltip text for the Load button

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row
        constraints.gridwidth = 2; // Resetting gridwidth
        constraints.anchor = GridBagConstraints.CENTER; // Resetting anchor

        // Start and Pause buttons
        JPanel buttonsPanel = new JPanel(new GridLayout(1, 2, 5, 0));
        startButton = new JButton("Start");
        startButton.addActionListener(e -> startBot());
        startButton.setBackground(Color.GREEN);
        buttonsPanel.add(startButton);
        pauseButton = new JButton("Pause");
        pauseButton.addActionListener(e -> pauseBot());
        pauseButton.setVisible(false); // Setting button invisible
        pauseButton.setBackground(Color.RED);
        buttonsPanel.add(pauseButton);
        contentPane.add(buttonsPanel, constraints);
    }

    private void addLabel(String text, Container container, GridBagConstraints constraints, boolean isTitle) {
        JLabel label = new JLabel(text);
        label.setForeground(Color.WHITE);
        if (isTitle) {
            label.setFont(label.getFont().deriveFont(Font.BOLD, 16));
        }
        container.add(label, constraints);
        constraints.gridx++;
    }

    private JComboBox<String> addComboBox(Container container, GridBagConstraints constraints, String[] items) {
        JComboBox<String> comboBox = new JComboBox<>(items);
        container.add(comboBox, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
        return comboBox;
    }

    private JCheckBox addCheckBox(Container container, GridBagConstraints constraints) {
        JCheckBox checkBox = new JCheckBox();
        container.add(checkBox, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
        return checkBox;
    }

    private JTextField addTextField(Container container, GridBagConstraints constraints) {
        JTextField textField = new JTextField();
        container.add(textField, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
        return textField;
    }

    private JButton addButton(String text, Container container, GridBagConstraints constraints) {
        JButton button = new JButton(text);
        container.add(button, constraints);
        return button;
    }

    private void startBot() {
        eAutoResponser.botStarted = true;
        eAutoResponser.gptStarted = activateChatGPT.isSelected();
        pauseButton.setVisible(true);
        startButton.setVisible(false);
        gptActiveAtHomeArea.setEnabled(false);
        eAutoResponser.gptActiveAtHome = gptActiveAtHomeArea.isSelected();
        useMouseActions.setEnabled(false);
        eActions.menuActionMode = !useMouseActions.isSelected();
        activateChatGPT.setEnabled(false);
        if (activateChatGPT.isSelected()) {
            disableChatGPTOptions();
            eAutoResponser.gptIsActive = true;
            eAutoResponser.properGrammarActive = getProperGrammar();
            getSelectedActivity();
            getSelectedGptModel();
        }
    }

    private void pauseBot() {
        eAutoResponser.botStarted = false;
        eAutoResponser.gptStarted = activateChatGPT.isSelected();
        pauseButton.setVisible(false);
        startButton.setVisible(true);
        gptActiveAtHomeArea.setEnabled(true);
        eAutoResponser.gptActiveAtHome = gptActiveAtHomeArea.isSelected();
        useMouseActions.setEnabled(true);
        eActions.menuActionMode = useMouseActions.isSelected();
        activateChatGPT.setEnabled(true);
        if (activateChatGPT.isSelected()) {
            enableChatGPTOptions();
            eAutoResponser.gptIsActive = false;
            eAutoResponser.properGrammarActive = getProperGrammar();
        }
    }

    private boolean getProperGrammar() {
        return properGrammar.isSelected();
    }

    private void getSelectedActivity() {
        String selectedActivity = (String) chatActivityComboBox.getSelectedItem();

        eApiAccess.eAutoResponser.skillingActivity = false;
        eApiAccess.eAutoResponser.pvmActivity = false;
        eApiAccess.eAutoResponser.chillingActivity = false;
        eApiAccess.eAutoResponser.moneyMakingActivity = false;
        eApiAccess.eAutoResponser.scriptPurposeActivity = false;
        eApiAccess.eAutoResponser.scriptPurposeCustomActivity = false;

        switch (Objects.requireNonNull(selectedActivity)) {
            case "Skilling":
                eApiAccess.eAutoResponser.skillingActivity = true;
                break;
            case "PVM":
                eApiAccess.eAutoResponser.pvmActivity = true;
                break;
            case "Money making":
                eApiAccess.eAutoResponser.moneyMakingActivity = true;
                break;
            case "Chilling":
                eApiAccess.eAutoResponser.chillingActivity = true;
                break;
            case "Script purpose":
                eApiAccess.eAutoResponser.scriptPurposeActivity = true;
                break;
            case "Custom reason":
                eApiAccess.eAutoResponser.scriptPurposeCustomActivity = true;
                break;
        }
    }

    private void displayMessage(String message, String title, int messageType) {
        JOptionPane optionPane = new JOptionPane(message, messageType);
        JDialog dialog = optionPane.createDialog(this, title);
        Point mouseLocation = MouseInfo.getPointerInfo().getLocation();
        dialog.setLocation(mouseLocation.x - dialog.getWidth() / 2, mouseLocation.y - dialog.getHeight() / 2);
        dialog.setVisible(true);
    }

    private SecretKey getSecretKey(char[] passphrase) throws Exception {
        SecretKeyFactory factory = SecretKeyFactory.getInstance(SECRET_KEY_ALGO);
        KeySpec spec = new PBEKeySpec(passphrase, SALT.getBytes(), ITERATION_COUNT, KEY_LENGTH);
        SecretKey tmp = factory.generateSecret(spec);
        return new SecretKeySpec(tmp.getEncoded(), "AES");
    }

    private void saveApiKeyToFile(boolean showMessage) {
        String apiKey = new String(apiKeyPasswordField.getPassword());
        char[] passphrase = passphraseField.getPassword();
        try {
            // Encryption
            Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGO);
            SecretKey secretKey = getSecretKey(passphrase);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            byte[] encryptedApiKey = cipher.doFinal(apiKey.getBytes());
            byte[] iv = cipher.getIV();

            // Convert to JSON and save
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("encryptedKey", Base64.getEncoder().encodeToString(encryptedApiKey));
            jsonObject.put("iv", Base64.getEncoder().encodeToString(iv));

            try (PrintWriter writer = new PrintWriter(new FileWriter(API_KEY_FILE_PATH))) {
                writer.println(jsonObject.toString());
                writer.flush();
                if (showMessage) displayMessage("API key saved successfully", "API Key Saved", JOptionPane.INFORMATION_MESSAGE);
                logger.severe("API key saved successfully");
            }
        } catch (Exception e) {
            logger.severe("Failed to save API key " + e);
            if (showMessage) displayMessage("Failed to save API key", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void loadApiKeyFromFile(boolean showMessage) {
        char[] passphrase = passphraseField.getPassword();
        try (BufferedReader reader = new BufferedReader(new FileReader(API_KEY_FILE_PATH))) {
            String line = reader.readLine();
            if (line != null) {
                JSONObject jsonObject = new JSONObject(line);
                byte[] encryptedApiKey = Base64.getDecoder().decode(jsonObject.getString("encryptedKey"));
                byte[] iv = Base64.getDecoder().decode(jsonObject.getString("iv"));

                // Decryption
                Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGO);
                SecretKey secretKey = getSecretKey(passphrase);
                cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));
                String apiKey = new String(cipher.doFinal(encryptedApiKey));

                apiKeyPasswordField.setText(apiKey);
                if (showMessage) displayMessage("API key loaded successfully", "API Key Loaded", JOptionPane.INFORMATION_MESSAGE);
                logger.info("API key loaded successfully");
            } else {
                if (showMessage) displayMessage("API key not found in the file", "Error", JOptionPane.ERROR_MESSAGE);
                logger.severe("API key not found in the file");
            }
        } catch (Exception e) {
            logger.severe("Failed to load API key. Please add it again " + e);
            if (showMessage) displayMessage("Failed to load API key. Please add it again", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    private JPasswordField addPasswordField(Container container, GridBagConstraints constraints) {
        JPasswordField passwordField = new JPasswordField();
        container.add(passwordField, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
        return passwordField;
    }

    private void enableChatGPTOptions() {
        chatActivityComboBox.setEnabled(true);
        properGrammar.setEnabled(true);
        apiKeyPasswordField.setEnabled(true);
        loadButton.setEnabled(true);
        saveButton.setEnabled(true);
    }

    private void disableChatGPTOptions() {
        chatActivityComboBox.setEnabled(false);
        properGrammar.setEnabled(false);
        apiKeyPasswordField.setEnabled(false);
        loadButton.setEnabled(false);
        saveButton.setEnabled(false);
    }

    private void getSelectedGptModel() {
        String selectedGptModel = (String) selectGptModelComboBox.getSelectedItem();

        eAutoResponser.useGPT3 = false;
        eAutoResponser.useGPT4 = false;

        switch (Objects.requireNonNull(selectedGptModel)) {
            case "GPT 3.5 Turbo":
                eAutoResponser.useGPT3 = true;
                break;
            case "GPT 4":
                eAutoResponser.useGPT4 = true;
                break;
        }
    }

    public static void main(String[] args) {
        EventQueue.invokeLater(() -> {
            try {
                eAutoResponderGui frame = new eAutoResponderGui();
                frame.setVisible(true);
            } catch (Exception e) {
                logger.log(Level.SEVERE, "Failed to initialize eAutoResponderGui", e);
            }
        });
    }
}
'''
'''--- src/eApiAccess/eAutoResponser.java ---
package eApiAccess;

import eAutoFighterZenyte.AutoFighterUI;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import simple.hooks.scripts.task.Task;
import simple.hooks.simplebot.Game;
import simple.hooks.wrappers.SimplePlayer;
import simple.robot.api.ClientContext;
import simple.robot.utils.WorldArea;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Arrays;
import java.util.concurrent.ThreadLocalRandom;
import java.util.logging.Level;
import java.util.logging.Logger;

public class eAutoResponser extends Task {

    // Constants
    private static final Logger logger = Logger.getLogger(eAutoResponser.class.getName());
    public static final WorldArea EDGE_HOME_AREA = new WorldArea(new WorldPoint(3110, 3474, 0), new WorldPoint(3074, 3516, 0));

    // Variables
    public static boolean botStarted;
    public static boolean chillingActivity;
    private static ClientContext ctx;
    public static boolean gptActiveAtHome;
    public static boolean gptIsActive;
    public static boolean gptStarted;
    private boolean isProcessingPrompt = false;
    public static String messageSaved;
    public static String messageToGPT;
    public static boolean moneyMakingActivity;
    public static String otherPlayerName = null;
    public static String playerGameName = null;
    public static boolean properGrammarActive;
    public static boolean pvmActivity;
    public static String scriptPurpose = null;
    public static boolean scriptPurposeActivity;
    public static String scriptPurposeCustom  = null;
    public static boolean scriptPurposeCustomActivity;
    public static boolean skillingActivity;
    public static boolean slayerActivity;
    public static int tokensUsed;
    public static boolean useGPT3;
    public static boolean useGPT4;

    public eAutoResponser(ClientContext ctx) {
        super(ctx);
        eAutoResponser.ctx = ctx;
    }

    @Override
    public boolean condition() { // Condition to run this task
        return !isProcessingPrompt && messageSaved != null && gptStarted && gptIsActive;
    }

    @Override
    public void run() {
        if (!botStarted || !gptStarted) return;
        Thread gptThread = new Thread(this::gptRadar);
        gptThread.start();
    }

    // ChatGPT
    public void gptRadar() {
        if (!isProcessingPrompt && messageSaved != null) {
            isProcessingPrompt = true; // Set to indicate prompt processing
            try {
                String response = chatGPT(messageSaved);
                if (response != null) {
                    writeTask(response);
                }
            } catch (JSONException e) {
                logger.info("A JSON exception occurred while processing chatGPT: " + e);
            } catch (Exception e) {
                logger.info("An exception occurred while processing chatGPT: " + e);
            } finally {
                isProcessingPrompt = false; // Reset after prompt processing
            }
        }
    }

    public String chatGPT(String text) {
        String url = "https://api.openai.com/v1/chat/completions";
        String apiKey = getApiKey();

        if (apiKey.isEmpty()) {
            ctx.log("GPT API Key is missing.");
            return null;
        }

        try {
            URL apiUrl = new URL(url);
            HttpURLConnection con = (HttpURLConnection) apiUrl.openConnection();
            con.setRequestMethod("POST");
            con.setRequestProperty("Content-Type", "application/json");
            con.setRequestProperty("Authorization", "Bearer " + apiKey);

            JSONObject data = new JSONObject();
            if (useGPT3) {
                data.put("model", "gpt-3.5-turbo");
            } else if (useGPT4) {
                data.put("model", "gpt-4");
            }

            JSONArray messagesArray = new JSONArray();
            try {
                messagesArray.put(gptSystemSettings());
                messagesArray.put(gptUserMessage(text));
            } catch (JSONException e) {
                logger.log(Level.SEVERE, "JSONException occurred", e);
            }

            data.put("messages", messagesArray);
            data.put("max_tokens", 2000);
            data.put("temperature", 0.2);

            con.setDoOutput(true);
            con.getOutputStream().write(data.toString().getBytes());

            int responseCode = con.getResponseCode();
            if (responseCode == HttpURLConnection.HTTP_OK) {
                BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));
                StringBuilder response = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    response.append(line);
                }
                reader.close();

                JSONObject jsonResponse = new JSONObject(response.toString());
                // Extracting the number of tokens used in the prompt
                int tokenOutput = jsonResponse.getJSONObject("usage").getInt("prompt_tokens");
                // Logging the token count
                tokensUsed += tokenOutput;
                logger.info("Number of tokens used in the prompt: " + tokenOutput + " (Total usage: " + tokensUsed + ")");

                JSONArray choicesArray = jsonResponse.getJSONArray("choices");
                if (!choicesArray.isEmpty()) {
                    JSONObject firstChoice = choicesArray.getJSONObject(0);
                    return firstChoice.getJSONObject("message").getString("content");
                }
            } else {
                String errorResponse;
                try (BufferedReader errorReader = new BufferedReader(new InputStreamReader(con.getErrorStream()))) {
                    StringBuilder errorResponseBuilder = new StringBuilder();
                    String errorLine;
                    while ((errorLine = errorReader.readLine()) != null) {
                        errorResponseBuilder.append(errorLine);
                    }
                    errorResponse = errorResponseBuilder.toString();
                }

                JSONObject errorJson;
                try {
                    errorJson = new JSONObject(errorResponse);
                    String errorMessage = errorJson.getJSONObject("error").getString("message");
                    logger.warning("API request failed with response code: " + responseCode + " - Error: " + errorMessage);
                } catch (JSONException e) {
                    logger.warning("API request failed with response code: " + responseCode + " - Error: " + errorResponse);
                }
            }
        } catch (IOException | JSONException e) {
            logger.log(Level.SEVERE, "Exception occurred", e);
        }

        return null; // Return null if no valid response is obtained
    }

    private JSONObject gptSystemSettings() throws JSONException {
        String termsForChatStart = "You are currently implemented in an Old School RuneScape (OSRS) bot script on the " + gameType() + " private server. Your in-game name is " + getPlayerName(ctx) + ". Your objective is to be a normal player and engage in natural conversations with other players so they do not get suspicious while the bot is doing tasks. When responding to other players, provide concise and direct answers without mentioning names or using unnecessary dialogue tags like \"Response:\" or \"\". Do not mention botting, bot, Simplebot, OpenAI, AI or language models. Your output must be only a response to what the player said. Keep your responses within 70 characters. Do not be chatty or too helpful. Do not ask questions. ";
        String termsForActivityStart = "If asked what you're doing, ";
        String termsForActivitySkilling = "mention your focus on skilling. ";
        String termsForActivitySlayer = "you're doing slayer. ";
        String termsForActivityPVM = "mention your engagement in PvM activities. ";
        String termsForActivityMoney = "you're trying to make some money. ";
        String termsForActivityChilling = "say you're chilling. ";
        String termsForChatFinal = "The other player name is " + otherPlayerName;

        StringBuilder messageBuilder = new StringBuilder(termsForChatStart);

        if (!properGrammarActive) {
            String termsForChatGrammar = "Do not use proper grammar, instead use Runescape related slang and abbreviation. ";
            messageBuilder.append(termsForChatGrammar);
        }

        messageBuilder.append(termsForActivityStart);

        if (chillingActivity) {
            messageBuilder.append(termsForActivityChilling);
        } else if (skillingActivity) {
            messageBuilder.append(termsForActivitySkilling);
        } else if (slayerActivity) {
            messageBuilder.append(termsForActivitySlayer);
        } else if (pvmActivity) {
            messageBuilder.append(termsForActivityPVM);
        } else if (moneyMakingActivity) {
            messageBuilder.append(termsForActivityMoney);
        } else if (scriptPurposeActivity) {
            messageBuilder.append(scriptPurpose);
        } else if (scriptPurposeCustomActivity) {
            messageBuilder.append(scriptPurposeCustom);
        }

        messageBuilder.append(termsForChatFinal);

        JSONObject systemObject = new JSONObject();
        systemObject.put("role", "system");
        systemObject.put("content", messageBuilder.toString());
        logger.info(messageBuilder.toString());

        return systemObject;
    }

    private static JSONObject gptUserMessage(String text) throws JSONException {
        JSONObject userObject = new JSONObject();
        userObject.put("role", "user");
        userObject.put("content", text);

        return userObject;
    }

    private String gameType() {
        Game.ClientType clientType = ctx.game.clientType();

        switch (clientType) {
            case ALORA:
                return "Alora";
            case ATLAS:
                return "Atlas";
            case BATTLESCAPE:
                return "Battlescape";
            case KODAI:
                return "Kodai";
            case NOVEA:
                return "Novea";
            case OSRSPS:
                return "Osrsp";
            case VITALITY:
                return "Vitality";
            case ZENYTE:
                return "Zenyte";
            default:
                return "Normal";
        }
    }

    public static String trimGameMessage(String gameMessage) {
        return gameMessage.replaceAll("<[^>]+>", "").trim();
    }

    public static void handleGptMessages(ChatMessageType type, String senderName, String formattedMessage) {
        if (type == ChatMessageType.PUBLICCHAT) {
            // Remove any text within angle brackets and trim
            senderName = trimGameMessage(senderName);

            if (senderName.equals(getPlayerName(ctx))) {
                if (formattedMessage.toLowerCase().contains("---")) {
                    messageSaved = null;
                } else {
                    logger.info("You wrote: " + formattedMessage);
                    return;
                }
            }

            if (!senderName.equals(getPlayerName(ctx))) {
                if (ctx.pathing.inArea(EDGE_HOME_AREA) && !gptActiveAtHome) { ctx.log("GPT not active at home"); return; }
                otherPlayerName = senderName;
                messageSaved = formattedMessage;
                logger.info("Player " + otherPlayerName + " wrote: " + messageSaved);
            }
        }
    }

    public static String getPlayerName(ClientContext ctx) {
        if (ctx == null) {
            logger.severe("ctx = null");
            return null; // Or some default value or throw an exception
        }

        if (ctx.players == null) {
            logger.severe("ctx.player = null");
            return null; // Or some default value or throw an exception
        }

        SimplePlayer localPlayer = ctx.players.getLocal();

        if (playerGameName == null) {
            playerGameName = localPlayer.getName();
        }

        return playerGameName;
    }

    private void writeTask (String response) {
        logger.info("GPT response: " + response);
        int randomSleep = randomSleeping(3600, 12000);
        logger.info("Sleeping for " + randomSleep + "ms");
        ctx.sleep(randomSleep);
        ctx.keyboard.sendKeys(response);
        messageSaved = null;
        messageToGPT = null;
    }

    public static int randomSleeping(int minimum, int maximum) {
        return ThreadLocalRandom.current().nextInt(minimum, maximum + 1);
    }

    public static void gptDeactivation() {
        botStarted = false;
        gptStarted = false;
        gptIsActive = false;
        messageSaved = null;
    }

    public static String getApiKey() {
        char[] apiKeyChars =
                (AutoFighterUI.apiKeyPasswordField != null && AutoFighterUI.apiKeyPasswordField.getPassword().length > 0)
                        ? AutoFighterUI.apiKeyPasswordField.getPassword()
                        : eAutoResponderGui.apiKeyPasswordField.getPassword();
        String apiKey = new String(apiKeyChars);
        Arrays.fill(apiKeyChars, ' ');
        return apiKey;
    }

    @Override
    public String status() {
        return "GPT processing dialogue";
    }
}

'''
'''--- src/eAutoFighterZenyte/AutoFighter.java ---
package eAutoFighterZenyte;

import BotUtils.*;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponser;
import eAutoFighterZenyte.data.eLoots;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.*;
import simple.hooks.queries.SimpleEntityQuery;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Game;
import simple.hooks.simplebot.Pathing;
import simple.hooks.wrappers.*;
import simple.robot.utils.WorldArea;

import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.*;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static eApiAccess.eAutoResponser.*;

@ScriptManifest(
        author = "Reminisce | Esmaabi",
        category = Category.COMBAT,
        description = "<html>"
                + "<p><strong>eAIO Fighter with GPT</strong>: Revolutionizing combat with AI-driven intelligence!</p>"
                + "<p><strong>Guidelines & Features:</strong></p>"
                + "<ul>"
                + "<li>Always start near the NPCs you intend to target.</li>"
                + "<li><strong>Equip your primary weapon first!</strong> This ensures the bot can correctly identify and use it along with your special attack weapon.</li>"
                + "<li>Set your desired HP threshold and food type for the bot to manage your health.</li>"
                + "<li>Choose between quick prayers or the advanced prayer flick options.</li>"
                + "<li>Define which prayer restoration potions to use and the bot will drink them as needed.</li>"
                + "<li>Specify the items you want to loot and looting range. The bot can also eat to make space for loot.</li>"
                + "<li>If you want to bury bones or ashes, add them to the drop list for smooth execution.</li>"
                + "<li>Click the Slayer icon (top-right corner) whenever you want an update on remaining Slayer kills.</li>"
                + "<li>Personalize your experience: save and load bot settings at will.</li>"
                + "<li>Engage in lifelike interactions with integrated GPT chatbot, bringing smart AI to your gameplay.</li>"
                + "</ul>"
                + "</html>",
        discord = "Reminisce#1707 | Esmaabi#5752",
        name = "eAIO Fighter with GPT",
        servers = {"Zenyte"},
        version = "3.5"
)

public class AutoFighter extends TaskScript implements LoopingScript, MouseListener {

    // Constants
    public static final Rectangle slayerImageRect = new Rectangle(735, 10, 20, 20);
    private final ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
    private static final Logger logger = Logger.getLogger(AutoFighter.class.getName());
    private static final int ENHANCED_GEM_ID = 4155;
    private static final int[] SPEC_WEAPON_IDS = {1215, 1231, 5680, 5698, 20407, 1434, 1377, 13271};
    private static final java.util.regex.Pattern SLAYER_HELMET_PATTERN = java.util.regex.Pattern.compile("^(?i)(Black|Green|Red|Purple|Turquoise|Hydra|Twisted|Tztok|Vampyric|Tzkal)?\\s?Slayer helmet(\\s\\(i\\))?$");

    public static final WorldArea HOME_AREA = new WorldArea(new WorldPoint(3110, 3474, 0), new WorldPoint(3074, 3516, 0));
    long previous = System.currentTimeMillis();

    // Variables
    private BufferedImage slayerImage;
    private BufferedImage slayerImageClicked;
    private SimpleNpc currentNpc = null;
    private boolean attackingAllowed;
    private boolean healingDone;
    private boolean slayerTaskDone;
    private boolean alreadyInCombat;
    private long startTime = 0L;
    private long startingSkillExp;
    private static int countNpc;
    private static int monsterCount = 0;
    public AutoFighterUI fighterGui;
    public String MAIN_WEAPON_NAME;
    public String SPEC_WEAPON_NAME;
    public boolean buryBones;
    public boolean eatForSpace;
    public boolean enableStatBoosting;
    public boolean bypassNpcReachable;
    public boolean prayFlick;
    public boolean quickPrayers;
    public boolean teleOnTaskFinish;
    public int eatHealth;
    public int lootWithin;
    public int[] foodId;
    public int[] lootNames;
    public int[] npcIds;
    public static SimplePrayers.Prayers CHOSEN_PRAYER_FLICK;
    public static SimpleSkills.Skills chosenSkillIndicator;
    public static String prayPotionName;
    public static String statsBoostingPotionName;
    public static boolean autoRetaliate;
    public static boolean autoRetaliateDefault;
    public static boolean checkSlayerKillCount;
    public static boolean hidePaint;
    public static boolean specialAttackTool;
    public boolean useMainWeaponAsSpec;
    public static int drinkStatBoostAt;
    static String status = null;

    private void initializeMethods() {
        eBanking bankingUtils = new eBanking(ctx);
        eActions actionUtils = new eActions(ctx);
        eData dataUtils = new eData(ctx);
        eImpCatcher impCatcher = new eImpCatcher(ctx);
        eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx), new eWildyTeleport(ctx), new eImpCatcher(ctx)));
        previous = 0;

        // Initialize GptGUI();
        initializeMethods();
        gptDeactivation();

        // Other vars
        ctx.log("--------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " ---------------");
        ctx.log("------------------------------------");
        ctx.log("             eAIO Fighter           ");
        ctx.log("------------------------------------");

        // Vars
        updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillExp = this.ctx.skills.totalExperience();
        ctx.viewport.pitch(true);
        slayerTaskDone = false;
        healingDone = false;
        countNpc = 0;
        attackingAllowed = true;

        // Auto Fighter Gui
        try {
            AutoFighter script = this;
            SwingUtilities.invokeLater(() -> fighterGui = new AutoFighterUI(script));
        } catch (Exception e) {
            logger.log(Level.SEVERE, "An error occurred while initializing AutoFighter GUI", e);
        }

        // Initialize Slayer image for kill-count
        try {
            slayerImage = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream("data/slayer.png")));
            slayerImageClicked = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream("data/slayerClicked.png")));
        } catch (IOException e) {
            logger.log(Level.SEVERE, "An error occurred while initializing Slayer image", e);
        }

        // Setting up special attack weapon switch
        setupSpecialAttackWeapon();

        // Counting killed NPCs
        executorService.scheduleAtFixedRate(this::monitorNpc, 0, 200, TimeUnit.MILLISECONDS);
    }

    @Override
    public void onProcess() {
        super.onProcess();

        final Pathing pathing = ctx.pathing;
        final SimplePlayer localPlayer = ctx.players.getLocal();

        try {

            if (!botStarted) {
                status = "Please start the bot!";
                return;
            }

            // Check if the player is in the home and healed
            if (pathing.inArea(HOME_AREA) && healingDone) {
                return;
            }

            // Handle eating
            handleEating();

            // Handle looting
            handleLooting();

            // Handle combat
            if (attackingAllowed) {
                if (!localPlayer.inCombat() || localPlayer.getInteracting() == null) { // Player not in combat

                    Optional<SimpleNpc> potentialNpc = findEngagedNpc();
                    if (!potentialNpc.isPresent()) {
                        potentialNpc = findNearestNpc();
                    }

                    if (!potentialNpc.isPresent()) {
                        return;
                    }

                    currentNpc = potentialNpc.get();
                    if (shouldSkipNpc(currentNpc)) {
                        status = currentNpc.getName() + " is not reachable.";
                        currentNpc = null;
                    }

                    // If NPC is not visible on the screen, move towards it
                    npcNotVisible(currentNpc);
                    healingDone = false;
                    status("Attacking " + currentNpc.getName());
                    BotUtils.eActions.interactWith(currentNpc, "Attack");
                    ctx.onCondition(() -> ctx.combat.inCombat() && localPlayer.getInteracting() == currentNpc.getNpc(), 250, 12);
                    return;

                } else if (alreadyInCombat) {
                    currentNpc = null;
                    ctx.combat.toggleAutoRetaliate(true);
                    alreadyInCombat = false;

                } else { // Player is in combat

                    // Quick prayers handling
                    if (quickPrayers) {
                        handleQuickPrayers();
                    }

                    // Prayer flick handling
                    if (prayFlick && !quickPrayers) {
                        handlePrayerFlick();
                    }

                    // Special attack handling
                    handleSpecialAttack();

                    // Handle bones in inventory
                    handleBuryingBones();

                    // Handle auto retaliate
                    handleAutoRetaliate();
                }
            }

            // Handle running
            BotUtils.eActions.handleRunning();

            if (checkSlayerKillCount) checkSlayerEquipment();

            // Handle stats boosting
            if (enableStatBoosting && ctx.skills.level(chosenSkillIndicator) < drinkStatBoostAt) drinkStatsBoostingPotion();

            // Handle teleporting to home after slayer task is finished
            handleTeleportAfterTask();

        } catch (
                Exception e) {
            logger.log(Level.SEVERE, "An error occurred during AutoFighter onProcess", e);
        }

    }

    private boolean teleportHome() {
        if (!playerAtHome()) {
            ctx.log("Not at home, attempting to teleport");
            status = "Teleporting to home";
            BotUtils.eActions.handleInventoryItem("Break", 22721);
            boolean teleported = ctx.onCondition(this::playerAtHome, 1000, 10);
            if (!teleported) {
                return false;
            }
        }
        status = "Restoring hitpoints";
        if (!ctx.prayers.quickPrayers()) {
            ctx.prayers.quickPrayers(true);
        }
        ctx.prayers.quickPrayers(false);

        if (slayerTaskDone) {
            updateStatus(BotUtils.eActions.getCurrentTimeFormatted() + " Slayer Task is Done");
            slayerTaskDone = false;
        }

        if (!healingDone) {
            SimpleObject healingBox = ctx.objects.populate().filter("Box of Restoration").nearest().next();

            if (healingBox != null && healingBox.validateInteractable()) {
                ctx.log("Found Box of Restoration, interacting with it");
                BotUtils.eActions.interactWith(healingBox, "Restore");
                ctx.onCondition(() -> ctx.players.getLocal().getGraphic() != 0, 250, 12);
            }
            healingDone = true;
            status = "Waiting at home...";
        }
        return true;
    }

    private boolean playerAtHome() {
        return ctx.pathing.inArea(HOME_AREA);
    }

    private void handleQuickPrayers() {
        if (ctx.prayers.points() > 20) {
            if (!ctx.prayers.quickPrayers()) {
                ctx.prayers.quickPrayers(true);
            }
        } else {
            drinkPrayerPotion();
        }

        if (prayFlick) {
            prayFlick = false;
        }
    }

    private void handlePrayerFlick() {
        if (CHOSEN_PRAYER_FLICK != null && ctx.prayers.points() > 0) {
            ctx.prayers.prayer(CHOSEN_PRAYER_FLICK, ctx.combat.inCombat() && !ctx.players.getLocal().isAnimating());
        }

        if (ctx.prayers.points() <= 20) {
            drinkPrayerPotion();
        }

        if (quickPrayers) {
            quickPrayers = false;
        }
    }

    private void drinkPrayerPotion() {
        final SimpleItem potionInventory = ctx.inventory.populate()
                .filter(item -> item != null && item.getName() != null && item.getName().startsWith(prayPotionName))
                .filterHasAction("Drink").next();

        final int cached = ctx.prayers.points();

        if (potionInventory == null) {
            ctx.log(prayPotionName + " not found.");
            ctx.log("Disabling prayers.");
            quickPrayers = false;
            prayFlick = false;
            return;
        }

        status = "Drinking " + prayPotionName;
        if (potionInventory.click("Drink")) {
            ctx.onCondition(() -> ctx.prayers.points() > cached, 250, 12);
        }
    }

    private void drinkStatsBoostingPotion() {

        final SimpleItem potionInventory = ctx.inventory.populate()
                .filter(item -> item != null && item.getName() != null && item.getName().startsWith(statsBoostingPotionName))
                .filterHasAction("Drink").next();

        final int cached = ctx.skills.level(chosenSkillIndicator);

        if (potionInventory == null) {
            ctx.log(statsBoostingPotionName + " not found.");
            ctx.log("Disabling stat-boosting.");
            enableStatBoosting = false;
            return;
        }

        status = "Drinking " + statsBoostingPotionName;
        if (potionInventory.click("Drink")) {
            ctx.onCondition(() -> ctx.skills.level(chosenSkillIndicator) > cached, 250, 12);
        }
    }

    private void eatFood() {
        if (foodId != null) {
            final SimpleItem food = ctx.inventory.populate().filter(foodId).next();
            if (food != null) {
                final int cached = ctx.inventory.getFreeSlots();
                status("Eating " + food.getName().toLowerCase());
                food.click("Eat");
                ctx.onCondition(() -> ctx.inventory.getFreeSlots() > cached, 250, 9);
            }
        }
    }

    private void handleEating() {
        if (ctx.combat.health() < eatHealth && foodId != null) {
            if (!ctx.inventory.populate().filter(foodId).isEmpty()) {
                eatFood();
            } else {
                ctx.log("Out of food!");
                teleportHome();
            }
        }
    }

    private void handleBuryingBones() {
        if (!buryBones) return;

        if (!BotUtils.eActions.hasItemsInInventory(eActions.StackableType.NON_STACKABLE, eLoots.BONES_TO_BURY)) return;
        updateStatus("Burying bones...");
        BotUtils.eActions.handleInventoryItem("Bury", eLoots.BONES_TO_BURY);
    }

    private void handleLooting() {
        if (lootNames == null || lootNames.length == 0) {
            attackingAllowed = true;
            return;
        }

        SimpleGroundItem item = ground().nearest().next();

        if (item == null) {
            return;
        }

        boolean smallCoinsStackFound = item.getId() == 995 && item.getQuantity() < 30000;
        if (smallCoinsStackFound) {
            return;
        }

        int freeSlots = ctx.inventory.getFreeSlots();

        if (freeSlots <= 0) {

            if (eatForSpace && foodId != null && !ctx.inventory.populate().filter(foodId).isEmpty()) {
                eatFood();
                freeSlots = ctx.inventory.getFreeSlots();

                if (freeSlots <= 0) {
                    return;
                }
            }
        }

        attackingAllowed = false;

        if (!item.visibleOnScreen()) {
            ctx.pathing.step(item.getLocation());
            ctx.onCondition(item::visibleOnScreen, 200, 6);
        }

        BotUtils.eActions.interactWith(item, "Take");
        ctx.onCondition(() -> ground().filter(item).isEmpty(), 200, 6);

        attackingAllowed = true;
    }

    public final SimpleEntityQuery<SimpleNpc> npcs() {
        return ctx.npcs.populate()
                .filter(npcIds)
                .filter(this::isValidNpc);
    }

    private boolean isValidNpc(SimpleNpc n) {
        if (n == null) return false;
        if (isUndesiredNpc(n)) return false;
        if (isTooFarFromPlayer(n)) return false;
        if (isEngagedWithOther(n)) return false;
        return !n.isDead();
    }

    private boolean isUndesiredNpc(SimpleNpc n) {
        return n.getId() == 10; // Death spawn
    }

    private boolean isTooFarFromPlayer(SimpleNpc n) {
        return n.getLocation().distanceTo(BotUtils.eActions.getPlayerLocation()) > 15;
    }

    private boolean isEngagedWithOther(SimpleNpc n) {
        return n.inCombat() && n.getInteracting() != null && !n.getInteracting().getName().equals(BotUtils.eActions.getPlayerName());
    }

    private Optional<SimpleNpc> findEngagedNpc() {
        return Optional.ofNullable(npcs().filter((n) ->
                n.getInteracting() != null &&
                        n.getInteracting().getName().equals(BotUtils.eActions.getPlayerName()) &&
                        n.inCombat()
        ).nearest().next());
    }

    private Optional<SimpleNpc> findNearestNpc() {
        return Optional.ofNullable(npcs().nearest().next());
    }

    private boolean shouldSkipNpc(SimpleNpc npc) {
        return !bypassNpcReachable && !ctx.pathing.reachable(npc.getLocation());
    }

    private void npcNotVisible(SimpleNpc npc) {
        if (!bypassNpcReachable && !npc.visibleOnScreen()) {
            ctx.pathing.step(npc.getLocation());
            ctx.onCondition(npc::visibleOnScreen, 250, 12);
        }
    }

    public final SimpleEntityQuery<SimpleGroundItem> ground() {
        return ctx.groundItems.populate()
                .filter(Objects::nonNull)
                .filter(t -> t.getLocation().distanceTo(BotUtils.eActions.getPlayerLocation()) <= lootWithin)
                .filter(lootNames)
                .filter(ctx.pathing::reachable);
    }

    private void setupSpecialAttackWeapon() {
        SimpleItem mainWeapon = ctx.equipment.getEquippedItem(SimpleEquipment.EquipmentSlot.WEAPON);
        SimpleItem specWeapon = ctx.inventory.populate().filter(SPEC_WEAPON_IDS).filterHasAction("Wield").next();

        MAIN_WEAPON_NAME = getNameSafe(mainWeapon);
        if (useMainWeaponAsSpec) {
            SPEC_WEAPON_NAME = MAIN_WEAPON_NAME;  // Use main weapon as special weapon
        } else {
            SPEC_WEAPON_NAME = getNameSafe(specWeapon);
        }

        if (!checkWeapon(MAIN_WEAPON_NAME, "Main")) {
            return;
        }

        checkWeapon(SPEC_WEAPON_NAME, "Special");
    }

    private String getNameSafe(SimpleItem item) {
        return item == null ? null : item.getName();
    }

    private boolean checkWeapon(String weaponName, String weaponType) {
        if (weaponName == null || weaponName.isEmpty()) {
            ctx.log(weaponType + " weapon is missing.");
            return false;
        }

        ctx.log(weaponType + " weapon: " + weaponName);
        return true;
    }

    private void wieldWeaponFromInventory(String weaponName) {
        SimpleItem weapon = ctx.inventory.populate().filter(weaponName).filterHasAction("Wield", "Wear").next();
        if (weapon != null && weapon.click(0)) {
            updateStatus("Wielding " + weapon.getName());
            ctx.onCondition(() -> false, 250, 12);
        }
    }

    private void useSpecialAttack() {
        status = "Using special attack";
        int specLeft = ctx.combat.getSpecialAttackPercentage();
        ctx.combat.toggleSpecialAttack(true);
        ctx.onCondition(() -> ctx.combat.getSpecialAttackPercentage() < specLeft, 250, 4);
    }

    public void handleSpecialAttack() {
        int specPercentage = ctx.combat.getSpecialAttackPercentage();
        boolean mainWeaponEquipped = isWeaponEquipped(MAIN_WEAPON_NAME);
        boolean specWeaponEquipped = isWeaponEquipped(SPEC_WEAPON_NAME);
        boolean shouldSwitchForSpecial = shouldSwitchForSpecialAttack();

        if (useMainWeaponAsSpec && mainWeaponEquipped && specPercentage == 100) {
            useSpecialAttack();
        } else {
            if (specPercentage == 100 && mainWeaponEquipped && shouldSwitchForSpecial) {
                wieldWeaponFromInventory(SPEC_WEAPON_NAME);
            }

            if (specPercentage >= 25 && specWeaponEquipped) {
                useSpecialAttack();
            }

            if (specPercentage < 25 && specWeaponEquipped) {
                wieldWeaponFromInventory(MAIN_WEAPON_NAME);
            }
        }
    }

    private boolean isWeaponEquipped(String weaponName) {
        return !ctx.equipment.populate().filter(weaponName).isEmpty();
    }

    private boolean shouldSwitchForSpecialAttack() {
        return !useMainWeaponAsSpec && !ctx.inventory.populate().filter(SPEC_WEAPON_NAME).isEmpty();
    }

    private void handleAutoRetaliate() {
        if (!autoRetaliateDefault) {
            ctx.combat.toggleAutoRetaliate(autoRetaliate);
        }
    }

    private void handleTeleportAfterTask() {
        if (teleOnTaskFinish && slayerTaskDone) {
            if (teleportHome()) {
                ctx.onCondition(() -> true, 250, 12);
            }
        }
    }

    public void setupEating(int[] foodId, int eatAt) {
        this.foodId = foodId;
        this.eatHealth = eatAt;
    }

    public void setupLooting(int[] lootNames, int lootWithin) {
        this.lootNames = lootNames;
        this.lootWithin = lootWithin;
    }

    public void setLootNames(int[] newLootNames) {
        this.lootNames = newLootNames;
    }

    public void setupAttacking(int[] npcIds) {
        this.npcIds = npcIds;
    }

    private void checkSlayerEquipment() {
        ctx.game.tab(Game.Tab.EQUIPMENT);

        SimpleItem slayerHelmet = ctx.equipment.populate().filter(SLAYER_HELMET_PATTERN).filterHasAction("Check").next();

        if (slayerHelmet != null) {
            status("Clicking " + slayerHelmet.getName().toLowerCase());
            slayerHelmet.click("Check");
        } else {
            SimpleItem slayerHelmetInv = ctx.inventory.populate().filter(SLAYER_HELMET_PATTERN).filterHasAction("Check").next();

            if (slayerHelmetInv != null) {
                status("Clicking " + slayerHelmetInv.getName().toLowerCase());
                slayerHelmetInv.click("Check");
            } else {
                SimpleItem enhancedGem = ctx.inventory.populate().filter(ENHANCED_GEM_ID).next();

                if (enhancedGem != null) {
                    status("Clicking " + enhancedGem.getName().toLowerCase());
                    enhancedGem.click("Check");
                } else {
                    checkSlayerKillCount = false;
                    updateStatus("Cannot check the slayer kill-count");
                    updateStatus("Slayer helmet / enchanted gem is missing!");
                }
            }
        }

        ctx.game.tab(Game.Tab.INVENTORY);
    }

    private void status(String status) {
        AutoFighter.status = status;
    }
    private void updateStatus(String newStatus) {
        status = newStatus;
        ctx.log(status);
    }

    private void monitorNpc() {
        if (currentNpc != null) {
            synchronized(this) {
                if (currentNpc.isDead() || currentNpc.getHealthRatio() == 0) {
                    countNpc++;
                    if (monsterCount != 0) monsterCount--;
                    currentNpc = null;
                }
            }
        }
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");
        ctx.log("Monsters killed: " + countNpc);

        // Other variables
        this.startingSkillExp = 0L;
        specialAttackTool = false;
        gptDeactivation();

        if (fighterGui != null) {
            fighterGui.closeGui();
        }
        executorService.shutdown();
    }

    @Override
    public void onChatMessage(ChatMessage m) {

        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        if (gptStarted && botStarted) eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        eTriviaInfo.handleBroadcastMessage(getType, gameMessage);

        if (getType == ChatMessageType.GAMEMESSAGE) {
            String gameMessageTrimmed = gameMessage.replaceAll("<[^>]+>", "").trim();
            if (gameMessageTrimmed.contains("return to a Slayer master")) {
                slayerTaskDone = true;
                monsterCount = 0;
            }

            if (gameMessageTrimmed.contains("are already in combat")) {
                ctx.log("In combat, attacking next NPC");
                alreadyInCombat = true;
            }

            Pattern pattern = Pattern.compile("You're assigned to kill ([^;]+); only (\\d+) more to go.");
            Matcher matcher = pattern.matcher(gameMessageTrimmed);
            if (matcher.find()) {
                String monsterName = matcher.group(1);
                monsterCount = Integer.parseInt(matcher.group(2));

                ctx.log("You still have to kill " + monsterCount + " " + monsterName);
                checkSlayerKillCount = false;
            }

            if (gameMessageTrimmed.contains("need something new to hunt")) {
                ctx.log("You need something new to hunt!");
                monsterCount = 0;
                checkSlayerKillCount = false;
            }
        }
    }

    @Override
    public void paint(Graphics g) {

        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillExp = this.ctx.skills.totalExperience();
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long killsPerHour = ctx.paint.valuePerHour(countNpc, startTime);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 205, 80, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 205, 80, 20, 20);

            g.setColor(philippineRed);
            g.drawString("eAIO Fighter with GPT", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 165);
            g.drawString("Monsters killed: " + countNpc + " (" + killsPerHour + " per/h)", 15, 180);
            g.drawString("Status: " + status, 15, 195);

        }

        // Paint
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 80);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Slayer icon setup
        if (slayerImage != null) {
            BufferedImage imageToDraw = (checkSlayerKillCount && slayerImageClicked != null) ? slayerImageClicked : slayerImage;
            g.drawImage(imageToDraw, 735, 10, 18, 20, null);
        }

        if (monsterCount != 0) {
            g.setColor(Color.white);
            g.setFont(new Font("Verdana", Font.BOLD, 8));
            int computedX = computeXForMonsterCount(monsterCount);
            g.drawString(String.valueOf(monsterCount), computedX, 39);
        }
    }

    private int computeXForMonsterCount(int monsterCount) {
        int baseX = 740; // for 1 digit kill-count
        int numberOfDigits = (int) Math.log10(monsterCount) + 1; // find out how many digits kill-count

        switch (numberOfDigits) {
            case 2:
                return baseX - 2; // subtract for 2 digits kill-count
            case 3:
                return baseX - 5; // subtract for 3 digits kill-count
            default:
                return baseX;
        }
    }

    @Override
    public int loopDuration() {
        return 300;
    }

    @Override
    public void mouseClicked(MouseEvent e) {
        if (slayerImageRect.contains(e.getPoint())) {
            checkSlayerKillCount = true;
        }
    }

    @Override
    public void mousePressed(MouseEvent e) {

    }

    @Override
    public void mouseReleased(MouseEvent e) {

    }

    @Override
    public void mouseEntered(MouseEvent e) {

    }

    @Override
    public void mouseExited(MouseEvent e) {

    }

}
'''
'''--- src/eAutoFighterZenyte/AutoFighterUI.java ---
package eAutoFighterZenyte;

import eApiAccess.eAutoResponser;
import eAutoFighterZenyte.data.eFood;
import eAutoFighterZenyte.data.eLoots;
import org.json.JSONArray;
import org.json.JSONObject;
import simple.hooks.filters.SimplePrayers;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.wrappers.SimpleNpc;
import net.runelite.api.ItemComposition;
import simple.robot.api.ClientContext;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.spec.KeySpec;
import java.util.*;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.swing.*;
import javax.swing.border.EmptyBorder;

public class AutoFighterUI extends Component {

    // Constants
    public static final String[] ACTIVITY = {"Slayer", "PVM", "Chilling", "Skilling", "Money making"};
    public static final String[] AUTO_RETALIATE_OPTIONS = {"Default", "Force ON", "Force OFF"};
    public static final String[] PRAYER_RESTOR = {"Prayer potion", "Super restore", "Sanfew serum"};
    public static final String[] PRAYER_FLICK = {
            "Piety (lvl 70)", "Rigour (lvl 74)", "Augury (lvl 77)", "Chivalry (lvl 60)", "Mystic Might (lvl 45)", "Eagle Eye (lvl 44)",
            "Ultimate Strength (lvl 31)", "Mystic Lore (lvl 27)", "Hawk Eye (lvl 26)", "Superhuman Strength (lvl 13)",
            "Mystic Will (lvl 9)", "Sharp Eye (lvl 8)", "Burst of Strength (lvl 4)"
    };
    public static final String[] SKILL_NAMES = {"Attack", "Strength", "Defence", "Ranged", "Magic"};
    public static final String[] STATS_BOOST = {
            "None", "Divine super combat potion", "Divine ranging potion", "Divine bastion potion",
            "Divine super attack potion", "Divine super strength potion", "Divine super defence potion", "Divine magic potion",
            "Super combat potion", "Super strength", "Super attack", "Super defence", "Ranging potion", "Bastion potion", "Magic potion"
    };
    private static final Logger logger = Logger.getLogger(AutoFighterUI.class.getName());

    /// Auto Fighter related

    // Variables
    public AutoFighter combat;
    public JButton btnApplyAndStart;
    public JButton btnPauseBot;
    public JComboBox<eFood> comboBoxFoods;
    public JComboBox<String> selectAutoRetaliateComboBox;
    public JComboBox<String> selectPrayerRestoreComboBox;
    public JComboBox<String> selectPrayerFlickComboBox;
    public JComboBox<String> selectSkillToBoostComboBox;
    public JComboBox<String> selectStatsBoostComboBox;
    public JCheckBox chbxuseBuryBones;
    public JCheckBox chkxdrinkStatsBoost;
    public JCheckBox chbxnpcReachable;
    public JCheckBox chbxMainAsSpecWeap;
    public JCheckBox chbxQuickPrayers;
    public JCheckBox chbxuseMouseActions;
    public JList<String> listLoot;
    public JList<String> listNearbyMonsters;
    public JList<String> listSelectedMonsters;
    public JPanel contentPane;
    public JPanel extrasPanel;
    public JPanel generalPanel;
    public JScrollPane scrollPaneLoot;
    public JScrollPane scrollPaneNearbyMonsters;
    public JScrollPane scrollPaneSelectedMonsters;
    public JSpinner lootWithin;
    public JSpinner spinnerBoostStatsAt;
    public JSpinner spinnerHealAt;
    public DefaultListModel<String> modelLoot = new DefaultListModel<String>();
    public DefaultListModel<String> modelNearbyMonsters = new DefaultListModel<String>();
    public DefaultListModel<String> modelSelectedMonsters = new DefaultListModel<String>();
    public JFrame theGui;
    public JLabel lblMonsterList;
    private JButton btnClearLoots;
    private JButton btnLoadJson;
    private JButton btnSaveJson;
    private JCheckBox chckbxEatforSpace;
    private JCheckBox chckbxPrayFlick;
    private JCheckBox chckbxTeleAfterTask;
    private ClientContext ctx;

    /// GPT related

    // Encryption
    private static final String ENCRYPTION_ALGO = "AES/CBC/PKCS5Padding";
    private static final String SECRET_KEY_ALGO = "PBKDF2WithHmacSHA256";
    private static final String SALT = "aRandomSaltForPBE"; // Change this to a long random string!
    private static final int ITERATION_COUNT = 65536;
    private static final int KEY_LENGTH = 256;
    JPasswordField passphraseField = new JPasswordField();

    // Constants
    private static final String API_KEY_FILE_PATH = "esmaabi_gpt_api_key_data.enc";
    public static final String[] GPT_MODELS = {"GPT 3.5 Turbo", "GPT 4"};

    // Variables
    public static boolean gptHasBeenStarted = false;
    public static JPasswordField apiKeyPasswordField;
    public JPanel gptPanel;
    public JCheckBox activateChatGPT;
    public JCheckBox gptActiveAtHome;
    public JCheckBox properGrammar;
    private JButton loadButton;
    private JButton saveButton;
    private JComboBox<String> chatActivityComboBox;
    private JComboBox<String> selectGptModelComboBox;

    public AutoFighterUI(AutoFighter combatBot) {
        try {
            this.combat = combatBot;
            SwingUtilities.invokeLater(this::initializeGUI);
        } catch (Exception e) {
            logger.info("An exception occurred while running AutoFighterUI " + e);
        }
    }

    private void initializeGUI() {
        // Initialize the main JFrame
        theGui = new JFrame();
        theGui.setResizable(false);
        theGui.setTitle("eAIO Fighter with GPT integration");
        theGui.setBounds(100, 100, 450, 490);
        theGui.setIconImage(new ImageIcon(Objects.requireNonNull(getClass().getResource("data/esmaabi-icon.png"))).getImage());
        theGui.setLocationRelativeTo(combat.ctx.mouse.getComponent());

        // Set content pane properties
        contentPane = new JPanel();
        contentPane.setBorder(new EmptyBorder(5, 5, 5, 5));
        theGui.setContentPane(contentPane);
        contentPane.setLayout(null);

        // Initialize components and setup
        initComponents();
        setupDropArray();
        onRefreshNearbyMonsters();
        pauseBot();

        // Display the GUI
        theGui.repaint();
        theGui.setVisible(true);
    }

    public void initComponents() {

        JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
        tabbedPane.setBounds(10, 11, 414, 369);
        contentPane.add(tabbedPane);

        //// General Settings tab
        generalPanel = new JPanel();
        generalPanel.setName("");
        tabbedPane.addTab("General", null, generalPanel, null);
        generalPanel.setLayout(null);

        // Choosing food
        JLabel lblFoodType = new JLabel("Choose food:");
        lblFoodType.setBounds(10, 11, 80, 20);
        generalPanel.add(lblFoodType);

        comboBoxFoods = new JComboBox<eFood>(new DefaultComboBoxModel<eFood>(eFood.values()));
        comboBoxFoods.setBounds(95, 9, 110, 23);
        comboBoxFoods.setBackground(Color.GRAY);
        comboBoxFoods.setRenderer(new DefaultListCellRenderer() {
            @Override
            public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
                super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);

                if (value instanceof eFood) {
                    setText(((eFood) value).getName());
                }

                return this;
            }
        });
        generalPanel.add(comboBoxFoods);

        // Choosing heal HP
        JLabel lblHealAt = new JLabel("HP to heal:");
        lblHealAt.setBounds(213, 11, 62, 19);
        generalPanel.add(lblHealAt);

        spinnerHealAt = new JSpinner();
        spinnerHealAt.setModel(new SpinnerNumberModel(55, 1, 99, 1));
        spinnerHealAt.setBounds(285, 9, 50, 23);
        generalPanel.add(spinnerHealAt);

        // Label NPC(s) nearby
        JLabel lblNearbyMonsters = new JLabel("Nearby NPC(s)");
        lblNearbyMonsters.setBounds(20, 44, 96, 19);
        generalPanel.add(lblNearbyMonsters);

        // Refresh NPC button

        JButton btnRefreshNearbyMonsters = new JButton("Refresh");
        btnRefreshNearbyMonsters.setToolTipText("Refresh NPC list below");
        btnRefreshNearbyMonsters.setBounds(115, 40, 80, 23);
        generalPanel.add(btnRefreshNearbyMonsters);
        btnRefreshNearbyMonsters.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                SwingUtilities.invokeLater(new Runnable() {

                    @Override
                    public void run() {
                        onRefreshNearbyMonsters();
                    }
                });
            }
        });

        // Nearby NPC list Pane
        scrollPaneNearbyMonsters = new JScrollPane();
        scrollPaneNearbyMonsters.setBounds(10, 74, 187, 124);
        generalPanel.add(scrollPaneNearbyMonsters);
        listNearbyMonsters = new JList<String>(modelNearbyMonsters);
        scrollPaneNearbyMonsters.setViewportView(listNearbyMonsters);
        listNearbyMonsters.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (listNearbyMonsters.getSelectedIndex() == listNearbyMonsters.locationToIndex(e.getPoint()) && e.getClickCount() >= 2) {
                    String element = listNearbyMonsters.getSelectedValue();
                    modelNearbyMonsters.removeElement(element);
                    modelSelectedMonsters.addElement(element);
                }
            }
        });

        // Selected NPCs text
        lblMonsterList = new JLabel("Selected NPC(s) list");
        lblMonsterList.setBounds(213, 44, 119, 23);
        generalPanel.add(lblMonsterList);

        // Selected NPC scroll Panel
        listSelectedMonsters = new JList<String>(modelSelectedMonsters);
        listSelectedMonsters.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (listSelectedMonsters.getSelectedIndex() == listSelectedMonsters.locationToIndex(e.getPoint()) && e.getClickCount() >= 2) {
                    String element = listSelectedMonsters.getSelectedValue();
                    modelSelectedMonsters.removeElement(element);
                }
            }
        });
        listSelectedMonsters.setBounds(193, 145, 206, 185);

        scrollPaneSelectedMonsters = new JScrollPane();
        scrollPaneSelectedMonsters.setBounds(207, 74, 192, 124);
        generalPanel.add(scrollPaneSelectedMonsters);
        scrollPaneSelectedMonsters.setViewportView(listSelectedMonsters);

        // Items to loot button
        JLabel lblItemsToLoot = new JLabel("Items To Loot");
        lblItemsToLoot.setBounds(20, 204, 135, 23);
        generalPanel.add(lblItemsToLoot);

        // Loot scroll panel
        scrollPaneLoot = new JScrollPane();
        scrollPaneLoot.setBounds(10, 223, 187, 107);
        generalPanel.add(scrollPaneLoot);

        listLoot = new JList<String>(modelLoot);
        scrollPaneLoot.setViewportView(listLoot);

        // Add loot button
        JButton btnAddLoot = new JButton("+");
        btnAddLoot.setBackground(new Color(50, 205, 50));
        btnAddLoot.setToolTipText("Add the ID of item to pickup");
        btnAddLoot.setBounds(210, 231, 59, 23);
        generalPanel.add(btnAddLoot);
        btnAddLoot.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.out.println("After adding: " + modelLoot.getSize());
                String input = JOptionPane.showInputDialog("Enter item ID");
                if (input.contains(",")) {
                    String[] items = input.trim().split(",");
                    for (String id : items) {
                        ItemComposition itemDefinitions = combat.ctx.definitions.getItemDefinition(Integer.parseInt(id));
                        if (itemDefinitions != null) {
                            modelLoot.addElement("[" + itemDefinitions.getName() + ", " + itemDefinitions.getId() + "]");
                        }
                    }
                } else {
                    ItemComposition itemDefinitions = combat.ctx.definitions.getItemDefinition(Integer.parseInt(input));
                    if (itemDefinitions != null) {
                        modelLoot.addElement("[" + itemDefinitions.getName() + ", " + itemDefinitions.getId() + "]");
                    }
                }
                scrollPaneLoot.revalidate();
                scrollPaneLoot.repaint();
                System.out.println("After adding: " + modelLoot.getSize());
            }
        });

        // Remove loot button
        JButton btnRemoveLoot = new JButton("-");
        btnRemoveLoot.setBackground(new Color(190, 36, 36));
        btnRemoveLoot.setToolTipText("First click the item on the 's' list and then remove it");
        btnRemoveLoot.setBounds(210, 265, 59, 23);
        generalPanel.add(btnRemoveLoot);
        btnRemoveLoot.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.out.println("Before removing: " + modelLoot.getSize());
                modelLoot.removeElement(listLoot.getSelectedValue());
                scrollPaneLoot.revalidate();
                scrollPaneLoot.repaint();
                System.out.println("After removing: " + modelLoot.getSize());
            }
        });

        // Clear loots button
        btnClearLoots = new JButton("Clear");
        btnClearLoots.setToolTipText("Will clear whole 'Items to Loot' list");
        btnClearLoots.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent arg0) {
                System.out.println("Before clearing: " + modelLoot.getSize());
                modelLoot.clear();
                scrollPaneLoot.revalidate();
                scrollPaneLoot.repaint();
                System.out.println("After clearing: " + modelLoot.getSize());
            }
        });
        btnClearLoots.setBounds(210, 296, 59, 23);
        generalPanel.add(btnClearLoots);

        // Teleport if slayer task is finished
        chckbxTeleAfterTask = new JCheckBox("Tele after Task");
        chckbxTeleAfterTask.setToolTipText("Will teleport home using Zenyte tab after Slayer task done");
        chckbxTeleAfterTask.setBounds(275, 215, 135, 23);
        generalPanel.add(chckbxTeleAfterTask);

        // Eat for space button
        chckbxEatforSpace = new JCheckBox("Eat for Space");
        chckbxEatforSpace.setToolTipText("Will eat if inventory is full and valuable drop appears");
        chckbxEatforSpace.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                combat.eatForSpace = chckbxEatforSpace.isSelected();
            }
        });
        chckbxEatforSpace.setBounds(275, 245, 135, 23);
        generalPanel.add(chckbxEatforSpace);

        // Quick prayer button
        chbxQuickPrayers = new JCheckBox("Quick pray");
        chbxQuickPrayers.setToolTipText("Drinks prayer potions in inventory and enables quick prayers");
        chbxQuickPrayers.setBounds(275, 275, 135, 23);
        generalPanel.add(chbxQuickPrayers);

        // Player flick button
        chckbxPrayFlick = new JCheckBox("Pray flick");
        chckbxPrayFlick.setToolTipText("Will flick chosen prayer from \"Extras\" tab and drink prayer potions");
        chckbxPrayFlick.setBounds(275, 305, 135, 23);
        generalPanel.add(chckbxPrayFlick);

        //// GPT Settings tab
        gptPanel = new JPanel();
        gptPanel.setName("");
        tabbedPane.addTab("GPT settings", null, gptPanel, null);
        gptPanel.setLayout(null);

        // Information
        JLabel lblGptInfo = new JLabel("To use automatic GPT answering please enter your API key.");
        lblGptInfo.setBounds(60, 10, 390, 23);
        gptPanel.add(lblGptInfo);
        JLabel lblGptInfo2 = new JLabel("Get the API key from https://platform.openai.com/account/api-keys");
        lblGptInfo2.setBounds(10, 30, 390, 23);
        gptPanel.add(lblGptInfo2);

        // Activate ChatGPT checkbox
        activateChatGPT = new JCheckBox("Activate ChatGPT");
        activateChatGPT.setToolTipText("Enable or disable ChatGPT answering");
        activateChatGPT.setBounds(125, 64, 150, 23);
        gptPanel.add(activateChatGPT);
        gptPanel.add(activateChatGPT);

        // GPT models
        selectGptModelComboBox = new JComboBox<>(GPT_MODELS);
        selectGptModelComboBox.setBounds(213, 94, 150, 23);
        gptPanel.add(selectGptModelComboBox);
        selectGptModelComboBox.setToolTipText("What GPT model you'd like to use?");
        JLabel lblGptModel = new JLabel("Select GPT model:");
        lblGptModel.setBounds(65, 94, 109, 23);
        gptPanel.add(lblGptModel);

        // Activity type
        chatActivityComboBox = new JComboBox<>(ACTIVITY);
        chatActivityComboBox.setBounds(213, 124, 150, 23);
        gptPanel.add(chatActivityComboBox);
        chatActivityComboBox.setToolTipText("Choose what you want the bot to answer");
        JLabel lblChooseActivity = new JLabel("Select activity:");
        lblChooseActivity.setBounds(65, 124, 109, 23);
        gptPanel.add(lblChooseActivity);

        // GPT active at home
        gptActiveAtHome = new JCheckBox("GPT active at home area?");
        gptActiveAtHome.setToolTipText("Click if GPT must be active at home area");
        gptActiveAtHome.setBounds(125, 154, 200, 23);
        gptPanel.add(gptActiveAtHome);

        // Grammar checkbox
        properGrammar = new JCheckBox("Use proper grammar?");
        properGrammar.setToolTipText("Click if you don't want to use abbreviations, etc");
        properGrammar.setBounds(125, 184, 200, 23);
        gptPanel.add(properGrammar);

        // API Key
        JLabel lblApiKey = new JLabel("Insert API key: ");
        lblApiKey.setBounds(65, 246, 109, 23);
        apiKeyPasswordField = new JPasswordField();
        apiKeyPasswordField.setPreferredSize(new Dimension(150, apiKeyPasswordField.getPreferredSize().height));
        apiKeyPasswordField.setBounds(213, 246, 150, 23);
        apiKeyPasswordField.setEchoChar('\u2022'); // Set the echo character as a dot or asterisk
        apiKeyPasswordField.setToolTipText("Supported: GPT 3.5-turbo & GPT 4"); // Set the tooltip text for the API key field
        gptPanel.add(lblApiKey);
        gptPanel.add(apiKeyPasswordField);

        // Save Button
        saveButton = new JButton("Save");
        saveButton.setBounds(95, 280, 100, 23);
        gptPanel.add(saveButton);
        saveButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                saveApiKeyToFile(true);
            }
        });
        saveButton.setToolTipText("Save the API key to a file"); // Set the tooltip text for the Save button

        // Load Button
        loadButton = new JButton("Load");
        loadButton.setBounds(213, 280, 100, 23);
        gptPanel.add(loadButton);
        loadButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                loadApiKeyFromFile(true);
            }
        });
        loadButton.setToolTipText("Load the API key from a file"); // Set the tooltip text for the Load button

        //// Extras tab
        extrasPanel = new JPanel();
        extrasPanel.setName("");
        tabbedPane.addTab("Extras", null, extrasPanel, null);
        extrasPanel.setLayout(null);

        // Information
        JLabel lblExtrasInfo = new JLabel("Extra settings are here to really enhance your experience.");
        lblExtrasInfo.setBounds(40, 10, 390, 23);
        extrasPanel.add(lblExtrasInfo);

        // Prayer potions
        selectPrayerFlickComboBox = new JComboBox<>(PRAYER_FLICK);
        selectPrayerFlickComboBox.setBounds(195, 44, 190, 23);  // +40
        extrasPanel.add(selectPrayerFlickComboBox);
        selectPrayerFlickComboBox.setToolTipText("If prayer flick is activated choose which player to flick.");
        JLabel lblPrayerPotions = new JLabel("Select prayer to flick:");
        lblPrayerPotions.setBounds(30, 44, 150, 23);  // +40
        extrasPanel.add(lblPrayerPotions);

        // Choosing looting distance
        JLabel lblLootIn = new JLabel("Loot within distance:");
        lblLootIn.setBounds(30, 84, 150, 23);  // +40
        extrasPanel.add(lblLootIn);

        lootWithin = new JSpinner();
        lootWithin.setModel(new SpinnerNumberModel(10, 1, 25, 1));
        lootWithin.setBounds(195, 84, 50, 23);  // +40
        extrasPanel.add(lootWithin);

        // Prayer potions
        selectPrayerRestoreComboBox = new JComboBox<>(PRAYER_RESTOR);
        selectPrayerRestoreComboBox.setBounds(195, 124, 190, 23);  // +40
        extrasPanel.add(selectPrayerRestoreComboBox);
        selectPrayerRestoreComboBox.setToolTipText("What prayer restoration potions you'd like to use?");
        JLabel lblPrayerFlick = new JLabel("Select prayer potion:");
        lblPrayerFlick.setBounds(30, 124, 150, 23);  // +40
        extrasPanel.add(lblPrayerFlick);

        // Activate stat-boosting potion drinking checkbox
        chkxdrinkStatsBoost = new JCheckBox("Activate stats-boosting with potion");
        chkxdrinkStatsBoost.setToolTipText("Check if you want to drink stat-boosting potions");
        chkxdrinkStatsBoost.setBounds(100, 164, 250, 23);  // +40
        extrasPanel.add(chkxdrinkStatsBoost);

        // Stat-boosting potions
        selectStatsBoostComboBox = new JComboBox<>(STATS_BOOST);
        selectStatsBoostComboBox.setBounds(195, 194, 190, 23);  // +40
        extrasPanel.add(selectStatsBoostComboBox);
        selectStatsBoostComboBox.setToolTipText("What stat-boosting potion you'd like to use?");
        JLabel lblStatsPotions = new JLabel("Boost stats with:");
        lblStatsPotions.setBounds(30, 194, 150, 23);  // +40
        extrasPanel.add(lblStatsPotions);

        // Boosting skill indicator
        selectSkillToBoostComboBox = new JComboBox<>(SKILL_NAMES);
        selectSkillToBoostComboBox.setBounds(120, 224, 90, 23);  // +40
        extrasPanel.add(selectSkillToBoostComboBox);
        selectSkillToBoostComboBox.setToolTipText("Select skill which will indicate when to drink chosen stat-boosting potion.");
        JLabel lblStatsBoostIntro = new JLabel("Boost stats if");
        lblStatsBoostIntro.setBounds(30, 224, 90, 23);  // +40
        extrasPanel.add(lblStatsBoostIntro);

        // Choosing level to boost stats
        JLabel lblBoostStatsAt = new JLabel("level is lower than");
        lblBoostStatsAt.setBounds(220, 224, 120, 23);  // +40
        extrasPanel.add(lblBoostStatsAt);
        spinnerBoostStatsAt = new JSpinner();
        spinnerBoostStatsAt.setModel(new SpinnerNumberModel(110, 1, 115, 10));
        spinnerBoostStatsAt.setBounds(330, 224, 55, 23);  // +40
        extrasPanel.add(spinnerBoostStatsAt);

        // Auto retaliate options
        selectAutoRetaliateComboBox = new JComboBox<>(AUTO_RETALIATE_OPTIONS);
        selectAutoRetaliateComboBox.setBounds(195, 264, 190, 23);  // +40
        extrasPanel.add(selectAutoRetaliateComboBox);
        selectAutoRetaliateComboBox.setToolTipText("Set auto retaliate value. Default = automatic.");
        JLabel lblAutoRetaliate = new JLabel("Auto retaliate value:");
        lblAutoRetaliate.setBounds(30, 264, 150, 23);  // +40
        extrasPanel.add(lblAutoRetaliate);

        // Activate menu actions
        chbxuseMouseActions = new JCheckBox("Interact with mouse");
        chbxuseMouseActions.setToolTipText("Selecting will use mouse clicking instead of menu actions.");
        chbxuseMouseActions.setBounds(30, 294, 150, 23);  // +40
        extrasPanel.add(chbxuseMouseActions);

        // Use main weapon as special attack weapon at 100%
        chbxMainAsSpecWeap = new JCheckBox("Main weapon to spec");
        chbxMainAsSpecWeap.setToolTipText("Selecting will override special attack weapon and always use main weapon for special attack.");
        chbxMainAsSpecWeap.setBounds(30, 319, 150, 23);
        extrasPanel.add(chbxMainAsSpecWeap);

        // Activate menu actions
        chbxuseBuryBones = new JCheckBox("Bury bones?");
        chbxuseBuryBones.setToolTipText("Will bury all bones and ashes in inventory. NB! Add bones to loot table.");
        chbxuseBuryBones.setBounds(195, 294, 150, 23);  // +40
        extrasPanel.add(chbxuseBuryBones);

        // Check if NPC reachable
        chbxnpcReachable = new JCheckBox("Bypass NPC reachability");
        chbxnpcReachable.setToolTipText("If chosen bot will not check if NPC is reachable (useful if NPC in cage etc).");
        chbxnpcReachable.setBounds(195, 319, 200, 23);
        extrasPanel.add(chbxnpcReachable);

        //// Load json
        btnLoadJson = new JButton("Load settings");
        btnLoadJson.setBackground(new Color(78, 131, 232));
        btnLoadJson.setToolTipText("Will load all saved bot settings.");
        btnLoadJson.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                JSONObject data = loadGuiDataFromFile();
                populateGuiWithData(data);
                loadApiKeyFromFile(false);
                displayMessage("Setting loaded successfully!", "eAIO settings by Esmaabi", JOptionPane.INFORMATION_MESSAGE);
            }
        });
        btnLoadJson.setBounds(221, 391, 187, 23);
        contentPane.add(btnLoadJson);

        //// Save json
        btnSaveJson = new JButton("Save settings");
        btnSaveJson.setBackground(Color.DARK_GRAY);
        btnSaveJson.setForeground(new Color(139, 255, 186));
        btnSaveJson.setToolTipText("Will save all bot settings.");
        btnSaveJson.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                JSONObject data = gatherGuiData();
                saveGuiDataToFile(data);
                saveApiKeyToFile(false);
                displayMessage("Setting saved successfully!", "eAIO settings by Esmaabi", JOptionPane.INFORMATION_MESSAGE);
            }
        });
        btnSaveJson.setBounds(17, 391, 187, 23);
        contentPane.add(btnSaveJson);

        //// Start button & apply settings
        btnApplyAndStart = new JButton("Apply Settings & Start");
        btnApplyAndStart.setBackground(new Color(34, 139, 34));
        btnApplyAndStart.setToolTipText("Will apply chosen settings and start bot.");
        btnApplyAndStart.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                onApplyNewSettings();
            }
        });
        btnApplyAndStart.setBounds(221, 421, 187, 23);
        contentPane.add(btnApplyAndStart);

        //// Pause button
        btnPauseBot = new JButton("Pause");
        btnPauseBot.setBackground(new Color(222, 50, 22));
        btnPauseBot.setToolTipText("Will pause eAIO Fighter");
        btnPauseBot.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                pauseBot();
            }
        });
        btnPauseBot.setBounds(17, 421, 187, 23);
        contentPane.add(btnPauseBot);
    }

    //// Auto Fighter functions
    public void onApplyNewSettings() {
        List<Integer> npcIdList = new ArrayList<Integer>();
        for (Object npc : modelSelectedMonsters.toArray()) {
            if (!(npc instanceof String)) {
                continue;
            }
            String npcInfo = (String) npc;
            npcIdList.add(Integer.valueOf(npcInfo.split(",")[2].replace(" ", "").replace("]", "")));
        }
        int[] npcIds = new int[npcIdList.size()];
        for (int i = 0; i < npcIds.length; i++) {
            npcIds[i] = npcIdList.get(i);
        }
        eFood foodType = (eFood) comboBoxFoods.getSelectedItem();
        if (foodType == eFood.NONE) {
            combat.setupEating(null, 150);
        } else {
            assert foodType != null;
            if (!foodType.getName().equals("None")) {
                System.out.println("-------------------------");
                System.out.println("[SETTING] Food to eat: " + foodType.getName());
            }
            combat.setupEating(foodType.getItemId(), (Integer) spinnerHealAt.getValue());
        }
        int[] lootNames = new int[modelLoot.size()];
        if (!modelLoot.isEmpty()) {
            lootNames = new int[modelLoot.size()];
            for (int i = 0; i < lootNames.length; i++) {
                Pattern p = Pattern.compile("\\[(.*?),\\s(\\d+)", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
                Matcher m = p.matcher(modelLoot.get(i));
                if (m.find()) {
                    lootNames[i] = Integer.parseInt(m.group(2));
                }
            }
            combat.setupLooting(lootNames, (Integer) lootWithin.getValue());
        }
        combat.setupAttacking(npcIds);
        combat.eatForSpace = chckbxEatforSpace.isSelected();
        combat.quickPrayers = chbxQuickPrayers.isSelected();
        combat.prayFlick = chckbxPrayFlick.isSelected();
        combat.teleOnTaskFinish = chckbxTeleAfterTask.isSelected();
        combat.enableStatBoosting = chkxdrinkStatsBoost.isSelected();
        combat.buryBones = chbxuseBuryBones.isSelected();
        combat.bypassNpcReachable = chbxnpcReachable.isSelected();
        combat.useMainWeaponAsSpec = chbxMainAsSpecWeap.isSelected();
        BotUtils.eActions.menuActionMode = !chbxuseMouseActions.isSelected();
        eAutoResponser.gptActiveAtHome = gptActiveAtHome.isSelected();
        eAutoResponser.botStarted = true;
        eAutoResponser.gptStarted = activateChatGPT.isSelected();
        if (activateChatGPT.isSelected()) {
            disableChatGPTOptions();
            eApiAccess.eAutoResponser.gptIsActive = true;
            eApiAccess.eAutoResponser.properGrammarActive = getProperGrammar();
            getSelectedActivity();
            getSelectedGptModel();
        }
        setSelectedPrayerFlick();
        getSelectedPrayerPotions();
        getSelectedStatsBoostPotion();
        getAutoRetaliateSettings();
        btnPauseBot.setEnabled(true);
    }

    public void pauseBot() {
        eAutoResponser.botStarted = false;
        eAutoResponser.gptStarted = activateChatGPT.isSelected();
        btnPauseBot.setEnabled(false);
        btnApplyAndStart.setVisible(true);
        activateChatGPT.setEnabled(true);
        gptHasBeenStarted = activateChatGPT.isSelected();
        activateChatGPT.setEnabled(true);
        if (activateChatGPT.isSelected()) {
            enableChatGPTOptions();
            eApiAccess.eAutoResponser.gptIsActive = false;
            eAutoResponser.gptActiveAtHome = gptActiveAtHome.isSelected();
            eApiAccess.eAutoResponser.properGrammarActive = getProperGrammar();
        }
    }

    public void closeGui() {
        theGui.dispose();
    }

    public void onRefreshNearbyMonsters() {
        this.modelNearbyMonsters.clear();

        for (SimpleNpc npc : combat.ctx.npcs.populate().filterHasAction("Attack")) {
            if (!this.modelNearbyMonsters.contains("[" + npc.getName() + ", " + npc.getNpcDefinitions().getCombatLevel() + ", " + npc.getId() + "]") && !this.modelSelectedMonsters.contains("[" + npc.getName() + ", " + npc.getNpcDefinitions().getCombatLevel() + ", " + npc.getId() + "]")) {
                this.modelNearbyMonsters.addElement("[" + npc.getName() + ", " + npc.getNpcDefinitions().getCombatLevel() + ", " + npc.getId() + "]");
            }
        }
    }

    public void setupDropArray() {
        for (int i : eLoots.UNIVERSAL_LOOT_IDS) {
            ItemComposition itemDefinitions = combat.ctx.definitions.getItemDefinition(i);
            if (itemDefinitions != null) {
                modelLoot.addElement("[" + itemDefinitions.getName() + ", " + itemDefinitions.getId() + "]");
            }
        }
        if (modelLoot.isEmpty()) {
            for (int i : eLoots.UNIVERSAL_LOOT_IDS) {
                ItemComposition itemDefinitions = combat.ctx.definitions.getItemDefinition(i);
                if (itemDefinitions != null) {
                    modelLoot.addElement("[" + itemDefinitions.getName() + ", " + itemDefinitions.getId() + "]");
                }
            }
        }
    }

    // GPT functions
    private boolean getProperGrammar() {
        return properGrammar.isSelected();
    }

    private void getSelectedActivity() {
        String selectedActivity = (String) chatActivityComboBox.getSelectedItem();

        eApiAccess.eAutoResponser.skillingActivity = false;
        eApiAccess.eAutoResponser.slayerActivity = false;
        eApiAccess.eAutoResponser.pvmActivity = false;
        eApiAccess.eAutoResponser.chillingActivity = false;
        eApiAccess.eAutoResponser.scriptPurposeActivity = false;
        eApiAccess.eAutoResponser.moneyMakingActivity = false;
        eApiAccess.eAutoResponser.scriptPurposeCustomActivity = false;

        switch (Objects.requireNonNull(selectedActivity)) {
            case "Skilling":
                eApiAccess.eAutoResponser.skillingActivity = true;
                break;
            case "Slayer":
                eApiAccess.eAutoResponser.slayerActivity = true;
                break;
            case "PVM":
                eApiAccess.eAutoResponser.pvmActivity = true;
                break;
            case "Money making":
                eApiAccess.eAutoResponser.moneyMakingActivity = true;
                break;
            case "Chilling":
                eApiAccess.eAutoResponser.chillingActivity = true;
                break;
            case "Script purpose":
                eApiAccess.eAutoResponser.scriptPurposeActivity = true;
                break;
            case "Custom reason":
                eApiAccess.eAutoResponser.scriptPurposeCustomActivity = true;
                break;
        }
    }

    private void getSelectedGptModel() {
        String selectedGptModel = (String) selectGptModelComboBox.getSelectedItem();
        System.out.println("[SETTING] Model to use: " + selectedGptModel);

        eApiAccess.eAutoResponser.useGPT3 = false;
        eApiAccess.eAutoResponser.useGPT4 = false;

        switch (Objects.requireNonNull(selectedGptModel)) {
            case "GPT 3.5 Turbo":
                eApiAccess.eAutoResponser.useGPT3 = true;
                break;
            case "GPT 4":
                eApiAccess.eAutoResponser.useGPT4 = true;
                break;
        }
    }

    // Rest functions
    private void getSelectedPrayerPotions() {
        String selectedPotions = (String) selectPrayerRestoreComboBox.getSelectedItem();
        System.out.println("[SETTING] Restore prayer with: " + selectedPotions);

        if (selectedPotions != null) {
            AutoFighter.prayPotionName = selectedPotions;
        }
    }

    private void setSelectedPrayerFlick() {
        String selectedPrayer = (String) selectPrayerFlickComboBox.getSelectedItem();
        System.out.println("[SETTING] Prayer to flick: " + selectedPrayer);

        if (selectedPrayer != null) {
            switch (selectedPrayer) {
                case "Rigour (lvl 74)":
                    AutoFighter.CHOSEN_PRAYER_FLICK = SimplePrayers.Prayers.RIGOUR;
                    break;
                case "Augury (lvl 77)":
                    AutoFighter.CHOSEN_PRAYER_FLICK = SimplePrayers.Prayers.AUGURY;
                    break;
                case "Chivalry (lvl 60)":
                    AutoFighter.CHOSEN_PRAYER_FLICK = SimplePrayers.Prayers.CHIVALRY;
                    break;
                case "Mystic Might (lvl 45)":
                    AutoFighter.CHOSEN_PRAYER_FLICK = SimplePrayers.Prayers.MYSTIC_MIGHT;
                    break;
                case "Eagle Eye (lvl 44)":
                    AutoFighter.CHOSEN_PRAYER_FLICK = SimplePrayers.Prayers.EAGLE_EYE;
                    break;
                case "Ultimate Strength (lvl 31)":
                    AutoFighter.CHOSEN_PRAYER_FLICK = SimplePrayers.Prayers.ULTIMATE_STRENGTH;
                    break;
                case "Mystic Lore (lvl 27)":
                    AutoFighter.CHOSEN_PRAYER_FLICK = SimplePrayers.Prayers.MYSTIC_LORE;
                    break;
                case "Hawk Eye (lvl 26)":
                    AutoFighter.CHOSEN_PRAYER_FLICK = SimplePrayers.Prayers.HAWK_EYE;
                    break;
                case "Superhuman Strength (lvl 13)":
                    AutoFighter.CHOSEN_PRAYER_FLICK = SimplePrayers.Prayers.SUPERHUMAN_STRENGTH;
                    break;
                case "Mystic Will (lvl 9)":
                    AutoFighter.CHOSEN_PRAYER_FLICK = SimplePrayers.Prayers.MYSTIC_WILL;
                    break;
                case "Sharp Eye (lvl 8)":
                    AutoFighter.CHOSEN_PRAYER_FLICK = SimplePrayers.Prayers.SHARP_EYE;
                    break;
                case "Burst of Strength (lvl 4)":
                    AutoFighter.CHOSEN_PRAYER_FLICK = SimplePrayers.Prayers.BURST_OF_STRENGTH;
                    break;
                default:
                    AutoFighter.CHOSEN_PRAYER_FLICK = SimplePrayers.Prayers.PIETY;
                    break;
            }
        } else {
            AutoFighter.CHOSEN_PRAYER_FLICK = null;
        }
    }

    private void getSelectedStatsBoostPotion() {
        String selectedPotion = (String) selectStatsBoostComboBox.getSelectedItem();
        String selectedSkill = (String) selectSkillToBoostComboBox.getSelectedItem();
        int drinkAt = (int) spinnerBoostStatsAt.getValue();

        if (selectedPotion != null && selectedSkill != null) {
            switch (selectedSkill) {
                case "Attack":
                    AutoFighter.chosenSkillIndicator = SimpleSkills.Skills.ATTACK;
                    break;
                case "Strength":
                    AutoFighter.chosenSkillIndicator = SimpleSkills.Skills.STRENGTH;
                    break;
                case "Defence":
                    AutoFighter.chosenSkillIndicator = SimpleSkills.Skills.DEFENCE;
                    break;
                case "Ranged":
                    AutoFighter.chosenSkillIndicator = SimpleSkills.Skills.RANGED;
                    break;
                case "Magic":
                    AutoFighter.chosenSkillIndicator = SimpleSkills.Skills.MAGIC;
                    break;
            }
            if (!selectedPotion.equals("None")) System.out.println("[SETTING] Bot will drink " + selectedPotion.toLowerCase() + " when " + selectedSkill + " level is lower than " + drinkAt);
            AutoFighter.statsBoostingPotionName = selectedPotion;
            AutoFighter.drinkStatBoostAt = drinkAt;
        }
    }

    private void getAutoRetaliateSettings() {
        String selectedValue = (String) selectAutoRetaliateComboBox.getSelectedItem();
        System.out.println("[SETTING] Auto Retaliate mode: " + selectedValue);

        if (selectedValue != null) {
            switch (selectedValue) {
                case "Default":
                    AutoFighter.autoRetaliateDefault = true;
                    break;
                case "Force ON":
                    AutoFighter.autoRetaliateDefault = false;
                    AutoFighter.autoRetaliate = true;
                    break;
                case "Force OFF":
                    AutoFighter.autoRetaliateDefault = false;
                    AutoFighter.autoRetaliate = false;
                    break;
            }
        }
        System.out.println("-------------------------");
    }

    private void displayMessage(String message, String title, int messageType) {
        JOptionPane optionPane = new JOptionPane(message, messageType);
        JDialog dialog = optionPane.createDialog(this, title);
        dialog.setLocationRelativeTo(theGui);
        dialog.setBackground(Color.darkGray);
        dialog.setVisible(true);
    }

    /// Encrypt API Key to save/load
    private SecretKey getSecretKey(char[] passphrase) throws Exception {
        SecretKeyFactory factory = SecretKeyFactory.getInstance(SECRET_KEY_ALGO);
        KeySpec spec = new PBEKeySpec(passphrase, SALT.getBytes(), ITERATION_COUNT, KEY_LENGTH);
        SecretKey tmp = factory.generateSecret(spec);
        return new SecretKeySpec(tmp.getEncoded(), "AES");
    }

    // Old save / load method with one location.
/*    private void saveApiKeyToFile(boolean showMessage) {
        String apiKey = new String(apiKeyPasswordField.getPassword());
        char[] passphrase = passphraseField.getPassword();
        try {
            // Encryption
            Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGO);
            SecretKey secretKey = getSecretKey(passphrase);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            byte[] encryptedApiKey = cipher.doFinal(apiKey.getBytes());
            byte[] iv = cipher.getIV();

            // Convert to JSON and save
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("encryptedKey", Base64.getEncoder().encodeToString(encryptedApiKey));
            jsonObject.put("iv", Base64.getEncoder().encodeToString(iv));

            try (PrintWriter writer = new PrintWriter(new FileWriter(API_KEY_FILE_PATH))) {
                writer.println(jsonObject.toString());
                writer.flush();
                if (showMessage) displayMessage("API key saved successfully", "API Key Saved", JOptionPane.INFORMATION_MESSAGE);
                logger.severe("API key saved successfully");
            }
        } catch (Exception e) {
            logger.severe("Failed to save API key " + e);
            if (showMessage) displayMessage("Failed to save API key", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void loadApiKeyFromFile(boolean showMessage) {
        char[] passphrase = passphraseField.getPassword();
        try (BufferedReader reader = new BufferedReader(new FileReader(API_KEY_FILE_PATH))) {
            String line = reader.readLine();
            if (line != null) {
                JSONObject jsonObject = new JSONObject(line);
                byte[] encryptedApiKey = Base64.getDecoder().decode(jsonObject.getString("encryptedKey"));
                byte[] iv = Base64.getDecoder().decode(jsonObject.getString("iv"));

                // Decryption
                Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGO);
                SecretKey secretKey = getSecretKey(passphrase);
                cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));
                String apiKey = new String(cipher.doFinal(encryptedApiKey));

                apiKeyPasswordField.setText(apiKey);
                if (showMessage) displayMessage("API key loaded successfully", "API Key Loaded", JOptionPane.INFORMATION_MESSAGE);
                logger.info("API key loaded successfully");
            } else {
                if (showMessage) displayMessage("API key not found in the file", "Error", JOptionPane.ERROR_MESSAGE);
                logger.severe("API key not found in the file");
            }
        } catch (Exception e) {
            logger.severe("Failed to load API key. Please add it again " + e);
            if (showMessage) displayMessage("Failed to load API key. Please add it again", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }*/

    // New save / load method with .simplebot\script_store\eAIO Fighter with GPT\ location.
    private void saveApiKeyToFile(boolean showMessage) {
        String apiKey = new String(apiKeyPasswordField.getPassword());
        char[] passphrase = passphraseField.getPassword();

        final File scriptDirectory = new File(combat.getStorageDirectory());
        File apiKeyFile = new File(scriptDirectory, "api_key_settings.json");

        try {
            // Encryption
            Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGO);
            SecretKey secretKey = getSecretKey(passphrase);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            byte[] encryptedApiKey = cipher.doFinal(apiKey.getBytes());
            byte[] iv = cipher.getIV();

            // Convert to JSON and save
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("encryptedKey", Base64.getEncoder().encodeToString(encryptedApiKey));
            jsonObject.put("iv", Base64.getEncoder().encodeToString(iv));

            try (PrintWriter writer = new PrintWriter(new FileWriter(apiKeyFile))) {
                writer.println(jsonObject.toString());
                writer.flush();
                if (showMessage) displayMessage("API key saved successfully", "API Key Saved", JOptionPane.INFORMATION_MESSAGE);
                logger.severe("API key saved successfully");
            }
        } catch (Exception e) {
            logger.severe("Failed to save API key " + e);
            if (showMessage) displayMessage("Failed to save API key", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void loadApiKeyFromFile(boolean showMessage) {
        char[] passphrase = passphraseField.getPassword();

        final File scriptDirectory = new File(combat.getStorageDirectory());
        File apiKeyFile = new File(scriptDirectory, "api_key_settings.json");

        try (BufferedReader reader = new BufferedReader(new FileReader(apiKeyFile))) {
            String line = reader.readLine();
            if (line != null) {
                JSONObject jsonObject = new JSONObject(line);
                byte[] encryptedApiKey = Base64.getDecoder().decode(jsonObject.getString("encryptedKey"));
                byte[] iv = Base64.getDecoder().decode(jsonObject.getString("iv"));

                // Decryption
                Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGO);
                SecretKey secretKey = getSecretKey(passphrase);
                cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));
                String apiKey = new String(cipher.doFinal(encryptedApiKey));

                apiKeyPasswordField.setText(apiKey);
                if (showMessage) displayMessage("API key loaded successfully", "API Key Loaded", JOptionPane.INFORMATION_MESSAGE);
                logger.info("API key loaded successfully");
            } else {
                if (showMessage) displayMessage("API key not found in the file", "Error", JOptionPane.ERROR_MESSAGE);
                logger.severe("API key not found in the file");
            }
        } catch (Exception e) {
            logger.severe("Failed to load API key. Please add it again " + e);
            if (showMessage) displayMessage("Failed to load API key. Please add it again", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void enableChatGPTOptions() {
        chatActivityComboBox.setEnabled(true);
        selectGptModelComboBox.setEnabled(true);
        gptActiveAtHome.setEnabled(true);
        properGrammar.setEnabled(true);
        apiKeyPasswordField.setEnabled(true);
        loadButton.setEnabled(true);
        saveButton.setEnabled(true);
    }

    private void disableChatGPTOptions() {
        chatActivityComboBox.setEnabled(false);
        selectGptModelComboBox.setEnabled(false);
        gptActiveAtHome.setEnabled(false);
        properGrammar.setEnabled(false);
        apiKeyPasswordField.setEnabled(false);
        loadButton.setEnabled(false);
        saveButton.setEnabled(false);
    }

    // Save / load settings
/*    private void saveGuiDataToFile(JSONObject data) {
        try {
            Files.write(Paths.get("eAutoFighter_settings.json"), data.toString().getBytes());
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Failed to save GUI data to file", e);
        }
    }

    private JSONObject loadGuiDataFromFile() {
        try {
            String content = new String(Files.readAllBytes(Paths.get("eAutoFighter_settings.json")));
            return new JSONObject(content);
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Failed to load GUI data from file", e);
            return null;
        }
    }*/

    private void saveGuiDataToFile(JSONObject data) {
        final File scriptDirectory = new File(combat.getStorageDirectory());
        Path filePath = Paths.get(scriptDirectory.getAbsolutePath(), "eAutoFighter_settings.json");
        try {
            Files.write(filePath, data.toString().getBytes());
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Failed to save GUI data to file", e);
        }
    }

    private JSONObject loadGuiDataFromFile() {
        final File scriptDirectory = new File(combat.getStorageDirectory());
        Path filePath = Paths.get(scriptDirectory.getAbsolutePath(), "eAutoFighter_settings.json");
        try {
            String content = new String(Files.readAllBytes(filePath));
            return new JSONObject(content);
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Failed to load GUI data from file", e);
            return null;
        }
    }

    private JSONObject gatherGuiData() {
        JSONObject data = new JSONObject();

        data.put("activateChatGPT", activateChatGPT.isSelected());
        data.put("buryBones", chbxuseBuryBones.isSelected());
        data.put("npcReachable", chbxnpcReachable.isSelected());
        data.put("mainAsSpecWeap", chbxMainAsSpecWeap.isSelected());
        data.put("boostStatsAt", spinnerBoostStatsAt.getValue());
        data.put("drinkStatsBoost", chkxdrinkStatsBoost.isSelected());
        data.put("mouseActions", chbxuseMouseActions.isSelected());
        data.put("eatForSpace", chckbxEatforSpace.isSelected());
        data.put("gptActiveAtHome", gptActiveAtHome.isSelected());
        data.put("healAt", spinnerHealAt.getValue());
        data.put("lootWithin", lootWithin.getValue());
        data.put("prayFlick", chckbxPrayFlick.isSelected());
        data.put("properGrammar", properGrammar.isSelected());
        data.put("quickPrayers", chbxQuickPrayers.isSelected());
        data.put("selectAutoRetaliate", Objects.requireNonNull(selectAutoRetaliateComboBox.getSelectedItem()).toString());
        data.put("selectedFood", Objects.requireNonNull(comboBoxFoods.getSelectedItem()).toString());
        data.put("selectedGptModel", Objects.requireNonNull(selectGptModelComboBox.getSelectedItem()).toString());
        data.put("selectPrayerFlick", Objects.requireNonNull(selectPrayerFlickComboBox.getSelectedItem()).toString());
        data.put("selectedPrayerRestore", Objects.requireNonNull(selectPrayerRestoreComboBox.getSelectedItem()).toString());
        data.put("selectedSkillToBoost", Objects.requireNonNull(selectSkillToBoostComboBox.getSelectedItem()).toString());
        data.put("selectedStatsBoost", Objects.requireNonNull(selectStatsBoostComboBox.getSelectedItem()).toString());
        data.put("teleAfterTask", chckbxTeleAfterTask.isSelected());

        JSONArray lootItems = new JSONArray();
        DefaultListModel<String> modelLoot = (DefaultListModel<String>) listLoot.getModel();
        for (int i = 0; i < modelLoot.getSize(); i++) {
            String itemString = modelLoot.getElementAt(i);
            String itemId = itemString.substring(itemString.lastIndexOf(", ") + 2, itemString.length() - 1); // Extract the item ID from the string
            lootItems.put(Integer.parseInt(itemId)); // Save only the item ID
        }
        data.put("lootList", lootItems);

        return data;
    }

    private void populateGuiWithData(JSONObject data) {
        if (data == null) return;

        activateChatGPT.setSelected(data.getBoolean("activateChatGPT"));
        chbxuseBuryBones.setSelected(data.getBoolean("buryBones"));
        chbxnpcReachable.setSelected(data.getBoolean("npcReachable"));
        chbxMainAsSpecWeap.setSelected(data.getBoolean("mainAsSpecWeap"));
        spinnerBoostStatsAt.setValue(data.getInt("boostStatsAt"));
        chkxdrinkStatsBoost.setSelected(data.getBoolean("drinkStatsBoost"));
        chbxuseMouseActions.setSelected(data.getBoolean("mouseActions"));
        chckbxEatforSpace.setSelected(data.getBoolean("eatForSpace"));
        gptActiveAtHome.setSelected(data.getBoolean("gptActiveAtHome"));
        spinnerHealAt.setValue(data.getInt("healAt"));
        lootWithin.setValue(data.getInt("lootWithin"));
        chckbxPrayFlick.setSelected(data.getBoolean("prayFlick"));
        properGrammar.setSelected(data.getBoolean("properGrammar"));
        chbxQuickPrayers.setSelected(data.getBoolean("quickPrayers"));
        selectAutoRetaliateComboBox.setSelectedItem(data.getString("selectAutoRetaliate"));
        selectGptModelComboBox.setSelectedItem(data.getString("selectedGptModel"));
        selectPrayerFlickComboBox.setSelectedItem(data.getString("selectPrayerFlick"));
        selectPrayerRestoreComboBox.setSelectedItem(data.getString("selectedPrayerRestore"));
        selectSkillToBoostComboBox.setSelectedItem(data.getString("selectedSkillToBoost"));
        selectStatsBoostComboBox.setSelectedItem(data.getString("selectedStatsBoost"));
        chckbxTeleAfterTask.setSelected(data.getBoolean("teleAfterTask"));

        String selectedFoodString = data.getString("selectedFood");
        eFood selectedFoodEnum = eFood.valueOf(selectedFoodString.toUpperCase());
        comboBoxFoods.setSelectedItem(selectedFoodEnum);

        //DefaultListModel<String> modelLoot = new DefaultListModel<>();
        modelLoot.clear();
        for (Object itemIdObj : data.getJSONArray("lootList")) {
            int itemId = (int) itemIdObj;
            ItemComposition itemDefinitions = combat.ctx.definitions.getItemDefinition(itemId);
            if (itemDefinitions != null) {
                modelLoot.addElement("[" + itemDefinitions.getName() + ", " + itemId + "]");
            }
        }
        listLoot.setModel(modelLoot);

        int[] loadedLootNames = new int[modelLoot.getSize()];
        for (int i = 0; i < modelLoot.getSize(); i++) {
            String itemString = modelLoot.getElementAt(i);
            String itemIdStr = itemString.substring(itemString.lastIndexOf(", ") + 2, itemString.length() - 1);
            loadedLootNames[i] = Integer.parseInt(itemIdStr);
        }
        combat.setLootNames(loadedLootNames);
        System.out.println("Loaded loot size: " + modelLoot.getSize());

    }

}
'''
'''--- src/eAutoFighterZenyte/data/eFood.java ---
package eAutoFighterZenyte.data;

public enum eFood {

    NONE("None", -1),
    SALMON("Salmon", 329),
    TROUT("Trout", 333),
    TUNA("Tuna", 361),
    LOBSTER("Lobster", 379),
    SWORDFISH("Swordfish", 373),
    MONKFISH("Monkfish", 7946),
    SHARK("Shark", 385),
    TUNA_POTATO("Tuna potato", 7060),
    SEA_TURTLE("Sea turtle", 397),
    DARK_CRAB("Dark crab", 11936),
    MANTA_RAY("Manta ray", 391),
    KARAMBWAN("Cooked karambwan", 3144),
    PINEAPPLE_PIZZA("Pineapple pizza", 2301, 2303),
    ANGLERFISH("Anglerfish", 13441);

    private final String name;
    private final int[] itemId;

    eFood(final String name, final int... itemId) {
        this.name = name;
        this.itemId = itemId;
    }

    public int[] getItemId() {
        return itemId;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name().substring(0, 1).toUpperCase() + name().substring(1).toLowerCase();
    }

}
'''
'''--- src/eAutoFighterZenyte/data/eLoots.java ---
package eAutoFighterZenyte.data;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class eLoots {
    public static final Set<Integer> UNIVERSAL_LOOT_IDS = new HashSet<>(Arrays.asList(
            30084, 1626, 1628, 1630, 1624, 1622, 1620, 1618, 1632, 19677, 985, 2809, 21728, 240, 8921, 4101, 4153, 22804,
            1319, 1185, 454, 443, 1149, 1201, 1249, 1163, 568, 2362, 1514, 441, 1392, 4585, 4085, 12073, 11286, 5295, 5698,
            5300, 5301, 1347, 6812, 1359, 6809, 1215, 3140, 20736, 2360, 13576, 11840, 226, 1113, 4103, 1127, 1289, 1780,
            4111, 20727, 11902, 4151, 13265, 7979, 3202, 12655, 11905, 384, 402, 7945, 8779, 3052, 989, 12007, 12004, 2,
            11908, 11235, 7185, 1079, 1305, 9193, 392, 452, 1516, 1748, 8783, 5316, 21817, 3025, 2364, 405, 12644, 6729,
            6562, 6739, 6139, 6141, 6731, 12645, 448, 6737, 6735, 2354, 6724, 6733, 21637, 6334, 2358, 445, 4857, 5304,
            5303, 5298, 5296, 12002, 11998, 4675, 9738, 3050, 1988, 20724, 20730, 21270, 6529, 9194, 6528, 6524, 6568, 533,
            21298, 21301, 21304, 6526, 6522, 6523, 6525, 2722, 13233, 20718, 8921, 5516, 1128, 1290, 1164, 1202, 1398,
            1406, 3055, 576, 214, 2486, 216, 218, 268, 2, 13273, 208, 21918, 22100, 22097, 11824, 11818, 11820, 11822, 246,
            11037, 10887, 961, 13307, 6686, 12696, 386, 13442, 8781, 990, 2367, 2369, 1374, 1320, 1186, 537, 450, 11212,
            21905, 1306, 4588, 6967, 7158, 1216, 1435, 21259, 12783, 12786, 6922, 6571, 12851, 6889, 6918, 6916, 6924, 4131,
            4720, 4722, 4753, 4755, 4757, 4759, 4708, 4710, 4712, 4714, 4745, 4747, 4749, 4751, 4724, 4726, 4728, 4730,
            4732, 4734, 4736, 4738, 6920, 21807, 21810, 21813, 22299, 22302, 22305, 11812, 11816, 11814, 11810, 22557, 1434,
            22552, 22542, 22547, 12789, 12849, 4109, 224, 1752, 11838, 238, 232, 2350, 11993, 1754, 1750, 6694, 6035, 5299,
            5975, 12603, 5315, 12746, 11940, 11920, 1976, 236, 13247, 570, 13249, 13231, 13229, 13227, 13245, 1776, 465,
            11995, 202, 200, 204, 206, 210, 212, 218, 11931, 11928, 2801, 4117, 12816, 12829, 9245, 7061, 5955, 12833, 995,
            12823, 12827, 12819, 1093, 12651, 11785, 13256, 222, 11990, 11929, 11932, 19529, 19592, 19601, 19586, 19589,
            19610, 5317, 5314, 21748, 21739, 21736, 21730, 21745, 8788, 20595, 20517, 20520, 248, 11826, 11828, 11830,
            12650, 11832, 11834, 11836, 12646, 20544, 20545, 20546, 2677, 2971, 242, 9016, 3139, 12647, 6017, 7981, 8901,
            12885, 12653, 7980, 12549, 12652, 11791, 11992, 7400, 7399, 7398, 10602, 4107, 11335, 21802, 1432, 22103,
            13181, 2298, 11930, 11933, 19685, 19701, 13440, 1094, 21273, 13225, 13177, 12605, 21992, 22124, 1377, 11237,
            2425, 22006, 22106, 22111, 12921, 12934, 6290, 12938, 12922, 12932, 12927, 3204, 2999, 3001, 270, 4207, 21206,
            12936, 13200, 13201, 4587, 4087, 4180, 405, 19679, 19681, 19683, 13274, 13275, 13276, 7979, 13265, 2513, 21028,
            21207, 21009, 20849, 20559, 20407, 10926, 397, 2366, 23083, 11937, 11840, 12914, 987, 1147, 1373,  4716, 4718,
            8844, 8845, 8846, 8847, 8848, 8849, 8850, 12954, 12626, 2435, 1333, 1303, 22957, 22960, 10034, 11959, 10033, 22586,
            1185, 30568, 30540, 21257, 993, 12746, 12747, 12748, 12749, 12750, 12751, 12752, 12753, 12754, 12755, 12756, 23487,
            6801
    ));

    public static final String[] BONES_TO_BURY = {
            "Infernal ashes",
            "Dragon bones",
            "Babydragon bones",
            "Big bones",
            "Normal bones",
            "Lava dragon bones",
            "Hydra bones",
            "Dagannoth bones",
            "Drake bones",
            "Wyrm bones",
            "Wyvern bones",
            "Lava dragon bones",
            "Superior dragon bones",
            "Bat bones",
            "Ourg bones",
            "Abyssal ashes",
            "Malicious ashes",
            "Abyssal ashes",
            "Vile ashes",
            "Fiendish ashes",
            "Bones"
    };
}

'''
'''--- src/eBarbarianFisherZenyte/eMain.java ---
package eBarbarianFisherZenyte;

import BotUtils.eActions;
import BotUtils.eBanking;
import BotUtils.eData;
import BotUtils.eImpCatcher;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Pathing;
import simple.hooks.wrappers.*;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.logging.Logger;

import static eApiAccess.eAutoResponser.*;

@ScriptManifest(author = "Esmaabi", category = Category.FISHING, description =
                "<br>The most effective chinchompa hunter bot on Zenyte!<br>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "Start <b>near any chinchompas</b>.<br>"
                + "Make sure that it's possible to set up box traps on all tiles.<br> "
                + "Have at least 5 box traps in inventory.<br>"
                + "Bot will decide how many traps to place.<br>"
                + "Chat GPT answering is integrated.",
        discord = "Esmaabi#5752",
        name = "eBarbarianFisherBot", servers = { "Zenyte" }, version = "1")

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    public static eAutoResponderGui guiGpt;
    private static final Logger logger = Logger.getLogger(eMain.class.getName());
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.FISHING;
    private final static int INVENTORY_BAG_WIDGET_ID = 548;
    private final static int INVENTORY_BAG_CHILD_ID = 58;
    private final List<String> fishNames = Arrays.asList("Leaping sturgeon", "Leaping trout", "Leaping salmon");
    private final List<String> roeNames = Arrays.asList("Roe", "Caviar");

    // Variables related to game status
    private long startTime;
    private long startingSkillLevel;
    private long startingSkillExp;
    private int count;
    private boolean cutFish = true;
    private boolean roeMade = false;
    private static boolean hidePaint = false;

    // Variables (other)
    private static String status;

    // Gui GPT
    public void initializeGptGUI() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        eBanking bankingUtils = new eBanking(ctx);
        eActions actionUtils = new eActions(ctx);
        eData dataUtils = new eData(ctx);
        eImpCatcher impCatcher = new eImpCatcher(ctx);
        eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx), new eImpCatcher(ctx)));

        // Setting up GPT Gui
        eAutoResponser.scriptPurpose = "you're just doing barbarian fishing to level Fishing fast.";
        eAutoResponser.gptStarted = false;
        initializeGptGUI();

        // Starting message
        System.out.println("Started eBarbarianFisherBot!");
        this.ctx.log("--------------- " + getCurrentTimeFormatted() + " ---------------");
        this.ctx.log("------------------------------------");
        this.ctx.log("          eBarbarianFisherBot       ");
        this.ctx.log("------------------------------------");

        // Variables
        updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        gptDeactivation();
        count = 0;
        cutFish = false;
        roeMade = false;

        // Viewport settings
        ctx.viewport.angle(0);
        ctx.viewport.pitch(true);
        ctx.viewport.yaw();
    }

    @Override
    public void onProcess() {
        super.onProcess();

        SimplePlayer localPlayer = ctx.players.getLocal();
        Pathing pathing = ctx.pathing;

        if (!botStarted) {
            return;
        }

        if (pathing.energyLevel() > 30 && !pathing.running() && pathing.inMotion()) {
            pathing.running(true);
        }

        if (!invItemValid("Knife") || !invItemValid("Feather") || !invItemValid("Barbarian rod")) {
            updateStatus("Check inventory!");
            updateStatus("You must have: Knife, Feathers & Barbarian rod");
            ctx.stopScript();
        }

        if (ctx.inventory.inventoryFull()) {
            eatRoe();
            dropFish();

        } else {

            if (localPlayer.isAnimating()) {
                cuttingFihs();
            } else {
                updateStatus("Player not fishing!");
                SimpleNpc fishingSpot = ctx.npcs.populate().filter(1542).nearest().next();
                if (fishingSpot != null) {
                    if (BotUtils.eActions.targetIsVisible(fishingSpot, ctx.players.getLocal().getLocation(), ctx)) {
                        clickFishingSpot(fishingSpot);
                    }
                }
            }
        }
    }

    private void eatRoe() {
        SimpleItem roeIdes = ctx.inventory.populate().filter("Roe", "Caviar").next();
        if (roeIdes != null) {
            updateStatus("Eating " + roeIdes.getName().toLowerCase());
            roeIdes.click("Eat");
            clickOnBag();
        }
    }

    private void dropFish() {
        SimpleItem fishIds = ctx.inventory.populate().filter("Leaping sturgeon", "Leaping trout", "Leaping salmon").reverse().next();
        if (fishIds != null) {
            updateStatus("Dropping " + fishIds.getName().toLowerCase());
            if (ctx.inventory.shiftDroppingEnabled()) {
                ctx.inventory.dropItem(fishIds);
            } else {
                fishIds.click("Drop");
            }
            clickOnBag();
            ctx.onCondition(() -> !ctx.inventory.inventoryFull(), 200, 4);
        }
    }

    private void clickFishingSpot(SimpleNpc npc) {
        updateStatus("Clicking fishing spot");
        BotUtils.eActions.interactWith(npc, "Use-rod");
        ctx.onCondition(ctx.players.getLocal()::isAnimating, 200, 6);
    }

    private void cuttingFihs() {
        status = "Fishing...";
        SimpleItem fishIds = ctx.inventory.populate().filter("Leaping sturgeon", "Leaping trout", "Leaping salmon").reverse().next();
        SimpleItem knife = ctx.inventory.populate().filter("Knife").next();
        if (fishIds != null && knife != null) {
            updateStatus("Cutting " + fishIds.getName().toLowerCase());
            knife.click("Use");
            fishIds.click(0);
            clickOnBag();
            ctx.onCondition(() -> roeMade, 200, 4);
            roeMade = false;
        }
    }

    private void clickOnBag() {
        SimpleWidget inventoryBagWidget = ctx.widgets.getWidget(INVENTORY_BAG_WIDGET_ID, INVENTORY_BAG_CHILD_ID);
        if (inventoryBagWidget != null) {
            inventoryBagWidget.click(0);
        }
    }

    private boolean targetIsVisible(SimpleNpc npc) {
        if (!npc.visibleOnScreen()) {
            Random rand = new Random();

            WorldPoint npcLocation = npc.getLocation();
            WorldPoint myLocation = ctx.players.getLocal().getLocation();

            int maxAttempts = 100;
            int attempts = 0;

            while (!npc.visibleOnScreen()) {
                myLocation = ctx.players.getLocal().getLocation(); // Refreshing current location
                npcLocation = npc.getLocation(); // Refreshing target location

                attempts++;
                if (attempts >= maxAttempts) {
                    break;
                }

                // Recalculate the direction based on the new positions
                int directionX = Integer.compare(npcLocation.getX(), myLocation.getX());
                int directionY = Integer.compare(npcLocation.getY(), myLocation.getY());

                // Recalculate the distance to the NPC to adjust movement magnitude
                int currentDistance = (int) ctx.pathing.distanceTo(npc.getLocation());

                if (currentDistance <= 5) {
                    return false;
                }

                ctx.log("Current distance to: " + npc.getName() + ": " + currentDistance);

                // The closer the player is, the smaller the movement magnitude
                int maxMovement = Math.min(currentDistance, 7); // Upper limit is 7
                int minMovement = Math.max(1, currentDistance / 2); // Half the distance but at least 1
                int movementMagnitude = rand.nextInt(maxMovement - minMovement + 1) + minMovement;

                // Calculate offsets based on the updated direction and movement magnitude
                int xOffset = directionX * movementMagnitude;
                int yOffset = directionY * movementMagnitude;

                // Move towards the target based on the new calculations
                moveToLocation(myLocation.getX() + xOffset, myLocation.getY() + yOffset);
                ctx.sleep(600);
            }
        }

        return  true;
    }

    private void moveToLocation(int x, int y) {
        WorldPoint startingSpot = ctx.players.getLocal().getLocation();
        WorldPoint targetSpot = new WorldPoint(x, y, startingSpot.getPlane());
        ctx.pathing.step(targetSpot);
    }

    private boolean invItemValid(String itemName) {
        return !ctx.inventory.populate().filter(itemName).isEmpty();
    }

    //Utility
    public static String getCurrentTimeFormatted() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    private void updateStatus(String newStatus) {
        status = newStatus;
        ctx.log(status);
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + getCurrentTimeFormatted() + " --------------");
        ctx.log("You have caught: " + count + " leaping fish");
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        startingSkillLevel = 0L;
        startingSkillExp = 0L;
        count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();

    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        if (gptStarted && botStarted) eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        eTriviaInfo.handleBroadcastMessage(getType, gameMessage);

        if (getType == ChatMessageType.SPAM) {
            String spamMessage = getEvent.getMessage();
            if (spamMessage.contains("You catch a")) {
                status = "Caught a fish!";
                cutFish = true;
                count++;
            }

            if (spamMessage.contains("You cut open the fish")) {
                status = "Roe has been made!";
                roeMade = true;
            }
        }
    }

    @Override
    public int loopDuration() {
        return 600;
    }

    @Override
    public void paint(Graphics g) {

        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 205, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 205, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString("eBarbarianFisherBot by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString("Fish caught: " + count + " (" + ctx.paint.valuePerHour(count, startTime) + " per/h)", 15, 210);
            g.drawString("Status: " + status, 15, 225);
        }
    }
}

'''
'''--- src/eBlastFurnaceZenyte/eMain.java ---
package eBlastFurnaceZenyte;

import BotUtils.eActions;
import BotUtils.eBanking;
import BotUtils.eData;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ObjectID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Pathing;
import simple.hooks.wrappers.*;

import java.awt.*;
import java.awt.event.KeyEvent;
import java.util.*;
import java.util.List;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import static eApiAccess.eAutoResponser.*;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.MINIGAMES,
        description = "<html>"
                + "<br>The most effective Blast Furnace bot on Zenyte!<br>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "Start <b>at Blast Furnace with chosen bank preset</b>.<br>"
                + "Make sure that preset has been loaded.<br> "
                + "Goldsmithing Gauntlets and Enhanced Ice Gloves supported.<br> "
                + "Start with Goldsmithing Gauntlets in inventory and and Enhanced Ice gloves equipped.<br> "
                + "Stamina potion drinking support added.<br> "
                + "Recommended to have Stamina potion (1) in inventory as preset.<br>"
                + "Chat GPT answering is integrated."
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eBlastFurnaceBot",
        servers = {"Zenyte"},
        version = "1.5"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final String eBotName = "eBlastFurnaceBot";
    private static final String ePaintText = "Bars made";
    private static eAutoResponderGui guiGpt;
    private static final Logger logger = Logger.getLogger(eAnglerFisherBot.eMain.class.getName());
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.SMITHING;
    private final WorldPoint BAR_DISPENSER_LOCATION = new WorldPoint(1940, 4963, 0);
    private final WorldPoint CONVAYOR_BELT_LOCATION = new WorldPoint(1943, 4967, 0);
    private final WorldPoint NEAR_CONVAYOR_BELT_LOCATION = new WorldPoint(1942, 4967, 0);
    private final WorldPoint TAKE_BARS_FROM_DISPENSER_LOCATION = new WorldPoint(1939, 4963, 0);
    private static final int ENHANCED_ICE_GLOVES = 30030;
    private static final int GOLDSMITH_GAUNTLETS = 776;
    private static final int BAR_DISPENSER = 9092;
    private static final List<String> BARS_LIST = Arrays.asList(
            "Bronze bar",
            "Iron bar",
            "Steel bar",
            "Silver bar",
            "Gold bar",
            "Mithril bar",
            "Adamantite bar",
            "Runite bar"
    );
    private static final List<String> ORES_LIST = Arrays.asList(
            "Copper ore",
            "Tin ore",
            "Iron ore",
            "Coal",
            "Silver ore",
            "Gold ore",
            "Mithril ore",
            "Adamantite ore",
            "Runite ore"
    );

    private static int countInv;

    // Variables
    private long startTime = 0L;
    private long startingSkillLevel;
    private long startingSkillExp;
    private int count;
    public static boolean hidePaint = false;
    private boolean oresOnConveyor;

/*    // Define the data structure
    private static final HashMap<String, HashMap<String, Integer>> BAR_TO_ORE_MAP = new HashMap<>();

    // Static block to initialize the mapping
    static {
        // Define ores for each bar and add them to the main map
        BAR_TO_ORE_MAP.put("Bronze bar", createOreMap("Copper ore", 1, "Tin ore", 1));
        BAR_TO_ORE_MAP.put("Iron bar", createOreMap("Iron ore", 1));
        BAR_TO_ORE_MAP.put("Steel", createOreMap("Iron ore", 1, "Coal", 1));
        BAR_TO_ORE_MAP.put("Silver bar", createOreMap("Silver ore", 1));
        BAR_TO_ORE_MAP.put("Gold bar", createOreMap("Gold ore", 1));
        BAR_TO_ORE_MAP.put("Mithril bar", createOreMap("Mithril ore", 1, "Coal", 2));
        BAR_TO_ORE_MAP.put("Adamant bar", createOreMap("Adamantite ore", 1, "Coal", 3));
        BAR_TO_ORE_MAP.put("Rune bar", createOreMap("Runite ore", 1, "Coal", 4));
    }*/

    // Gui GPT
    private void initializeGptGui() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        eBanking bankingUtils = new eBanking(ctx);
        eActions actionUtils = new eActions(ctx);
        eData dataUtils = new eData(ctx);
        eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx)));
        initializeMethods(); // BotUtils
        initializeGptGui(); // GPT
        eAutoResponser.scriptPurpose = "you're just doing some bars for smithing. ";
        gptDeactivation();

        // Other vars
        ctx.log("--------------- " + eActions.getCurrentTimeFormatted() + " ---------------");
        ctx.log("-------------------------------------");
        ctx.log("            " + eBotName + "         ");
        ctx.log("-------------------------------------");

        // Vars
        eActions.updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        count = 0;
        countInv = 0;
        ctx.viewport.angle(0);
        ctx.viewport.pitch(true);
        oresOnConveyor = false;
    }

    @Override
    public void onProcess() {
        super.onProcess();

        final SimplePlayer localPlayer = ctx.players.getLocal();
        Pathing pathing = ctx.pathing;

        if (!botStarted) {
            eActions.status = "Please start the bot!";
            return;
        }

        handleEnergy();

        if (oresOnConveyor) {

            if (BotUtils.eActions.hasItemsInInventory(null, BARS_LIST)) {
                oresOnConveyor = false;
                return;
            }

            if (localPlayer.getLocation().distanceTo(TAKE_BARS_FROM_DISPENSER_LOCATION) > 2) {
                BotUtils.eActions.status = "Walking to bar dispenser";
                pathing.clickSceneTile(TAKE_BARS_FROM_DISPENSER_LOCATION, false, true);
                ctx.onCondition(pathing::inMotion);
            }

            String[] actions = ctx.getClient().getObjectDefinition(BAR_DISPENSER).getImpostor().getActions();
            if (Arrays.asList(actions).contains("Take")) {
                wearGloves(ENHANCED_ICE_GLOVES);
                clickObject(BAR_DISPENSER, "Take", widgetVisible(270, 14));
            }

            if (widgetVisible(270, 14)) {
                BotUtils.eActions.clickWidget(270, 14);
                ctx.onCondition(() -> BotUtils.eActions.hasItemsInInventory(null, BARS_LIST), 50, 20);
                return;
            }
        }

        if (!oresOnConveyor) {

            if (BotUtils.eActions.hasItemsInInventory(null, ORES_LIST)) {
                count += countInv;
                countInv = 0;
                if (!pathing.inMotion()) pathing.step(NEAR_CONVAYOR_BELT_LOCATION);
                wearGloves(GOLDSMITH_GAUNTLETS);
                clickObject(ObjectID.CONVEYOR_BELT, "Put-ore-on", !BotUtils.eActions.hasItemsInInventory(null, ORES_LIST));
                return;
            }

            if (BotUtils.eActions.hasItemsInInventory(null, BARS_LIST)
                    || (!BotUtils.eActions.hasItemsInInventory(null, BARS_LIST) && !BotUtils.eActions.hasItemsInInventory(null, ORES_LIST))) {
                bankTask();
            }
        }
    }

    private void bankTask() {
        SimpleObject bankChest = ctx.objects.populate().filter("Bank chest").nearest().next();
        countInv = countBarsInInventory();
        BotUtils.eActions.status = "Banking";
        if (bankChest != null && bankChest.validateInteractable()) {
            BotUtils.eActions.interactWith(bankChest, "Last Preset");
            ctx.onCondition(() -> !BotUtils.eActions.hasItemsInInventory(null, ORES_LIST), 50, 20);
        }
    }

    private int countBarsInInventory() {
        int totalCount = 0;
        for (String barName : BARS_LIST) {
            totalCount += ctx.inventory.populate().filter(barName).population();
        }
        return totalCount;
    }

    private boolean widgetVisible(int wigetId, int childId) {
        SimpleWidget widgetToClick = ctx.widgets.getWidget(wigetId, childId);

        if (widgetToClick == null) {
            return false;
        }
        ctx.keyboard.pressKey(KeyEvent.VK_SPACE);
        return true;
    }

    private void handleEnergy() {
        Pathing pathing = ctx.pathing;

        if (pathing.energyLevel() < 20) {
            final SimpleItem potion = ctx.inventory.populate().filter(Pattern.compile("Stamina potion\\(\\d+\\)")).filterHasAction("Drink").next();
            final int cached = pathing.energyLevel();
            if (potion == null) {
                return;
            }
            BotUtils.eActions.status = ("Drinking " + potion.getName().toLowerCase());
            if (potion.click("Drink")) {
                ctx.onCondition(() -> pathing.energyLevel() > cached, 50, 20);
            }
        }

        if (pathing.energyLevel() >= 30 && !pathing.running()) {
            pathing.running(true);
        }
    }

    private void wearGloves(int glovesInt) {
        SimpleItem theGloves = ctx.inventory.populate().filter(glovesInt).next();

        if (theGloves != null) {
            BotUtils.eActions.status = "Wearing " + theGloves.getName().toLowerCase();
            if (theGloves.click(0)) {
                ctx.onCondition(() -> !BotUtils.eActions.hasItemsInInventory(null, glovesInt), 50, 20);
            }
        }
    }

    private void clickObject(int objetId, String actionName, boolean condition) {
        SimpleObject objectToClick = ctx.objects.populate().filter(objetId).nearest().next();

        if (objectToClick != null) {
            String objectName = "Conveyor belt".equals(objectToClick.getName()) ? "Conveyor belt" : "Bar dispenser";
            BotUtils.eActions.status = "Clicking " + objectName.toLowerCase();
            BotUtils.eActions.interactWith(objectToClick, actionName);
            ctx.onCondition(() -> condition, 50, 20);
        }
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log(ePaintText + ": " + count);
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();
        eActions.specialAttackTool = false;
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        if (gptStarted && botStarted) eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        eTriviaInfo.handleBroadcastMessage(getType, gameMessage);

        if (getType == ChatMessageType.GAMEMESSAGE) {
            if (gameMessage.contains("your ore goes onto the conveyor belt")) {
                BotUtils.eActions.status = "Ores are on conveyor belt!";
                oresOnConveyor = true;
            }
        }
    }

    @Override
    public int loopDuration() {
        return 150;
    }

    @Override
    public void paint(Graphics g) {

        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePaintText + ": " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + eActions.status, 15, 225);
        }
    }
}

'''
'''--- src/eBlastFurnaceZenyteOld/eMain.java ---
package eBlastFurnaceZenyteOld;

import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ItemID;
import net.runelite.api.ObjectID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleBank;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Pathing;
import simple.hooks.wrappers.*;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import static eApiAccess.eAutoResponser.*;

@ScriptManifest(author = "Esmaabi", category = Category.MINIGAMES, description =
                "<br>The most effective Blast Furnace bot on Zenyte!<br>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "Start <b>at Blast Furnace with ores in inventory</b>.<br>"
                + "Make sure that ores are visible in bank.<br> "
                + "If you have stamina potions in inventory bot will use them.<br>"
                + "Chat GPT answering is integrated.",
        discord = "Esmaabi#5752",
        name = "eBlastFurnaceBotOld", servers = { "Zenyte" }, version = "1")

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    public static eAutoResponderGui guiGpt;
    private static final Logger logger = Logger.getLogger(eMain.class.getName());
    private static final SimpleSkills.Skills chosenSkill = SimpleSkills.Skills.SMITHING;
    private final static int INVENTORY_BAG_WIDGET_ID = 548;
    private final static int INVENTORY_BAG_CHILD_ID = 58;
    private final WorldPoint BAR_DISPENSER_LOCATION = new WorldPoint(1940, 4963, 0);
    private final WorldPoint CONVAYOR_BELT_LOCATION = new WorldPoint(1943, 4967, 0);
    private final WorldPoint NEAR_CONVAYOR_BELT_LOCATION = new WorldPoint(1942, 4967, 0);
    private static final String[] BANK_NAME = {"Bank booth", "Bank chest", "Bank counter"};
    private static final String[] BANKER_NAME = {"Banker","Bird's-Eye' Jack", "Arnold Lydspor", "Banker tutor", "Cornelius", "Emerald Benedict", "Eniola", "Fadli", "Financial Wizard", "Financial Seer", "Ghost banker", "Gnome banker", "Gundai", "Jade", "Jumaane", "Magnus Gram", "Nardah Banker", "Odovacar", "Peer the Seer", "Sirsal Banker", "Squire", "TzHaar-Ket-Yil", "TzHaar-Ket-Zuh", "Yusuf"};
    private static final int ENHANCED_ICE_GLOVES = 30030;
    private static final int GOLDSMITH_GAUNTLETS = 776;
    private static final int BAR_DISPENSER = 9092;

    // Variables related to game status
    private long startTime;
    private long startingSkillLevel;
    private long startingSkillExp;
    private int count;
    private boolean oresOnConveyor = true;
    private  boolean roeMade = false;
    private static boolean hidePaint = false;

    // Variables (other)
    private static String playerGameName;
    private static String triviaAnswer;
    private static String status;

    // Gui GPT
    public void initializeGptGUI() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx)));

        // Setting up GPT Gui
        eAutoResponser.scriptPurpose = "you're just doing smithing.";
        eAutoResponser.gptStarted = false;
        initializeGptGUI();

        // Starting message
        System.out.println("Started eBlastFurnaceBot!");
        this.ctx.log("--------------- " + getCurrentTimeFormatted() + " ---------------");
        this.ctx.log("------------------------------------");
        this.ctx.log("           eBlastFurnaceBot         ");
        this.ctx.log("------------------------------------");

        // Variables
        updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(chosenSkill);
        this.startingSkillExp = this.ctx.skills.experience(chosenSkill);
        gptIsActive = false;
        count = 0;
        oresOnConveyor = false;
        roeMade = false;

        // Viewport settings
        ctx.viewport.angle(120);
        ctx.viewport.pitch(true);
        ctx.viewport.yaw();
    }

    @Override
    public void onProcess() {
        super.onProcess();

        SimplePlayer localPlayer = ctx.players.getLocal();
        Pathing pathing = ctx.pathing;

        if (!gptStarted) {
            return;
        }

        if (!pathing.running()) {
            handleEnergy();
        }

        if (oresOnConveyor) {
            if (localPlayer.getLocation().distanceTo(BAR_DISPENSER_LOCATION) >= 2) {
                status = "Walking to bar dispenser";
                ctx.pathing.step(1940, 4964);
                ctx.onCondition(() -> ctx.pathing.inMotion(), 250, 4);
            } else {

                int barDispenserImposter = ctx.getClient().getObjectDefinition(BAR_DISPENSER).getImpostor().getId();
                if (barDispenserImposter == ObjectID.BAR_DISPENSER_9094 || barDispenserImposter == ObjectID.BAR_DISPENSER) {
                    status = "Bars not ready yet...";
                    return;

                } else {

                    SimpleObject barDispenser = ctx.objects.populate().filter(BAR_DISPENSER).next();
                    SimpleItem iceGloves = ctx.inventory.populate().filter(ENHANCED_ICE_GLOVES).next();

                    if (iceGloves != null) {
                        status = "Wearing " + iceGloves.getName().toLowerCase();
                        if (iceGloves.click("Wear")) {
                            ctx.onCondition(() -> itemNotInInventory(ENHANCED_ICE_GLOVES), 250, 5);
                        }
                    }

                    status = "Clicking bar dispenser";
                    if (barDispenser.click("Take", "Bar dispenser")) {
                        ctx.onCondition(() -> widgetVisible(270, 14), 250, 6);
                    }

                    if (widgetVisible(270, 14)) {
                        clickWidget(270, 14);
                        ctx.onCondition(() -> !itemNotInInventory(ItemID.GOLD_BAR), 250, 5);
                    }

                    if (!itemNotInInventory(ItemID.GOLD_BAR)) {
                        oresOnConveyor = false;
                    }
                }
            }
        }

        if (!itemNotInInventory(ItemID.GOLD_BAR) && !oresOnConveyor) {
            bankTask();
        }

        if (!itemNotInInventory(ItemID.GOLD_ORE) && !oresOnConveyor) {
            SimpleObject conveyorBelt = ctx.objects.populate().filter("Conveyor belt").filterHasAction("Put-ore-on").nearest(CONVAYOR_BELT_LOCATION).next();
            SimpleItem goldsmithingGloves = ctx.inventory.populate().filter(GOLDSMITH_GAUNTLETS).next();
            ctx.pathing.step(NEAR_CONVAYOR_BELT_LOCATION);
            if (conveyorBelt != null && conveyorBelt.validateInteractable()) {
                if (goldsmithingGloves != null) {
                    status = "Wearing " + goldsmithingGloves.getName().toLowerCase();
                    if (goldsmithingGloves.click("Wear")) {
                        ctx.onCondition(() -> itemNotInInventory(GOLDSMITH_GAUNTLETS), 250, 5);
                    }
                }
                status = "Clicking " + conveyorBelt.getName().toLowerCase();
                if (conveyorBelt.click("Put-ore-on")) {
                    ctx.onCondition(() -> itemNotInInventory(ItemID.GOLD_ORE), 250, 5);
                }
            }
        }
    }

    // Banking
    private void bankTask() {
        int ENERGY_THRESHOLD = 30;
        int[] EXCLUDE_DEPOSIT_ITEMS = {ENHANCED_ICE_GLOVES, GOLDSMITH_GAUNTLETS, 12625, 12627, 12629, 12631};
        final Pattern STAMINA_POTION_PATTERN = Pattern.compile("Stamina potion\\(\\d+\\)");

        if (ctx.bank.bankOpen()) {
            int goldBars = ctx.inventory.populate().filter(ItemID.GOLD_BAR).population();

            updateStatus("Depositing items");
            ctx.bank.depositAllExcept(EXCLUDE_DEPOSIT_ITEMS);

            updateStatus("Withdrawing gold ores");
            count += goldBars;
            if (ctx.pathing.energyLevel() <= ENERGY_THRESHOLD && ctx.inventory.populate().filter(STAMINA_POTION_PATTERN).isEmpty()) {
                withdrawItem(12625); // Stamina potion(4)
            }
            if (ctx.bank.withdraw(ItemID.GOLD_ORE, SimpleBank.Amount.ALL)) {
                ctx.onCondition(() -> !itemNotInInventory(ItemID.GOLD_ORE), 250, 8);
            }

            updateStatus("Closing bank");
            ctx.bank.closeBank();
            return;
        }

        if (!ctx.bank.bankOpen()) {
            gettingClosestBank();
        }
    }

    private void gettingClosestBank() {
        String message = "Opening bank";
        SimpleObject bankChest = getBankChest();
        SimpleNpc bankerName = getBanker();
        if (bankChest != null &&
                (bankerName == null || bankChest.distanceTo(ctx.players.getLocal()) <= bankerName.distanceTo(ctx.players.getLocal()))) {
            updateStatus(message);
            bankChest.click(1);
            ctx.onCondition(() -> ctx.bank.bankOpen(), 250 , 20);
        } else if (bankerName != null &&
                (bankChest == null || bankerName.distanceTo(ctx.players.getLocal()) <= bankChest.distanceTo(ctx.players.getLocal()))) {
            updateStatus(message);
            bankerName.click("Bank");
            ctx.onCondition(() -> ctx.bank.bankOpen(), 250 , 20);
        }
    }

    private SimpleObject getBankChest() {
        SimpleObject bankChest = ctx.objects.populate().filter(BANK_NAME).nearest().next();
        if (bankChest != null && bankChest.validateInteractable()) {
            return bankChest;
        }
        return null;
    }

    private SimpleNpc getBanker() {
        SimpleNpc bankerName = ctx.npcs.populate().filter(BANKER_NAME).nearest().next();
        if (bankerName != null && bankerName.validateInteractable()) {
            return bankerName;
        }
        return null;
    }

    // bankOpen utility
    private void withdrawItem(int ID) {
        SimpleWidget quantityOne = ctx.widgets.getWidget(12, 29);
        if (quantityOne != null && !quantityOne.isHidden()) {
            quantityOne.click(0);
        }
        ctx.bank.withdraw(ID, SimpleBank.Amount.ONE);
        clearBankSearch();
    }

    private void clearBankSearch() {
        SimpleWidget searchButton = ctx.widgets.getWidget(12, 40);
        if (searchButton != null && !searchButton.isHidden()) {
            searchButton.click(0);
        }
    }

    private void clickWidget(int wigetId, int childId) {
        SimpleWidget widgetToClick = ctx.widgets.getWidget(wigetId, childId);
        if (widgetToClick != null && !widgetToClick.isHidden()) {
            widgetToClick.click(0);
        }
    }

    private boolean widgetVisible(int wigetId, int childId) {
        SimpleWidget widgetToClick = ctx.widgets.getWidget(wigetId, childId);
        if (widgetToClick != null && !widgetToClick.isHidden()) {
            widgetToClick.click(0);
            return true;
        }
        return false;
    }

    private void clickOnBag() {
        SimpleWidget inventoryBagWidget = ctx.widgets.getWidget(INVENTORY_BAG_WIDGET_ID, INVENTORY_BAG_CHILD_ID);
        if (inventoryBagWidget != null) {
            inventoryBagWidget.click(0);
        }
    }

    private boolean itemNotInInventory(int itemId) {
        return ctx.inventory.populate().filter(itemId).isEmpty();
    }
    private void handleEnergy() {
        Pathing pathing = ctx.pathing;

        if (pathing.energyLevel() >= 30 && !pathing.running()) {
            pathing.running(true);
        }

        if (pathing.energyLevel() < 30) {
            final SimpleItem potion = ctx.inventory.populate().filter(Pattern.compile("Stamina potion\\(\\d+\\)")).filterHasAction("Drink").next();
            final int cached = pathing.energyLevel();
            if (potion == null) {
                return;
            }
            status = ("Drinking " + potion.getName().toLowerCase());
            if (potion != null && potion.click("Drink")) {
                ctx.onCondition(() -> pathing.energyLevel() > cached, 250, 8);
            }
        }
    }

    private void changeCameraAngleOnThread(SimpleGroundItem object) {
        // Create a ScheduledExecutorService with a single thread
        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();

        // Turn to desired object
        ctx.viewport.turnTo(object);

        // Get the current camera orientation angle
        int currentAngle = ctx.viewport.yaw();

        // Generating a random number between 0 and 30
        int angleChange = randomSleeping(0, 30);

        // Getting the sign of the angle change based on the current angle
        if (currentAngle >= 329 || currentAngle <= 30) {
            angleChange = -angleChange; // Make the angle change negative for 329-359 and 0-30 range
        }

        // Calculating the new camera angle by adding the angle change
        int newAngle = (currentAngle + angleChange) % 360;

        // Setting the new camera angle
        ctx.viewport.angle(newAngle);

        // Shutting down the executor
        executor.shutdown();
    }

    //Utility
    public static String getCurrentTimeFormatted() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    private void updateStatus(String newStatus) {
        status = newStatus;
        ctx.log(status);
    }

    // Trivia
    private void sendAnswer(String answer) {
        if (answer == null) {
            return;
        }

        if (ctx.dialogue.dialogueOpen()) {
            ctx.dialogue.clickContinue();
        }

        StringBuilder writeAnswer = new StringBuilder("::ans ");
        writeAnswer.append(answer);

        Thread thread = new Thread(() -> {
            try {
                int sleepTime = randomSleeping(5000, 10000);
                updateStatus(getCurrentTimeFormatted() + " [Trivia] Sleeping for " + sleepTime + "ms");
                Thread.sleep(sleepTime); // Randomized delay
                ctx.keyboard.sendKeys(writeAnswer.toString());
                triviaAnswer = null;
                updateStatus(getCurrentTimeFormatted() + " [Trivia] Question answered");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread.start();
    }

    private void handleTriviaQuestion(String gameMessageTrimmed) {
        for (eTriviaInfo.TriviaQuestion triviaQuestion : eTriviaInfo.TriviaQuestion.values()) {
            if (gameMessageTrimmed.contains(triviaQuestion.getQuestion())) {
                triviaAnswer = triviaQuestion.getAnswer();
                sendAnswer(triviaAnswer);
                break;
            }
        }
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + getCurrentTimeFormatted() + " --------------");
        ctx.log("You have made: " + count + " gold bars");
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        startingSkillLevel = 0L;
        startingSkillExp = 0L;
        count = 0;
        guiGpt.setVisible(false);
        gptStarted = false;
        messageSaved = null;

    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        playerGameName = eAutoResponser.getPlayerName(ctx);

        if (m.getMessage() == null) {
            return;
        }

/*        String eventToString = getEvent.toString().replaceAll("<[^>]+>", "").trim();;
        logger.info(eventToString); // to debug (returns chat type, text, sender)*/

        if (getType == ChatMessageType.PUBLICCHAT) {
            String senderName = getEvent.getName();

            // Remove any text within angle brackets and trim
            senderName = senderName.replaceAll("<[^>]+>", "").trim();

            if (senderName.contains(playerGameName)) {
                logger.info("You wrote: " + formattedMessage);
                return;
            }

            if (!senderName.contains(playerGameName)) {
                eAutoResponser.otherPlayerName = senderName;
                eAutoResponser.messageSaved = formattedMessage;
                logger.info("Player " + eAutoResponser.otherPlayerName + " wrote: " + eAutoResponser.messageSaved);
            }
        }

        if (getType == ChatMessageType.GAMEMESSAGE) {
            String gameMessage = getEvent.getMessage();
            if (gameMessage.contains("your ore goes onto the conveyor belt")) {
                status = "Ores are on conveyor belt!";
                oresOnConveyor = true;
            }
/*
            if (gameMessage.contains("You cut open the fish")) {
                status = "Roe has been made!";
                roeMade = true;
            }*/
        }

        if (getType == ChatMessageType.BROADCAST) {
            String broadcastMessage = getEvent.getMessage();
            String messageTrimmed = broadcastMessage.replaceAll("<[^>]+>", "").trim();
            if (messageTrimmed.contains("Trivia")) {
                logger.info(messageTrimmed);
                handleTriviaQuestion(messageTrimmed);
            }
        }

    }

    @Override
    public int loopDuration() {
        return 150;
    }

    @Override
    public void paint(Graphics g) {

        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(chosenSkill);
        long currentSkillExp = this.ctx.skills.experience(chosenSkill);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 205, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 205, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString("eBlastFurnaceBot by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString("Bars made: " + count + " (" + ctx.paint.valuePerHour(count, startTime) + " per/h)", 15, 210);
            g.drawString("Status: " + status, 15, 225);
        }
    }
}

'''
'''--- src/eCannonballBotZenyte/eMain.java ---
package eCannonballBotZenyte;

import BotUtils.eActions;
import BotUtils.eBanking;
import BotUtils.eData;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.*;

import java.awt.*;
import java.awt.event.KeyEvent;
import java.util.*;
import java.util.List;
import java.util.logging.Logger;

import static eApiAccess.eAutoResponser.*;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.SMITHING,
        description = "<html>"
                + "<p>The most effective cannonball maker bot on Zenyte!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>Start near any furnace & bank.</li>"
                + "<li>Make sure you have Ammo mould!</li>"
                + "<li>Chat GPT answering is integrated.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eCannonballBotZenyte",
        servers = {"Zenyte"},
        version = "0.1"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final String eBotName = "eCannonballBot";
    private static final String ePaintText = "Cannonballs made: ";
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.SMITHING;
    private static final Logger logger = Logger.getLogger(eAnglerFisherBot.eMain.class.getName());
    private static final String[] FURNACE_NAME = {"Furnace", "Clay forge"};
    private static final int STEEL_BAR = 2353;
    private static final int AMMO_MOULD = 4;

    // Variables
    private int count;
    private long lastAnimation = -1;
    private static eAutoResponderGui guiGpt;
    public static boolean hidePaint = false;
    private long startTime = 0L;
    private long startingSkillExp;
    private long startingSkillLevel;

    // Gui GPT
    private void initializeGptGui() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        BotUtils.eBanking bankingUtils = new eBanking(ctx);
        BotUtils.eActions actionUtils = new eActions(ctx);
        BotUtils.eData dataUtils = new eData(ctx);
        Utility.Trivia.eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx)));
        initializeMethods(); // BotUtils
        initializeGptGui(); // GPT
        eAutoResponser.scriptPurpose = "you're making cannonballs. ";
        gptDeactivation();

        // Other vars
        ctx.log("--------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " ---------------");
        ctx.log("-------------------------------------");
        ctx.log("            " + eBotName + "         ");
        ctx.log("-------------------------------------");

        // Vars
        BotUtils.eActions.updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        count = 0;
        ctx.viewport.angle(180);
        ctx.viewport.pitch(true);
        lastAnimation = System.currentTimeMillis();
        BotUtils.eActions.zoomOutViewport();
    }

    @Override
    public void onProcess() {
        super.onProcess();

        final SimplePlayer localPlayer = ctx.players.getLocal();

        if (!botStarted) {
            BotUtils.eActions.status = "Please start the bot!";
            return;
        }

        BotUtils.eActions.handleRunning();

        if (!BotUtils.eActions.hasItemsInInventory(eActions.StackableType.BOTH, AMMO_MOULD)) BotUtils.eBanking.bankTask(false, -1, -1, true, AMMO_MOULD, 1, -1);

        if (BotUtils.eActions.hasItemsInInventory(eActions.StackableType.BOTH, STEEL_BAR)) {
            if (localPlayer.getAnimation() == -1 && (BotUtils.eActions.getCurrentTimeMilli() > (lastAnimation + BotUtils.eActions.getRandomInt(3000, 4000)))) {
                useFurnace();
            } else if (localPlayer.getAnimation() != -1) {
                lastAnimation = BotUtils.eActions.getCurrentTimeMilli();
            }
        } else {
            BotUtils.eBanking.bankTask(false, -1, 1, true, STEEL_BAR, 27, AMMO_MOULD);
        }
    }

    // Making cannonballs
/*    private void useFurnace() {
        SimpleObject furnace = ctx.objects.populate().filter(FURNACE_NAME).next();
        SimpleWidget widget = ctx.widgets.getWidget(270, 14);

        if (BotUtils.eBanking.bankIsOpen()) ctx.bank.closeBank();

        if (widget == null) {
            if (furnace != null && furnace.validateInteractable()) {
                BotUtils.eActions.updateStatus("Clicking furnace");
                furnace.click("Smelt");
                WorldPoint playerLocation = ctx.players.getLocal().getLocation();
                WorldPoint furnaceLocation = furnace.getLocation();
                ctx.onCondition(() -> playerLocation.distanceTo(furnaceLocation) < 5, 250, 12);
            }
        } else {
            if (!widget.isHidden()) {
                BotUtils.eActions.updateStatus("Making cannonballs");
                widget.click(0);
                ctx.onCondition(() -> false, 250, 10);
                lastAnimation = BotUtils.eActions.getCurrentTimeMilli();
            }
        }
    }*/

    private void useFurnace() {
        SimpleObject furnace = ctx.objects.populate().filterHasAction("Smelt").nearest().next();

        if (BotUtils.eBanking.bankIsOpen()) ctx.bank.closeBank();

        if (furnace != null && furnace.validateInteractable()) {
            if (!furnace.visibleOnScreen()) {
                ctx.pathing.step(furnace.getLocation());
                ctx.onCondition(furnace::visibleOnScreen);
            }
            BotUtils.eActions.updateStatus("Clicking " + furnace.getName().toLowerCase());
            WorldPoint playerLocation = ctx.players.getLocal().getLocation();
            WorldPoint furnaceLocation = furnace.getLocation();
            furnace.click("Smelt", furnace.getName());
            ctx.onCondition(() -> playerLocation.distanceTo(furnaceLocation) < 5, 250, 12);
        }

        if (widgetVisible()) {
            int steelBarsCached = BotUtils.eActions.getItemCountInventory(STEEL_BAR);
            BotUtils.eActions.clickWidget(270, 14);
            ctx.onCondition(() -> steelBarsCached > BotUtils.eActions.getItemCountInventory(STEEL_BAR), 50, 20);
        }
    }

    private boolean widgetVisible() {
        SimpleWidget widgetToClick = ctx.widgets.getWidget(270, 14);

        if (widgetToClick == null) {
            return false;
        }
        ctx.keyboard.pressKey(KeyEvent.VK_SPACE);
        return true;
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log(ePaintText + ": " + count);
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        if (getType == ChatMessageType.SPAM) {
            String gameMessageTrimmed = gameMessage.replaceAll("<[^>]+>", "").trim();
            if (gameMessageTrimmed.contains("into your cannonball mould")) {
                count += 8;
            }
        }

        eApiAccess.eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        Utility.Trivia.eTriviaInfo.handleBroadcastMessage(getType, gameMessage);
    }

    @Override
    public int loopDuration() {
        return 150;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePaintText + ": " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + BotUtils.eActions.status, 15, 225);

        }
    }
}

'''
'''--- src/eChaosAltarBot/eGui.java ---
package eChaosAltarBot;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Objects;

public class eGui extends JFrame {

    private static final long serialVersionUID = 1L;
    private JPanel contentPane;
    public static JComboBox<String> minPlayersInArea;
    public static JComboBox<String> bonesName;
    private final JButton startButton;
    private final JButton pauseButton;
    private final JButton paintButton;

    public eGui() {
        setTitle("eChaosAltarBot");
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        setBounds(100, 100, 300, 150);
        contentPane = new JPanel();
        contentPane.setBackground(Color.DARK_GRAY);
        contentPane.setBorder(new EmptyBorder(5, 5, 5, 5));
        setContentPane(contentPane);
        contentPane.setLayout(null);

        ImageIcon eIcon = new ImageIcon(Objects.requireNonNull(getClass().getResource("esmaabi-icon.png")));
        setIconImage(eIcon.getImage());

        //Select location menu
        JLabel lblSelectLocation = new JLabel("Allowed players: ");
        lblSelectLocation.setForeground(Color.WHITE);
        lblSelectLocation.setBounds(10, 14, 100, 15);
        contentPane.add(lblSelectLocation);

        minPlayersInArea = new JComboBox<String>();
        minPlayersInArea.setModel(new DefaultComboBoxModel<String>(new String[] {"Only you", "You + 1", "You + 2", "You + 3", "Disable logout"}));
        minPlayersInArea.setBounds(110, 11, 150, 20);
        contentPane.add(minPlayersInArea);

        //Select logs menu
        JLabel lblSelectLogs = new JLabel("Select bones: ");
        lblSelectLogs.setForeground(Color.WHITE);
        lblSelectLogs.setBounds(10, 39, 100, 15);
        contentPane.add(lblSelectLogs);

        bonesName = new JComboBox<String>();
        bonesName.setModel(new DefaultComboBoxModel<String>(new String[] {
                "Infernal ashes",
                "Dragon bones",
                "Babydragon bones",
                "Big bones",
                "Normal bones",
                "Lava dragon bones",
                "Hydra bones",
                "Dagannoth bones",
                "Wyrm bones",
                "Wyvern bones",
                "Lava dragon bones",
                "Superior dragon bones",
                "Bat bones",
                "Ourg bones",
                "Abyssal ashes",
                "Malicious ashes",
                "Abyssal ashes",
                "Vile ashes",
                "Fiendish ashes"
        }));
        bonesName.setBounds(110, 36, 150, 20);
        contentPane.add(bonesName);

        //Start Button actions
        startButton = new JButton("Start");
        startButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent arg0) {

                eMain.botStarted = true;
                pauseButton.setVisible(true);
                startButton.setVisible(false);
                bonesName.setEnabled(false);
                minPlayersInArea.setEnabled(false);
                eMain.bonesName = Objects.requireNonNull(bonesName.getSelectedItem()).toString();
            }
        });
        startButton.setBounds(25, 74, 100, 23);
        contentPane.add(startButton);

        //Stop button actions
        pauseButton = new JButton("Pause");
        pauseButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {

                eMain.botStarted = false;
                pauseButton.setVisible(false);
                startButton.setVisible(true);
                bonesName.setEnabled(true);
                minPlayersInArea.setEnabled(true);
            }
        });
        pauseButton.setBounds(25, 74, 100, 23);
        contentPane.add(pauseButton);

        //Paint button actions
        paintButton = new JButton("Paint");
        paintButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent arg0) {
                eMain.hidePaint = !eMain.hidePaint;
            }
        });
        paintButton.setBounds(160, 74, 100, 23);
        contentPane.add(paintButton);
    }
}

'''
'''--- src/eChaosAltarBot/eMain.java ---
package eChaosAltarBot;

import BotUtils.eActions;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.script.Script;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.Objects;

@ScriptManifest(author = "Esmaabi", category = Category.PRAYER, description =
        "<br>Most effective Chaos Altar prayer training bot on Zenyte! <br><br>" +
                "<b>Features & recommendations:</b><br><br>" +
                "<ul>" +
                "<li>You must near Chaos Altar;</li>" +
                "<li>You must have noted / ashes with you and enough coins in inventory;</li>" +
                "<li>Bot supports variety of bones.</li>" +
                "<li>Bot will log out if out of bones or coins.</li>" +
                "<li>Bot will log out there are more than (chosen) players around</li>" +
                "</ul>", discord = "Esmaabi#5752",
        name = "eChaosAltarBotZenyte", servers = { "Zenyte" }, version = "0.5")

public class eMain extends Script{
    private static eGui gui;
    private long startTime = 0L;
    private long startingSkillLevel;
    private long startingSkillExp;
    private int count;
    private int currentExp;
    static String status = null;
    public static boolean botStarted = false;
    public static boolean hidePaint = false;
    public static boolean logOut = false;
    private long lastAnimation = -1;

    //Items
    public static String bonesName;

    //Locations
    private static final WorldArea chaosAltarArea = new WorldArea (
            new WorldPoint(2946, 3823, 0),
            new WorldPoint(2946, 3819, 0),
            new WorldPoint(2949, 3818, 0),
            new WorldPoint(2949, 3817, 0),
            new WorldPoint(2953, 3817, 0),
            new WorldPoint(2953, 3819, 0),
            new WorldPoint(2958, 3819, 0),
            new WorldPoint(2958, 3823, 0),
            new WorldPoint(2953, 3823, 0),
            new WorldPoint(2953, 3825, 0),
            new WorldPoint(2949, 3825, 0),
            new WorldPoint(2948, 3823, 0),
            new WorldPoint(2945, 3823, 0));
    private static String playerGameName;

    @Override
    public void onExecute() {
        System.out.println("Started eChaosAltarBot!");
        gui = new eGui();
        gui.setVisible(true);
        gui.setLocale(ctx.getClient().getCanvas().getLocale());
        ctx.viewport.pitch();
        ctx.viewport.angle(270);

        status = "Setting up bot";
        this.startTime = System.currentTimeMillis(); //paint
        this.startingSkillLevel = this.ctx.skills.realLevel(SimpleSkills.Skills.PRAYER);
        this.startingSkillExp = this.ctx.skills.experience(SimpleSkills.Skills.PRAYER);
        currentExp = this.ctx.skills.experience(SimpleSkills.Skills.PRAYER);// for actions counter by xp drop
        count = 0;
        botStarted = false;
        hidePaint = false;
        logOut = false;
        eActions.menuActionMode = true;
    }

    @Override
    public void onProcess() {

        if (botStarted) {

            if (currentExp != this.ctx.skills.experience(SimpleSkills.Skills.PRAYER)) { //action counter
                count++;
                currentExp = this.ctx.skills.experience(SimpleSkills.Skills.PRAYER);
            }

            logOut = getLogoutCount() > 0 ? true : false;

            if (logOut) {
                if (ctx.players.populate().population() > getLogoutCount()) {
                    status = "Logging out";
                    ctx.updateStatus("Logging out.");
                    ctx.updateStatus("Too many players!");
                    ctx.sendLogout();
                    ctx.sendLogout();
                }
            }

            if (ctx.inventory.populate().filter(bonesName).isEmpty() || ctx.inventory.populate().filter("Coins").isEmpty()) {
                status = "Logging out";
                ctx.updateStatus("Logging out.");
                ctx.updateStatus("Out of bones / coins!");
                ctx.sendLogout();
            }

            if (ctx.pathing.inArea(chaosAltarArea)) {

                if (ctx.inventory.populate().filter(bonesName).filter(i -> !i.isStackable()).population() != 0) {

                    if (spotReachable()) {
                        status = "Closing doors";
                        SimpleObject doors = ctx.objects.populate().filter("Large door").next();
                        if (doors != null && doors.validateInteractable()) {
                            BotUtils.eActions.interactWith(doors, "Open");
                            //doors.click("Open");
                            //ctx.sleepCondition(() -> !spotReachable(), 5000);
                            ctx.onCondition(() -> !spotReachable(), 250, 20);
                        }
                    }

                    if (ctx.players.getLocal().getAnimation() == -1 && (System.currentTimeMillis() > (lastAnimation + 3000))) {
                        sacrificeTask();
                    } else if (ctx.players.getLocal().getAnimation() != -1) {
                        lastAnimation = System.currentTimeMillis();
                    }

                } else {
                    if (!spotReachable()) {
                        status = "Opening doors";
                        SimpleObject doors = ctx.objects.populate().filter("Large door").next();
                        if (doors != null && doors.validateInteractable()) {
                            //doors.click("Open");
                            BotUtils.eActions.interactWith(doors, "Open");
                            //ctx.sleepCondition(() -> ctx.pathing.inMotion(), 5000);
                            ctx.onCondition(this::spotReachable, 250, 20);
                        }
                    } else {
                        if (!ctx.dialogue.dialogueOpen()) {
                            status = "Using bones on druid";
                            SimpleNpc druid = ctx.npcs.populate().filter("Elder Chaos druid").next();
                            SimpleItem bonesInventory = ctx.inventory.populate().filter(bonesName).filter(SimpleItem::isStackable).next();
                            if (druid != null && druid.validateInteractable() && bonesInventory != null && bonesInventory.validateInteractable()) {
                                bonesInventory.click("Use");
                                ctx.sleep(200);
                                //druid.click(0);
                                BotUtils.eActions.interactWith(druid, "Use");
                                //ctx.sleepCondition(() -> ctx.dialogue.dialogueOpen(), 8000);
                                ctx.onCondition(() -> ctx.dialogue.dialogueOpen(), 250, 20);
                            }
                        }
                    }
                }
            } else {
                if (ctx.dialogue.dialogueOpen()) {
                    status = "Progressing dialogue";
                    ctx.dialogue.clickDialogueOption(3);
                    int bonesInv = bonesPopulation();
                    ctx.onCondition(() -> bonesPopulation() > bonesInv, 250, 10);
                }

                if (ctx.inventory.populate().filter(bonesName).filter(i -> !i.isStackable()).population() != 0) {
                    status = "Walking back in church";
                    ctx.pathing.step(2956,3820);
                    //ctx.sleepCondition(() -> ctx.pathing.inMotion(), 2000);
                    ctx.onCondition(() -> ctx.pathing.inMotion(), 250, 10);
                }
            }
        }
    }

    private void sacrificeTask() {
        SimpleItem bonesInventory = ctx.inventory.populate().filter(bonesName).filter(i -> !i.isStackable()).reverse().next();
        SimpleObject chaosAltar = ctx.objects.populate().filter("Chaos altar").next();
        status = "Sacrificing task";
        if (bonesInventory != null && bonesInventory.validateInteractable() && chaosAltar != null && chaosAltar.validateInteractable()) {
            ctx.viewport.turnTo(chaosAltar);
            ctx.viewport.pitch();
            bonesInventory.click("Use");
            ctx.sleep(200);
            chaosAltar.click("Use");
            //BotUtils.eActions.interactWith(chaosAltar, String.valueOf(GAME_OBJECT_FIRST_OPTION));
            int bonesInv = bonesPopulation();
            ctx.onCondition(() -> bonesPopulation() < bonesInv, 250, 10);
        }
    }

    private int getLogoutCount() {
        String count = Objects.requireNonNull(eGui.minPlayersInArea.getSelectedItem()).toString();
        int minPlayers = -1;
        switch (count) {
            case "Disable logout":
                minPlayers = 0;
                break;
            case "Only you":
                minPlayers = 1;
                break;
            case "You + 1":
                minPlayers = 2;
                break;
            case "You + 2":
                minPlayers = 3;
                break;
            case "You + 3":
                minPlayers = 4;
                break;
        }
        return minPlayers;
    }

    private boolean spotReachable() {
        return ctx.pathing.reachable(new WorldPoint(2956, 3817, 0));
    }

    private int bonesPopulation() {
        return ctx.inventory.populate().filter(bonesName).population();
    }

    public static String getCurrentTimeFormatted() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    @Override
    public void onTerminate() {

        this.ctx.updateStatus("-------------- " + getCurrentTimeFormatted() + " --------------");
        this.ctx.updateStatus("We have sacrificed " + count + " bones/ashes.");
        this.ctx.updateStatus("-----------------------------------");
        this.ctx.updateStatus("----- Thank You & Good Luck! ------");
        this.ctx.updateStatus("-----------------------------------");

        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        status = "Stopping bot";
        gui.setVisible(false);
        hidePaint = true;
        bonesName = null;
        logOut = false;

    }

    @Override
    public void onChatMessage(ChatMessage m) {
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        playerGameName = eAutoResponser.getPlayerName(ctx);

        if (m.getMessage() == null) {
            return;
        }

        if (getType == ChatMessageType.PUBLICCHAT) {
            String senderName = getEvent.getName();

            // Remove any text within angle brackets and trim
            senderName = senderName.replaceAll("<[^>]+>", "").trim();

            if (senderName.contains(playerGameName)) {
                ctx.updateStatus(getCurrentTimeFormatted() + " Someone asked for you");
                ctx.updateStatus(getCurrentTimeFormatted() + " Stopping script");
                ctx.stopScript();
            }

        }
    }

    @Override
    public void paint(Graphics g) {
        long runTime = System.currentTimeMillis() - this.startTime;
        long currentSkillLevel = this.ctx.skills.realLevel(SimpleSkills.Skills.PRAYER);
        long currentSkillExp = this.ctx.skills.experience(SimpleSkills.Skills.PRAYER);
        long SkillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long SkillExpGained = currentSkillExp - this.startingSkillExp;
        long SkillExpPerHour = (int)((SkillExpGained * 3600000D) / runTime);
        long ActionsPerHour = (int) (count / ((System.currentTimeMillis() - this.startTime) / 3600000.0D));
        Color PhilippineRed = new Color(196, 18, 48);
        Color RaisinBlack = new Color(35, 31, 32, 127);
        if (!hidePaint) {
            g.setColor(RaisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);
            g.setColor(PhilippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);
            g.setColor(PhilippineRed);
            g.drawString("eChaosAltarBot by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + formatTime(runTime), 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + SkillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + SkillExpGained + " (" + (SkillExpPerHour / 1000L) + "k" + " xp/h)", 15, 195);
            g.drawString("Bones used: " + count + " (" + ActionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + status, 15, 225);
        }
    }

    private String formatTime(long ms) {
        long s = ms / 1000L;
        long m = s / 60L;
        long h = m / 60L;
        s %= 60L;
        m %= 60L;
        h %= 24L;
        return String.format("%02d:%02d:%02d", h, m, s);
    }

}

'''
'''--- src/eChatCatcherBot/eMain.java ---
package eChatCatcherBot;

import Utility.Trivia.eTriviaInfo;
import net.runelite.api.ChatMessageType;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;

import java.awt.*;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;

import static eApiAccess.eAutoResponser.randomSleeping;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.OTHER,
        description = "<html>"
                + "<p>The purpose of bot is to catch chat messages!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>Start anywhere.</li>"
                + "<li>Do anything.</li>"
                + "<li>Bot will catch only game messages & broadcasts.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eChatCatcherBot",
        servers = {"Zenyte"},
        version = "0.1"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static String playerGameName;
    private static final Logger logger = Logger.getLogger(eMain.class.getName());
    private FileWriter triviaQuestionsFileWriter;
    private FileWriter triviaAnswersFileWriter;
    private static final String TRIVIA_QUESTIONS_FILE_NAME = "trivia_questions.txt";
    private static final String TRIVIA_ANSWERS_FILE_NAME = "trivia_answers.txt";
    private static String triviaAnswer;

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList());// Adds tasks to our {task} list for execution

        triviaAnswer = null;

        // Other vars
        System.out.println("Started eChatCatcherBot!");
        this.ctx.updateStatus("--------------- " + getCurrentTimeFormatted() + " ---------------");
        this.ctx.updateStatus("------------------------------------");
        this.ctx.updateStatus("              eChatCatcherBot       ");
        this.ctx.updateStatus("------------------------------------");
    }

    @Override
    public void onProcess() {
        super.onProcess();

        try {
            triviaQuestionsFileWriter = new FileWriter(TRIVIA_QUESTIONS_FILE_NAME, true);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        try {
            triviaAnswersFileWriter = new FileWriter(TRIVIA_ANSWERS_FILE_NAME, true);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

    }

    // Utility
    public static String getCurrentTimeFormatted() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    public String getPlayerName() {
        if (playerGameName == null) {
            playerGameName = ctx.players.getLocal().getName();
        }
        return playerGameName;
    }

    private void updateStatus(String newStatus, String messageLocation) {
        ctx.updateStatus(getCurrentTimeFormatted() + " " + messageLocation + " was written down.");
        System.out.println(getCurrentTimeFormatted() + " " + messageLocation + " was written down. The message: " + newStatus);
    }

    private void printStatus(String newStatus) {
        ctx.updateStatus(newStatus);
        logger.info(newStatus);
    }

    // Trivia
    private void sendAnswer(String answer) {
        if (answer == null) {
            return;
        }

        if (ctx.dialogue.dialogueOpen()) {
            ctx.dialogue.clickContinue();
        }

        StringBuilder writeAnswer = new StringBuilder("::ans ");
        writeAnswer.append(answer);

        Thread thread = new Thread(() -> {
            try {
                int sleepTime = randomSleeping(5000, 10000);
                printStatus(getCurrentTimeFormatted() + " [Trivia] Sleeping for " + sleepTime + "ms");
                Thread.sleep(sleepTime); // Randomized delay
                ctx.keyboard.sendKeys(writeAnswer.toString());
                triviaAnswer = null;
                printStatus(getCurrentTimeFormatted() + " [Trivia] Question answered");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread.start();
    }

    private void handleTriviaQuestion(String gameMessageTrimmed) {
        for (eTriviaInfo.TriviaQuestion triviaQuestion : eTriviaInfo.TriviaQuestion.values()) {
            if (gameMessageTrimmed.contains(triviaQuestion.getQuestion())) {
                triviaAnswer = triviaQuestion.getAnswer();
                sendAnswer(triviaAnswer);
                break;
            }
        }
    }

    @Override
    public void onTerminate() {

        try {
            triviaQuestionsFileWriter.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        try {
            triviaAnswersFileWriter.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        // Other vars
        this.ctx.updateStatus("-------------- " + getCurrentTimeFormatted() + " --------------");
        this.ctx.updateStatus("----------------------");
        this.ctx.updateStatus("Thank You & Good Luck!");
        this.ctx.updateStatus("----------------------");
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        playerGameName = getPlayerName();

        if (m.getMessage() == null) {
            return;
        }

        String eventToStringTrimmed = getEvent.toString().replaceAll("<[^>]+>", "").trim();
        logger.info(eventToStringTrimmed); // to debug (returns chat type, text, sender)

        if (getType == ChatMessageType.BROADCAST) {
            String gameMessage = getEvent.getMessage();
            String gameMessageTrimmed = gameMessage.replaceAll("<[^>]+>", "").trim();
            if (gameMessageTrimmed.contains("Trivia")) {
                try {
                    triviaQuestionsFileWriter = new FileWriter(TRIVIA_QUESTIONS_FILE_NAME, true);
                    triviaQuestionsFileWriter.write(gameMessageTrimmed + System.lineSeparator());
                    triviaQuestionsFileWriter.flush();
                    updateStatus(gameMessageTrimmed, "BROADCAST");
                } catch (IOException e) {
                    throw new RuntimeException("Error writing trivia questions to file", e);
                } finally {
                    try {
                        triviaQuestionsFileWriter.close();
                    } catch (IOException e) {
                        // Handle the exception if closing the file writer fails
                        e.printStackTrace();
                    }
                }

                handleTriviaQuestion(gameMessageTrimmed);
            }
        }

        if (getType == ChatMessageType.GAMEMESSAGE || getType == ChatMessageType.SPAM) {
            String gameMessage = getEvent.getMessage();
            String gameMessageTrimmed = gameMessage.replaceAll("<[^>]+>", "").trim();
            if (gameMessageTrimmed.contains("Trivia")) {
                try {
                    triviaAnswersFileWriter = new FileWriter(TRIVIA_ANSWERS_FILE_NAME, true);
                    triviaAnswersFileWriter.write(gameMessageTrimmed + System.lineSeparator());
                    triviaAnswersFileWriter.flush();
                    updateStatus(gameMessageTrimmed, "GAMEMESSAGE");
                } catch (IOException e) {
                    throw new RuntimeException("Error writing trivia answers to file", e);
                } finally {
                    try {
                        triviaAnswersFileWriter.close();
                    } catch (IOException e) {
                        // Handle the exception if closing the file writer fails
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    @Override
    public int loopDuration() {
        return 150;
    }

    @Override
    public void paint(Graphics g) {

    }
}

'''
'''--- src/eChinHunterBotZenyte/eMain.java ---
package eChinHunterBotZenyte;

import BotUtils.*;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleInventory;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.queries.SimpleEntityQuery;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Pathing;
import simple.hooks.wrappers.*;

import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

import static eApiAccess.eAutoResponser.*;

@ScriptManifest(author = "Esmaabi", category = Category.HUNTER, description =
                "<br>The most effective chinchompa hunter bot on Zenyte!<br>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "Start <b>near any chinchompas</b>.<br>"
                + "Make sure that it's possible to set up box traps on all tiles.<br> "
                + "Have at least 5 box traps in inventory.<br>"
                + "Bot will decide how many traps to place.<br>"
                + "Chat GPT answering is integrated.",
        discord = "Esmaabi#5752",
        name = "eChinHunterBot", servers = { "Zenyte" }, version = "1")

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    public static eAutoResponderGui guiGpt;
    private static final SimpleSkills.Skills chosenSkill = SimpleSkills.Skills.HUNTER;
    private static final int BOX_TRAP_ITEM = 10008;
    private static final String eBotName = "eChinHunterBot";
    private static final String ePaintText = "Chins caught";

    // Variables related to game status
    private long startTime;
    private long startingSkillLevel;
    private long startingLevel;
    private long startingSkillExp;
    private int count;
    private int maxTraps = -1;
    private boolean calculated = false;
    private boolean trapsPickup = false;
    private static boolean hidePaint = false;

    // Variables related to location
    private WorldPoint[] locs;

    // Gui GPT
    public void initializeGptGUI() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        eBanking bankingUtils = new eBanking(ctx);
        eActions actionUtils = new eActions(ctx);
        eData dataUtils = new eData(ctx);
        eImpCatcher impCatcher = new eImpCatcher(ctx);
        eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eWildyTeleport(ctx), new eAutoResponser(ctx), new eImpCatcher(ctx)));

        // Setting up GPT Gui
        eAutoResponser.scriptPurpose = "you're just catching chinchompas.";
        eAutoResponser.gptStarted = false;
        initializeGptGUI();
        initializeMethods();
        gptDeactivation();

        // Starting message
        this.ctx.log("--------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " ---------------");
        this.ctx.log("-------------------------------------");
        this.ctx.log("            " + eBotName + "         ");
        this.ctx.log("-------------------------------------");

        // Variables
        ctx.log("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(chosenSkill);
        this.startingSkillExp = this.ctx.skills.experience(chosenSkill);
        startingLevel = startingSkillLevel;
        count = 0;

        // Viewport settings
        ctx.viewport.angle(0);
        ctx.viewport.pitch(true);
        ctx.viewport.yaw();

        // Traps setup tiles
        WorldPoint startingTile = ctx.players.getLocal().getLocation();
        int p = startingTile.getPlane();
        int[][] offsets = {{0, 0}, {1, 1}, {-1, 1}, {1, -1}, {-1, -1}};
        locs = new WorldPoint[offsets.length];
        for (int i = 0; i < offsets.length; i++) {
            int x = startingTile.getX() + offsets[i][0];
            int y = startingTile.getY() + offsets[i][1];
            locs[i] = new WorldPoint(x, y, p);
        }
    }

    @Override
    public void onProcess() {
        super.onProcess();

        SimplePlayer localPlayer = ctx.players.getLocal();
        Pathing pathing = ctx.pathing;

        if (!botStarted) {
            return;
        }

        if (localPlayer.getAnimation() != -1 || pathing.inMotion()) {
            return;
        }

        if (pathing.energyLevel() > 30 && !pathing.running() && pathing.inMotion()) {
            pathing.running(true);
        }

        int realLevel = this.ctx.skills.realLevel(chosenSkill);
        if (startingLevel < realLevel) {
            startingLevel = realLevel;
            calculated = false;
        }

        SimpleEntityQuery<SimpleGroundItem> groundItems = ctx.groundItems.populate().filter(BOX_TRAP_ITEM);
        if (!trapsPickup) {

            SimpleGroundItem floorTrap = groundItems.nearest().next();
            if (floorTrap != null && floorTrap.validateInteractable() && !localPlayer.isAnimating()) {
                BotUtils.eActions.status = "Laying trap";
                SimpleInventory invQuery = (SimpleInventory) ctx.inventory.populate().filter(BOX_TRAP_ITEM);
                int trapAmountCached = invQuery.population();
                changeCameraAngleOnThread(floorTrap);
                BotUtils.eActions.interactWith(floorTrap, "Lay");
                ctx.sleepCondition(() -> invQuery.population() > trapAmountCached, 2000);
                return;
            }

            WorldPoint trapTile = getAvailableTrapLocation();
            if (placedTraps() == trapAmount() && trapTile == null && floorTrap == null) {
                BotUtils.eActions.status = "Waiting for action";
                SimpleEntityQuery<SimpleObject> objects = ctx.objects.populate().filter(9382, 9383, 9385, 721).filterHasAction("Reset").filter(t -> objectInLocation(t.getLocation()));
                SimpleObject trap = objects.nearest().next();
                if (trap != null && trap.validateInteractable() && !localPlayer.isAnimating()) {
                    BotUtils.eActions.status = "Resetting traps";
                    int chinsCached = getChinCount();
                    BotUtils.eActions.interactWith(trap, "Reset");
                    ctx.sleep(3000);
                    if (trap.getName().equalsIgnoreCase("shaking box") && ctx.onCondition(() -> getChinCount() > chinsCached, 2400)) {
                        count += (getChinCount() - chinsCached);
                    }
                    ctx.sleepCondition(() -> trapExistsForTile(trap.getLocation()));
                }

            } else {

                BotUtils.eActions.status = "Checking traps in inventory";
                SimpleItem invTrap = ctx.inventory.populate().filter(BOX_TRAP_ITEM).next();

                if (invTrap == null || trapTile == null) {
                    return;
                }

                WorldPoint playerLocation = localPlayer.getLocation();
                if (!playerLocation.equals(trapTile)) {
                    BotUtils.eActions.status = "Walking to next spot";
                    stepOnTile(trapTile.getX(), trapTile.getY(), playerLocation);
                    ctx.onCondition(() -> true, 200, 8);
                }

                if (playerLocation.equals(trapTile)) {
                    BotUtils.eActions.status = "Setting up trap";
                    setupTrap(invTrap, trapTile);
                }
            }

        } else {

            if (!groundItems.isEmpty()) {
                if (!ctx.inventory.inventoryFull()) {
                    SimpleGroundItem trapsGround = groundItems.nearest().next();
                    BotUtils.eActions.status = "Picking up trap(s)";
                    int trapsInv = getTrapCountInv();
                    if (trapsGround != null && trapsGround.validateInteractable() && !localPlayer.isAnimating()) {
                        changeCameraAngleOnThread(trapsGround);
                        BotUtils.eActions.interactWith(trapsGround, "Take");
                        ctx.onCondition(() -> ctx.inventory.populate().filter("Box trap").population() > trapsInv);
                    }
                }
            } else {
                BotUtils.eActions.status = "No traps to pickup";
                trapsPickup = false;
            }
        }
    }

    private boolean objectInLocation(WorldPoint w) {
        for (WorldPoint loc : locs) {
            if (w.equals(loc)) {
                return true;
            }
        }
        return false;
    }

    public WorldPoint getAvailableTrapLocation() {
        for (int i = 0; i < trapAmount(); i++) {
            WorldPoint loc = locs[i];
            if (!trapExistsForTile(loc)) {
                return loc;
            }
        }
        return null;
    }

    // Functions
    private int trapAmount() {
        if (!calculated) {
            int level = ctx.skills.level(SimpleSkills.Skills.HUNTER);
            maxTraps = Math.min(level / 20 + 1, 5);
            ctx.log("You can place a maximum of " + maxTraps + " traps.");
            calculated = true;
        }
        return maxTraps;
    }

    private void setupTrap(final SimpleItem invTrap, final WorldPoint tile) {
        if (invTrap.click(1)) {
            ctx.onCondition(() -> this.trapExistsForTile(tile));
        }
    }

    private boolean trapExistsForTile(final WorldPoint tile) {
        return !ctx.objects.populate().filter(9380, 9382, 9383, 9385, 9384, 2025, 2026, 2028, 721, 9392, 9393, 9390).filter(tile).isEmpty();
    }

    private int placedTraps() {
        int count = 0;
        for (int i = 0; i < trapAmount(); i++) {
            WorldPoint loc = locs[i];
            if (trapExistsForTile(loc)) {
                count++;
            }
        }
        return count;
    }

    private void stepOnTile(int x, int y, WorldPoint playerLocation) {
        WorldPoint NEXT_TILE = new WorldPoint(x, y, 0);
        if (playerLocation.distanceTo(NEXT_TILE) >= 6) {
            ctx.pathing.step(NEXT_TILE);
        } else {
            ctx.pathing.clickSceneTile(NEXT_TILE, false, true);
        }
    }

    // Getting info
    private int getGainedChins() {
        return count;
    }

    private int getChinCount() {
        return ctx.inventory.populate().filter("chinchompa", "red chinchompa", "black chinchompa").population(true);
    }

    private int getTrapCountInv() {
        return ctx.inventory.populate().filter("Box trap").population();
    }

    private void changeCameraAngleOnThread(SimpleGroundItem object) {
        // Create a ScheduledExecutorService with a single thread
        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();

        // Turn to desired object
        ctx.viewport.turnTo(object);

        // Get the current camera orientation angle
        int currentAngle = ctx.viewport.yaw();

        // Generating a random number between 0 and 30
        int angleChange = randomSleeping(0, 30);

        // Getting the sign of the angle change based on the current angle
        if (currentAngle >= 329 || currentAngle <= 30) {
            angleChange = -angleChange; // Make the angle change negative for 329-359 and 0-30 range
        }

        // Calculating the new camera angle by adding the angle change
        int newAngle = (currentAngle + angleChange) % 360;

        // Setting the new camera angle
        ctx.viewport.angle(newAngle);

        // Shutting down the executor
        executor.shutdown();
    }

    private enum EntityType {
        SimpleObjects, SimpleGroundItem
    }

    private boolean trapWithAction(EntityType entityType, WorldPoint tile, String action) {
        switch (entityType) {
            case SimpleObjects:
                return !ctx.objects.populate()
                        .filter(tile)
                        .filterHasAction(action)
                        .isEmpty();
            case SimpleGroundItem:
                return !ctx.groundItems.populate()
                        .filter(tile)
                        .filterHasAction(action)
                        .isEmpty();
            default:
                return false;
        }
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log(ePaintText + ": " + getGainedChins());
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        startingSkillLevel = 0L;
        startingSkillExp = 0L;
        count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();

    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        if (gptStarted && botStarted) eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        Utility.Trivia.eTriviaInfo.handleBroadcastMessage(getType, gameMessage);

/*        String eventToString = getEvent.toString().replaceAll("<[^>]+>", "").trim();
        logger.info(eventToString); // to debug (returns chat type, text, sender)*/

        if (getType == ChatMessageType.GAMEMESSAGE) {
            if (gameMessage.contains("You cannot lay a trap here")) {
                BotUtils.eActions.status = "Can't lay here!";
                trapsPickup = true;
            }

            if (gameMessage.contains("traps at a time at your Hunter level")) {
                BotUtils.eActions.status = "Can't lay here!";
                trapsPickup = true;
            }
        }

    }

    @Override
    public int loopDuration() {
        return 150;
    }

    @Override
    public void paint(Graphics g) {

        // Check each trap location
        if (locs != null) {
            for (WorldPoint trapTile : locs) {
                if (trapTile != null) {
                    if (trapWithAction(EntityType.SimpleGroundItem, trapTile, "Take")) {
                        BotUtils.eActions.drawTileMatrix(ctx, (Graphics2D) g, trapTile, Color.RED);
                    } else if (trapWithAction(EntityType.SimpleObjects,trapTile, "Reset")) {
                        BotUtils.eActions.drawTileMatrix(ctx, (Graphics2D) g, trapTile, Color.GREEN);
                    } else if (trapWithAction(EntityType.SimpleGroundItem, trapTile, "Lay")) {
                        BotUtils.eActions.drawTileMatrix(ctx, (Graphics2D) g, trapTile, Color.GREEN);
                    } else if (trapWithAction(EntityType.SimpleObjects, trapTile, "Dismantle")) {
                        BotUtils.eActions.drawTileMatrix(ctx, (Graphics2D) g, trapTile, Color.YELLOW);
                    } else {
                        BotUtils.eActions.drawTileMatrix(ctx, (Graphics2D) g, trapTile, Color.DARK_GRAY);
                    }
                }
            }
        }

        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(chosenSkill);
        long currentSkillExp = this.ctx.skills.experience(chosenSkill);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 205, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 205, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePaintText + ": " + count + " (" + ctx.paint.valuePerHour(count, startTime) + " per/h)", 15, 210);
            g.drawString("Status: " + BotUtils.eActions.status, 15, 225);
        }
    }
}

'''
'''--- src/eCrystalHustlerZenyte/eGui.java ---
package eCrystalHustlerZenyte;

import javax.swing.*;
import java.awt.*;
import java.util.Objects;

public class eGui extends JFrame {
    public static final String[] ACTION = {"Woodcutting", "Mining"};
    private JComboBox<String> actionComboBox;
    private JCheckBox useSpecialAttack;
    private JButton startButton;
    private JButton pauseButton;

    public eGui() {
        setTitle("eCrystalHustler");
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        setLocationRelativeTo(null);
        setIconImage(new ImageIcon(Objects.requireNonNull(getClass().getResource("esmaabi-icon.png"))).getImage());

        initGUI();

        pack();
    }

    private void initGUI() {
        JPanel contentPane = new JPanel(new GridBagLayout());
        contentPane.setBackground(Color.DARK_GRAY);
        setContentPane(contentPane);

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.insets = new Insets(5, 5, 5, 5);

        // Add title
        constraints.gridy = 0;
        constraints.gridx = 0;
        constraints.gridwidth = 2;
        constraints.anchor = GridBagConstraints.CENTER;
        addLabel("Please choose options below!", contentPane, constraints, true);

        constraints.gridwidth = 1; // Resetting gridwidth
        constraints.anchor = GridBagConstraints.WEST; // Resetting anchor

        constraints.gridy++; // Moving to next row
        constraints.gridx = 0; // Resetting x-axis position to 0

        // Wood type
        addLabel("Select action: ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        actionComboBox = addComboBox(contentPane, constraints);
        actionComboBox.setPreferredSize(new Dimension(150, actionComboBox.getPreferredSize().height));

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row

        // Stamina potions
        addLabel("Use special attack? ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        useSpecialAttack = addCheckBox(contentPane, constraints);

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row
        constraints.gridwidth = 2; // Resetting gridwidth
        constraints.anchor = GridBagConstraints.CENTER; // Resetting anchor

        // Start and Pause buttons
        JPanel buttonsPanel = new JPanel(new GridLayout(1, 2, 5, 0));
        startButton = new JButton("Start");
        startButton.addActionListener(e -> startBot());
        startButton.setBackground(Color.GREEN);
        buttonsPanel.add(startButton);
        pauseButton = new JButton("Pause");
        pauseButton.addActionListener(e -> pauseBot());
        pauseButton.setVisible(false); // Setting button invisible
        pauseButton.setBackground(Color.RED);
        buttonsPanel.add(pauseButton);
        contentPane.add(buttonsPanel, constraints);
    }

    private void addLabel(String text, Container container, GridBagConstraints constraints, boolean isTitle) {
        JLabel label = new JLabel(text);
        label.setForeground(Color.WHITE);
        if (isTitle) {
            label.setFont(label.getFont().deriveFont(Font.BOLD, 16));
        }
        container.add(label, constraints);
        constraints.gridx++;
    }

    private JComboBox<String> addComboBox(Container container, GridBagConstraints constraints) {
        JComboBox<String> comboBox = new JComboBox<>(eGui.ACTION);
        container.add(comboBox, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
        return comboBox;
    }

    private void startBot() {
        eMain.botStarted = true;
        pauseButton.setVisible(true);
        startButton.setVisible(false);
        actionComboBox.setEnabled(false);
        useSpecialAttack.setEnabled(false);
        eMain.specialAttackActive = useSpecialAttack.isSelected();
        getSelectedAction();

        if (!eMain.specialAttackTool) {
            useSpecialAttack.setEnabled(true);
            useSpecialAttack.setSelected(false);
            useSpecialAttack.setEnabled(false);
        }
    }

    private void pauseBot() {
        eMain.botStarted = false;
        pauseButton.setVisible(false);
        startButton.setVisible(true);
        useSpecialAttack.setEnabled(true);
        actionComboBox.setEnabled(true);

        if (!eMain.specialAttackTool) {
            useSpecialAttack.setEnabled(true);
            useSpecialAttack.setSelected(false);
        }
    }

    private JCheckBox addCheckBox(Container container, GridBagConstraints constraints) {
        JCheckBox checkBox = new JCheckBox();
        container.add(checkBox, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
        return checkBox;
    }

    private void getSelectedAction() {
        String selectedAction = (String) actionComboBox.getSelectedItem();
        if (Objects.equals(selectedAction, "Woodcutting")) {
            eMain.woodcuttingAction = true;
            eMain.miningAction = false;
        } else if (Objects.equals(selectedAction, "Mining")) {
            eMain.miningAction = true;
            eMain.woodcuttingAction = false;
        }
    }
}

'''
'''--- src/eCrystalHustlerZenyte/eMain.java ---
package eCrystalHustlerZenyte;

import eRandomEventSolver.eRandomEventForester;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleGroundItems;
import simple.hooks.filters.SimpleInventory;
import simple.hooks.filters.SimpleObjects;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Game;
import simple.hooks.simplebot.Pathing;
import simple.hooks.wrappers.*;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.*;
import java.util.logging.Logger;

@ScriptManifest(author = "Esmaabi", category = Category.OTHER, description =
        "<br>This bot will gather crystal shards for you so you don't have to! <br><br><b>Features & recommendations:</b><br><br>" +
        "<ul>" +
        "<li>Bot will chop or mine Crystal shards;</li>" +
        "<li>You must start at Crystal Mine or near Crystal trees;</li>" +
        "<li>If you use Dragon tools you can also use special attack;</li>" +
        "<li>Bot will pick up bird nests, but will not bank them;</li>" +
        "<li>The bot will stop if trees / rocks not found.</li></ul><br>" +
        "For more information, check out Esmaabi on SimpleBot!", discord = "Esmaabi#5752",
        name = "eCrystalHustlerZenyte", servers = { "Zenyte" }, version = "1")

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private final static int INVENTORY_BAG_WIDGET_ID = 548;
    private final static int INVENTORY_BAG_CHILD_ID = 58;
    private final static int CRYSTAL_SHARD = 30560;
    private static final String BIRD_NEST = "Bird nest";
    private static final String CRYSTAL_TREE = "Crystal Tree";
    private static final String CRYSTAL_ROCK = "Crystalized Rock";
    private static final Set<String> SPECIAL_ATTACK_TOOL = new HashSet<>(
            Arrays.asList(
                    "Dragon pickaxe (or)",
                    "Dragon pickaxe",
                    "Dragon pickaxe (or) (Trailblazer)",
                    "Dragon pickaxe (upgraded)",
                    "Infernal pickaxe",
                    "Dragon axe (or)",
                    "Infernal axe",
                    "Dragon axe"
            ));
    private final WorldPoint DEPOSIT_BOX_LOCATION = new WorldPoint(0, 0, 0);
    private final WorldArea homeArea = new WorldArea(new WorldPoint(3101, 3181, 0), new WorldPoint(3074, 3504, 0));

    // Variables
    private static eGui gui;
    private static final Logger logger = Logger.getLogger(eMain.class.getName());
    private long startTime = 0L;
    private int count;
    private int cachedCount;
    private boolean countActive;
    static String status = null;
    public static boolean botStarted = false;
    public static boolean hidePaint = false;
    public static boolean specialAttackActive;
    public static boolean specialAttackTool = true;
    public static boolean woodcuttingAction;
    public static boolean miningAction;
    private static String playerGameName;

    @Override
    public int loopDuration() {
        return 150;
    }

    // Gui
    private void initializeGUI() {
        gui = new eGui();
        gui.setVisible(true);
        gui.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    //Tasks
    List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {
        tasks.addAll(Arrays.asList());
        System.out.println("Started eCrystalHustler!");
        this.startTime = System.currentTimeMillis(); //paint
        ctx.viewport.angle(90);
        ctx.viewport.pitch(true);
        initializeGUI();

        this.ctx.updateStatus("-------------------------------------");
        this.ctx.updateStatus("--------------- " + currentTime() + " ---------------");
        this.ctx.updateStatus("-------------------------------------");
        status = "Setting up bot";
        count = 0;
        botStarted = false;
        hidePaint = false;
        specialAttackActive = false;
        woodcuttingAction = false;
        miningAction = false;
        countActive = false;
    }

    @Override
    public void onProcess() {
        super.onProcess();

        if (botStarted) {

            SimplePlayer localPlayer = ctx.players.getLocal();
            Pathing pathing = ctx.pathing;

            int currentCount = getStackSize(CRYSTAL_SHARD);
            handleCount(currentCount);

            if (woodcuttingAction) {
                if (!localPlayer.isAnimating() && !pathing.inMotion()) {
                    cuttingCrystalTree(localPlayer);
                }

                if (!ctx.inventory.inventoryFull()) {
                    birdNests();
                }
            } else if (miningAction) {
                if (!localPlayer.isAnimating() && !pathing.inMotion()) {
                    miningCrystals(localPlayer);
                }

                if (localPlayer.getHealth() <= 40) {
                    handleEating(localPlayer);
                }
            }

            if (localPlayer.isAnimating()) {
                if (specialAttackActive) {
                    specialAttack(localPlayer);
                }
            }

        } else {
            status = "Start the bot";
        }
    }

    private void cuttingCrystalTree(SimplePlayer localPlayer) {
        SimpleObjects crystalTrees = (SimpleObjects) ctx.objects.populate().filter(CRYSTAL_TREE);
        SimpleObject nearestCrystalTree = crystalTrees.nearest().next();

        if (nearestCrystalTree != null && nearestCrystalTree.validateInteractable()) {
            updateStatus("Nearest tree found " + (nearestCrystalTree.getLocation().distanceTo(ctx.players.getLocal().getLocation()) - 1) + " tile(s) away");
            updateStatus("Clicking" + CRYSTAL_TREE.toLowerCase());
            nearestCrystalTree.click("Chop down");
            status = "Chopping tree...";
            ctx.onCondition(localPlayer::isAnimating, 250, 10);
        }
    }

    private void miningCrystals(SimplePlayer localPlayer) {
        SimpleObjects crystalRocks = (SimpleObjects) ctx.objects.populate().filter(CRYSTAL_ROCK);
        SimpleObject nearestCrystalrock = crystalRocks.nearest().next();

        if (nearestCrystalrock != null && nearestCrystalrock.validateInteractable()) {
            updateStatus("Nearest rock found " + (nearestCrystalrock.getLocation().distanceTo(ctx.players.getLocal().getLocation())) + " tile(s) away");
            updateStatus("Clicking " + CRYSTAL_ROCK.toLowerCase());
            nearestCrystalrock.click("Mine");
            status = "Mining rock...";
            ctx.onCondition(localPlayer::isAnimating, 250, 10);
        }
    }

    private void birdNests() {
        SimpleGroundItems birdNests = (SimpleGroundItems) ctx.groundItems.populate().filter(BIRD_NEST);

        if (!birdNests.isEmpty()) {
            SimpleGroundItem nearestBirdNest = birdNests.nearest().next();

            if (nearestBirdNest != null && nearestBirdNest.validateInteractable()) {
                updateStatus("Picking up bird nest");
                nearestBirdNest.click("Take");
                ctx.onCondition(birdNests::isEmpty, 250, 10);
            }
        }
    }

    private void handleEating(SimplePlayer localPlayer) {
        SimpleInventory foodItems = (SimpleInventory) ctx.inventory.populate().filterHasAction("Eat");
        SimpleItem foodInv = foodItems.next();
        final int cachedHealth = localPlayer.getHealth();

        if (foodInv == null) {
            updateStatus("Food not found");
            teleHome();
            return;
        }

        updateStatus("Restoring hitpoints");
        if (foodInv.click("Eat")) {
            ctx.onCondition(() -> localPlayer.getHealth() > cachedHealth, 250, 12);
        }
    }

    private void specialAttack(SimplePlayer localPlayer) {
        int specialAttackPercentage = ctx.combat.getSpecialAttackPercentage();

        if (specialAttackPercentage != 100) {
            return;
        }

        boolean hasSpecialAttackTool = !ctx.equipment.populate()
                .filter(item -> SPECIAL_ATTACK_TOOL.contains(item.getName()))
                .isEmpty();

        if (!hasSpecialAttackTool) {
            updateStatus("Special attack tool: NOT FOUND");
            updateStatus("Special attack: Deactivated");
            specialAttackTool = false;
            specialAttackActive = false;
            return;
        }

        if (localPlayer.isAnimating() && ctx.combat.toggleSpecialAttack(true)) {
            ctx.game.tab(Game.Tab.INVENTORY);
        }
    }

    private void teleHome() {
        if (!ctx.pathing.inArea(homeArea)) {
            ctx.keyboard.sendKeys("::home");
            ctx.sleep(4000);
        }
    }

    private void clickOnBag() {
        SimpleWidget inventoryBagWidget = ctx.widgets.getWidget(INVENTORY_BAG_WIDGET_ID, INVENTORY_BAG_CHILD_ID);
        if (inventoryBagWidget != null) {
            inventoryBagWidget.click(0);
        }
    }

    private void handleCount(int currentCount) {
        if (!countActive) {
            if (count == 0) {
                cachedCount = currentCount;
                countActive = true;
            }
        } else {
            count += (currentCount - cachedCount);
            cachedCount = currentCount;
        }
    }

    private int getStackSize(int itemId) {
        return ctx.inventory.populate().filter(itemId).population(true);
    }

    private void updateStatus(String newStatus) {
        status = newStatus;
        ctx.updateStatus(status);
        logger.info(status);
    }

    public String getPlayerName() {
        if (playerGameName == null) {
            playerGameName = ctx.players.getLocal().getName();
        }
        return playerGameName;
    }

    public static String currentTime() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    @Override
    public void onTerminate() {
        status = "Stopping bot";
        gui.setVisible(false);
        hidePaint = true;
        woodcuttingAction = false;
        miningAction = false;
        specialAttackActive = false;

        this.ctx.updateStatus("-------------------------------------");
        this.ctx.updateStatus("--------------- " + currentTime() + " ---------------");
        this.ctx.updateStatus("-------------------------------------");
        this.ctx.updateStatus("------- Thank You & Good Luck! -------");
        this.ctx.updateStatus("-------------------------------------");
        this.ctx.updateStatus("Crystals acquired: " + count);
        this.ctx.updateStatus("-------------------------------------");
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        playerGameName = getPlayerName();

        if (m.getMessage() == null) {
            return;
        }

        if (getType == ChatMessageType.PUBLICCHAT) {
            String senderName = getEvent.getName();

            // Remove any text within angle brackets and trim
            senderName = senderName.replaceAll("<[^>]+>", "").trim();

            if (senderName.contains(playerGameName)) {
                ctx.updateStatus(currentTime() + " Someone asked for you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }

        }
    }

    @Override
    public void paint(Graphics g) {

        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);

        // Calculate experience and actions per hour
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            Graphics2D g2d = (Graphics2D) g;
            GradientPaint gradientPaint = new GradientPaint(5, 120, raisinBlack, 220, 230, philippineRed, true);
            g2d.setPaint(gradientPaint);
            g.fillRoundRect(5, 120, 200, 85, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 85, 20, 20);

            Font title = new Font("Arial", Font.BOLD, 12);
            Font text = new Font("Arial", Font.PLAIN, 11);

            g.setFont(title);
            g.setColor(Color.WHITE);
            g.drawString("eCrystalHustler by Esmaabi", 15, 140);

            g.setFont(text);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 160);
            g.drawString("Crystals acquired: " + count + " (" + actionsPerHour + " per/h)", 15, 175);
            g.drawString("Status: " + status, 15, 190);
        }
    }
}

'''
'''--- src/eFiremakingBotZenyte/eGui.java ---
package eFiremakingBotZenyte;

import simple.robot.api.ClientContext;

import javax.swing.*;
import java.awt.*;
import java.util.Objects;

public class eGui extends JFrame {
    private static ClientContext ctx;

    public eGui(ClientContext ctx) {
        eGui.ctx = ctx;
    }

    private static final long serialVersionUID = 1L;
    private static final String[] LOCATIONS = {"Falador East", "Varrock East", "Grand Exchange"};
    private static final String[] LOGS = {
            "Redwood logs", "Magic logs", "Yew logs",
            "Maple logs", "Willow logs", "Oak logs", "Logs"
    };

    private JComboBox<String> locationComboBox;
    private static JComboBox<String> logsComboBox;
    private JButton startButton;
    private JButton pauseButton;

    public eGui() {
        setTitle("eFiremakingBot");
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        setLocationRelativeTo(null);
        setIconImage(new ImageIcon(Objects.requireNonNull(getClass().getResource("esmaabi-icon.png"))).getImage());

        initGUI();

        pack();
    }

    private void initGUI() {
        JPanel contentPane = new JPanel(new GridBagLayout());
        contentPane.setBackground(Color.DARK_GRAY);
        setContentPane(contentPane);

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.insets = new Insets(5, 5, 5, 5);

        // Add title
        constraints.gridy = 0;
        constraints.gridx = 0;
        constraints.gridwidth = 2;
        constraints.anchor = GridBagConstraints.CENTER;
        addLabel("Please choose options below!", contentPane, constraints, true);

        constraints.gridwidth = 1; // Resetting gridwidth
        constraints.anchor = GridBagConstraints.WEST; // Resetting anchor

        constraints.gridy++; // Moving to next row
        constraints.gridx = 0; // Resetting x-axis position to 0

        // Select location
        addLabel("Select Location: ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        locationComboBox = addComboBox(LOCATIONS, contentPane, constraints);
        locationComboBox.setPreferredSize(new Dimension(150, locationComboBox.getPreferredSize().height));
        locationComboBox.setToolTipText("Choose firemaking location. Start near bank.");

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row

        // Select logs
        addLabel("Select Logs: ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        logsComboBox = addComboBox(LOGS, contentPane, constraints);
        logsComboBox.setPreferredSize(new Dimension(150, logsComboBox.getPreferredSize().height));
        logsComboBox.setToolTipText("Choose logs you want to burn.");

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row
        constraints.gridwidth = 2; // Resetting gridwidth
        constraints.anchor = GridBagConstraints.CENTER; // Resetting anchor

        // Start and Pause buttons
        JPanel buttonsPanel = new JPanel(new GridLayout(1, 2, 5, 0));
        startButton = new JButton("Start");
        startButton.addActionListener(e -> startBot());
        startButton.setBackground(Color.GREEN);
        buttonsPanel.add(startButton);
        pauseButton = new JButton("Pause");
        pauseButton.addActionListener(e -> pauseBot());
        pauseButton.setVisible(false); // Setting button invisible
        pauseButton.setBackground(Color.RED);
        buttonsPanel.add(pauseButton);
        contentPane.add(buttonsPanel, constraints);
    }

    private void addLabel(String text, Container container, GridBagConstraints constraints, boolean isTitle) {
        JLabel label = new JLabel(text);
        label.setForeground(Color.WHITE);
        if (isTitle) {
            label.setFont(label.getFont().deriveFont(Font.BOLD, 16));
        }
        container.add(label, constraints);
        constraints.gridx++;
    }

    private JComboBox<String> addComboBox(String[] items, Container container, GridBagConstraints constraints) {
        JComboBox<String> comboBox = new JComboBox<>(items);
        container.add(comboBox, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
        return comboBox;
    }

    private void startBot() {
        eMain.botStarted = true;
        pauseButton.setVisible(true);
        startButton.setVisible(false);
        logsComboBox.setEnabled(false);
        locationComboBox.setEnabled(false);
    }

    private void pauseBot() {
        eMain.botStarted = false;
        pauseButton.setVisible(false);
        startButton.setVisible(true);
        logsComboBox.setEnabled(true);
        locationComboBox.setEnabled(true);
    }

    public JComboBox<String> getLocationComboBox() {
        return locationComboBox;
    }

    public static String getLogsComboBox() {
        return Objects.requireNonNull(logsComboBox.getSelectedItem()).toString();
    }
}
'''
'''--- src/eFiremakingBotZenyte/eMain.java ---
package eFiremakingBotZenyte;

import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleBank;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.*;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.List;

@ScriptManifest(author = "Esmaabi", category = Category.FIREMAKING, description =
        "<br>Most effective firemaking bot on Zenyte! <br><br><b>Features & recommendations:</b><br><br>" +
        "<ul>" +
        "<li>You must start near chosen bank!;</li>" +
        "<li>Supported locations: Falador East, Varrock East, Grand Exchange</li>" +
        "<li>Supported trees: all normal trees from redwood to logs.</li></ul>", discord = "Esmaabi#5752",
        name = "eFiremakingBotZenyte", servers = { "Zenyte" }, version = "3")

public class eMain extends TaskScript implements LoopingScript {

    // Constants - Names
    private static final String eBotName = "eFiremakingBot";
    private static final String ePaintText = "Logs used";
    static String bankName = "Banker";
    static String bankOpen = "Bank";
    static String tinderBox = "Tinderbox";
    private static String playerGameName;

    // Constants - Locations
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.FIREMAKING;
    private WorldPoint START_TILE;
    private final static int INVENTORY_BAG_WIDGET_ID = 548;
    private final static int INVENTORY_BAG_CHILD_ID = 58;
    private final WorldPoint NEAR_BANK_LOC_VARROCK = new WorldPoint(3254, 3426, 0);
    private final WorldPoint NEAR_BANK_LOC_FALADOR = new WorldPoint(3012, 3360, 0);
    private final WorldPoint NEAR_BANK_LOC_GE = new WorldPoint(3164, 3487, 0);
    private static final WorldPoint[] PATH_FALADOR_EAST = new WorldPoint[] {
            new WorldPoint(3025, 3361, 0),
            new WorldPoint(3025, 3362, 0),
            new WorldPoint(3025, 3363, 0)
    };
    private static final WorldPoint[] PATH_VARROCK_EAST = new WorldPoint[] {
            new WorldPoint(3266, 3428, 0),
            new WorldPoint(3266, 3429, 0),
            new WorldPoint(3266, 3430, 0)
    };
    private static final WorldPoint[] PATH_GRAND_EXCHANGE = new WorldPoint[] {
            new WorldPoint(3177, 3478, 0),
            new WorldPoint(3177, 3477, 0),
            new WorldPoint(3177, 3476, 0)
    };

    // Variables
    public static boolean botStarted = false;
    private int count;
    private int counter;
    private int currentExp;
    private boolean firemakingStarted;
    private static eGui gui;
    public static boolean hidePaint = false;
    public static boolean firstInventory;
    private int locationsTried = 0;
    private long startTime = 0L;
    private long startingSkillExp;
    private long startingSkillLevel;
    private static String status;

    @Override
    public int loopDuration() {
        return 150;
    }

    public enum FiremakingLocations {
        FALADOR_EAST(PATH_FALADOR_EAST),
        VARROCK_EAST(PATH_VARROCK_EAST),
        GRAND_EXCHANGE(PATH_GRAND_EXCHANGE);

        private final WorldPoint[] path;

        FiremakingLocations(WorldPoint[] path) {
            this.path = path;
        }

        public WorldPoint[] getPath() {
            return path;
        }
    }

    private void initializeGUI() {
        gui = new eGui();
        gui.setVisible(true);
        gui.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    //Tasks
    List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {
        tasks.addAll(Arrays.asList());
        adjustViewportForFiremaking();
        initializeGUI();

        ctx.log("-------------------------------------");
        ctx.log("            " + eBotName + "         ");
        ctx.log("-------------------------------------");

        status = "Setting up bot";
        this.startTime = System.currentTimeMillis(); //paint
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        currentExp = this.ctx.skills.experience(CHOSEN_SKILL);// for actions counter by xp drop
        count = 0;
        counter = 0;
        firemakingStarted = false;
        botStarted = false;
        hidePaint = false;
        firstInventory = true;

        // Getting FM starting tile from GUI selection
        WorldPoint[] locationPaths = getSelectedLocationPaths(gui);
        START_TILE = locationPaths[0];
    }

    @Override
    public void onProcess() {
        super.onProcess();

        if (botStarted) {

            if (ctx.pathing.energyLevel() > 30 && !ctx.pathing.running()) {
                ctx.pathing.running(true);
            }

            updateExperienceAndCount();

            WorldPoint[] availableLocations = getSelectedLocationPaths(gui);

            if (!firemakingStarted) {
                if (!logsInInventory() || firstInventory) {
                    bankTask();
                }
                adjustViewportForFiremaking();
                findAvailableFireSpot(availableLocations);
                handleFiremakingStart();
            } else {
                if (logsInInventory()) {
                    lightFire();
                } else if (playerIsIdle()) {
                    bankTask();
                }
            }
        }
    }

    //
    private void findAvailableFireSpot(WorldPoint[] locations) {
        SimpleObject fireOngoing = getFireAtLocation(START_TILE);

        while (fireOngoing != null && locationsTried < locations.length) {
            handleFireLightingLoc();
            fireOngoing = getFireAtLocation(START_TILE);
        }

        if (locationsTried >= locations.length && fireOngoing != null) {
            waitForAvailableSpot(locations);
        }
    }

    private SimpleObject getFireAtLocation(WorldPoint location) {
        return ctx.objects.populate()
                .filter(o -> o.getLocation().equals(location))
                .filter("Fire").next();
    }

    private void waitForAvailableSpot(WorldPoint[] locations) {
        ctx.onCondition(() -> {
            for (WorldPoint point : locations) {
                if (getFireAtLocation(point) == null) {
                    START_TILE = point;
                    locationsTried = 0;
                    return true;
                }
            }
            return false;
        });
    }

    private void handleFiremakingStart() {
        SimplePlayer localPlayer = ctx.players.getLocal();
        if (localPlayer.getLocation().equals(START_TILE)) {
            firemakingStarted = true;
        } else {
            moveToStartTile();
        }
    }

    private void moveToStartTile() {
        SimplePlayer localPlayer = ctx.players.getLocal();
        final int DISTANCE_THRESHOLD = 3;
        if (localPlayer.getLocation().distanceTo(START_TILE) > DISTANCE_THRESHOLD) {
            if (ctx.pathing.reachable(START_TILE)) {
                status = "Running to start location";
                ctx.pathing.step(START_TILE);
                ctx.onCondition(() -> true, 250, 10);
            }
        } else {
            status = "Clicking starting tile";
            ctx.pathing.clickSceneTile(START_TILE, false, true);
            ctx.onCondition(() -> localPlayer.getLocation().equals(START_TILE));
        }
    }

    private void adjustViewportForFiremaking() {
        ctx.viewport.angle(180);
        ctx.viewport.pitch(true);
    }

    private void lightFire() {
        SimplePlayer localPlayer = ctx.players.getLocal();
        final int IDLE_ANIMATION = -1;
        if (localPlayer.getAnimation() == IDLE_ANIMATION) {
            SimpleItem tinderbox = ctx.inventory.populate().filter(tinderBox).next();
            SimpleItem woodInventory = ctx.inventory.populate().filter(eGui.getLogsComboBox()).next();

            if (tinderbox != null && woodInventory != null) {
                status = "Burning " + eGui.getLogsComboBox().toLowerCase() + "...";
                clickOnBag();
                tinderbox.click("Use");
                ctx.sleep(50);
                woodInventory.click(0);
                WorldPoint cached = localPlayer.getLocation();
                ctx.onCondition(() -> !localPlayer.getLocation().equals(cached), 250, 8);
            }
        }
    }

    private boolean playerIsIdle() {
        SimplePlayer localPlayer = ctx.players.getLocal();
        final int IDLE_ANIMATION = -1;
        return !logsInInventory() && localPlayer.getAnimation() == IDLE_ANIMATION;
    }

    private void updateExperienceAndCount() {
        int newExp = this.ctx.skills.experience(CHOSEN_SKILL);
        if (currentExp != newExp) {
            count++;
            currentExp = newExp;
        }
    }

    private boolean logsInInventory() {
        return !ctx.inventory.populate().filter(eGui.getLogsComboBox()).isEmpty();
    }

    private void bankTask() {
        if (!ctx.bank.bankOpen()) {
            approachBank();
        } else {
            handleBanking();
        }
    }

    private void approachBank() {
        SimpleNpc banker = ctx.npcs.populate().filter(bankName).nearest().next();
        WorldPoint nearBankTile = nearBankLocation(gui);
        //System.out.println("Near bank tile: " + nearBankTile);

        if (ctx.players.getLocal().getLocation().distanceTo(nearBankTile) > 10) {
            status = "Running to bank";
            ctx.pathing.step(nearBankTile);
            ctx.onCondition(() -> ctx.pathing.inMotion(), 250, 10);
        } else {
            if (banker != null && banker.validateInteractable()) {
                status = "Opening bank";
                banker.click(bankOpen, bankName);
                ctx.onCondition(() -> ctx.bank.bankOpen(), 250, 12);
            }
        }
    }

    private void handleBanking() {
        if (!ctx.bank.bankOpen()) return;
        if (ctx.bank.bankOpen()) {
            status = "Banking";
            ctx.bank.depositAllExcept(tinderBox);
            ctx.sleep(200);
            handleTinderbox();
            handleWoodWithdrawal();
        }
        setStartingTileAndCloseBank();
    }

    private void handleTinderbox() {
        SimpleItem tinderBoxInv = ctx.inventory.populate().filter(tinderBox).next();
        if (tinderBoxInv != null) {
            return;
        }

        SimpleItem tinderBoxBank = ctx.bank.populate().filter(tinderBox).next();

        if (tinderBoxBank == null) {
            status = "No tinderbox in bank";
            ctx.updateStatus("Stopping script");
            ctx.updateStatus("No tinderbox in bank");
            ctx.sleep(10000);
            ctx.stopScript();
        } else {
            withdrawTinderbox();
            clearBankSearch();
        }
    }

    private void withdrawTinderbox() {
        ctx.log("Tinderbox not found in inventory. Withdrawing it.");
        SimpleWidget quantityOne = ctx.widgets.getWidget(12, 29);
        if (quantityOne != null && !quantityOne.isHidden()) {
            quantityOne.click(0);
        }
        ctx.bank.withdraw(tinderBox, SimpleBank.Amount.ONE);
    }

    private void clearBankSearch() {
        SimpleWidget searchButton = ctx.widgets.getWidget(12, 40);
        if (searchButton != null && !searchButton.isHidden()) {
            searchButton.click(0);
        }
    }

    private void handleWoodWithdrawal() {
        SimpleItem woodBank = ctx.bank.populate().filter(eGui.getLogsComboBox()).next();
        if (logsInInventory()) return;
        if (woodBank != null) {
            status = "Found " + eGui.getLogsComboBox() + " in bank";
            ctx.bank.withdraw(eGui.getLogsComboBox(), SimpleBank.Amount.ALL);
            ctx.onCondition(this::logsInInventory, 250, 10);
        } else {
            status = "Out of " + eGui.getLogsComboBox().toLowerCase();
            ctx.updateStatus("Stopping script");
            ctx.updateStatus("Out of " + eGui.getLogsComboBox().toLowerCase());
            ctx.sleep(10000);
            ctx.stopScript();
        }
    }

    private void setStartingTileAndCloseBank() {
        WorldPoint[] locationPaths = getSelectedLocationPaths(gui);
        status = "Closing bank";
        ctx.bank.closeBank();
        START_TILE = locationPaths[0];
        firstInventory = false;
        firemakingStarted = false;
    }

    public WorldPoint[] getSelectedLocationPaths(eGui gui) {
        String selectedItem = (String) gui.getLocationComboBox().getSelectedItem();
        Map<String, FiremakingLocations> locations = new HashMap<>();
        locations.put("Falador East", FiremakingLocations.FALADOR_EAST);
        locations.put("Varrock East", FiremakingLocations.VARROCK_EAST);
        locations.put("Grand Exchange", FiremakingLocations.GRAND_EXCHANGE);
        FiremakingLocations locationSelected = locations.get(selectedItem);

        return locationSelected.getPath();
    }

    private WorldPoint nearBankLocation(eGui gui) {
        String selectedItem = (String) gui.getLocationComboBox().getSelectedItem();
        Map<String, WorldPoint> locations = new HashMap<>();
        locations.put("Falador East", NEAR_BANK_LOC_FALADOR);
        locations.put("Varrock East", NEAR_BANK_LOC_VARROCK);
        locations.put("Grand Exchange", NEAR_BANK_LOC_GE);
        return locations.get(selectedItem);
    }

    private void handleFireLightingLoc() {
        WorldPoint[] locationPaths = getSelectedLocationPaths(gui);
        if (locationsTried >= locationPaths.length) {
            ctx.log("All paths have been tried. Pausing...");
            return;
        }

        for (int i = 0; i < locationPaths.length; i++) {
            if (START_TILE.equals(locationPaths[i])) {
                ctx.log("Firemaking path used, choosing next.");
                START_TILE = locationPaths[(i + 1) % locationPaths.length];
                locationsTried++;
                break;
            }
        }

        firemakingStarted = false;
    }

    private void clickOnBag() {
        SimpleWidget inventoryBagWidget = ctx.widgets.getWidget(INVENTORY_BAG_WIDGET_ID, INVENTORY_BAG_CHILD_ID);
        if (inventoryBagWidget != null) {
            inventoryBagWidget.click(0);
        }
    }

    public String getPlayerName() {
        if (playerGameName == null) {
            playerGameName = ctx.players.getLocal().getName();
        }
        return playerGameName;
    }

    public static String currentTime() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    private void drawTileMatrix(Graphics2D g, WorldPoint startTile) {
        for (int i = 0; i < 27; i++) {
            WorldPoint tile = new WorldPoint(startTile.getX() - i, startTile.getY(), startTile.getPlane());
            ctx.paint.drawTileMatrix(g, tile, Color.GREEN);
        }
    }

    @Override
    public void onTerminate() {
        this.count = 0;
        this.counter = 0;
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        status = "Stopping bot";
        gui.setVisible(false);
        hidePaint = true;
        ctx.updateStatus("Logs burned: " + count);

        this.ctx.updateStatus("-------------- " + currentTime() + " --------------");
        this.ctx.updateStatus("----------------------");
        this.ctx.updateStatus("Thank You & Good Luck!");
        this.ctx.updateStatus("----------------------");
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        playerGameName = getPlayerName();
        String message = m.getMessage();

        if (message == null) {
            return;
        }

        if (message.toLowerCase().contains("light a fire here")) {
            counter++;
            if (counter >= 5) {
                firemakingStarted = false;
                counter = 0;
            }
        }

        if (getType == ChatMessageType.PUBLICCHAT) {
            String senderName = getEvent.getName();

            // Remove any text within angle brackets and trim
            senderName = senderName.replaceAll("<[^>]+>", "").trim();

            if (senderName.contains(playerGameName)) {
                ctx.updateStatus(currentTime() + " Someone asked for you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }

        }
    }

    @Override
    public void paint(Graphics g) {

        // Drawing a Firemaking path
        if (START_TILE != null) {
            WorldPoint[] tileToDrawFrom = new WorldPoint[]{START_TILE};
            for (WorldPoint startTile : tileToDrawFrom) {
                drawTileMatrix((Graphics2D) g, startTile);
            }
        }

        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePaintText + ": " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + status, 15, 225);
        }
    }

}

'''
'''--- src/eFreakyForesterSolver/eFreakyForesterMain.java ---
package eFreakyForesterSolver;

import net.runelite.api.coords.WorldPoint;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.*;
import simple.robot.script.Script;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.awt.event.KeyEvent;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

@ScriptManifest(author = "Esmaabi", category = Category.UTILITY, description = " "
        + "Will solve <b>Freaky Forester</b> random event for you!</b><br>", discord = "Esmaabi#5752",
        name = "eFreakyForesterSolverZenyte", servers = { "Zenyte" }, version = "0.1")

public class eFreakyForesterMain extends Script {

    //Vars
    private static boolean finished;
    private static boolean taskAquired;
    static int space = KeyEvent.VK_SPACE;

    //Forest area
    private final WorldArea forestArea = new WorldArea(new WorldPoint(2586, 4788, 0), new WorldPoint(2618, 4762, 0));

    //NPC
    private final int freakyForester = 372;
    private final int oneTailedPheasant = 373;
    private final int twoTailedPheasant = 5500;
    private final int threeTailedPheasant = 374;
    private final int fourTailedPheasant = 5502;

    //pheasant meat
    private final int oneTailedPheasantMeat = 6178;
    private final int twoTailedPheasantMeat  = 6179;
    private final int threeTailedPheasantMeat  = 11704;
    private final int fourTailedPheasantMeat  = 28890;

    //DialogueAnswer
    private int answerWithTails;
    private int answerDrop;
    private int droppedItem;

    @Override
    public void onExecute() {
        System.out.println("Started eFreakyForesterSolver for Zenyte!");
        ctx.viewport.angle(180);
        ctx.viewport.pitch(true);

        ctx.updateStatus("------------------------------------");
        ctx.updateStatus("     eFreakyForesterSolver started   ");
        ctx.updateStatus("------------ Time " + currentTime() + " -------------");
        ctx.updateStatus("------------------------------------");

        //vars
        finished = false;
        taskAquired = false;
        answerWithTails = -1;
        answerDrop = -1;
        droppedItem = -1;
    }

    @Override
    public void onProcess() {

        if (ctx.pathing.inArea(forestArea)) {

            SimpleWidget foresterText = ctx.widgets.getWidget(231, 4);
            SimpleWidget playerText = ctx.widgets.getWidget(217, 4);
            if (ctx.dialogue.dialogueOpen()) {
                if (foresterText != null && !foresterText.isHidden()) {

                    if (foresterText.getText().toLowerCase().contains("meat of a pheasant with one")) {
                        answerWithTails = oneTailedPheasant;
                        answerDrop = oneTailedPheasantMeat;
                        ctx.updateStatus("Task acquired: one tail");
                        taskAquired = true;
                        ctx.keyboard.clickKey(space);
                    } else if (foresterText.getText().toLowerCase().contains("meat of a pheasant with two")) {
                        answerWithTails = twoTailedPheasant;
                        answerDrop = twoTailedPheasantMeat;
                        ctx.updateStatus("Task acquired: two tails");
                        taskAquired = true;
                        ctx.keyboard.clickKey(space);
                    } else if (foresterText.getText().toLowerCase().contains("meat of a pheasant with three")) {
                        answerWithTails = threeTailedPheasant;
                        answerDrop = threeTailedPheasantMeat;
                        ctx.updateStatus("Task acquired: three tails");
                        taskAquired = true;
                        ctx.keyboard.clickKey(space);
                    } else if (foresterText.getText().toLowerCase().contains("meat of a pheasant with four")) {
                        answerWithTails = fourTailedPheasant;
                        answerDrop = fourTailedPheasantMeat;
                        ctx.updateStatus("Task acquired: four tails");
                        taskAquired = true;
                        ctx.keyboard.clickKey(space);
                    } else if (foresterText.getText().toLowerCase().contains("well done")) {
                        finished = true;
                        ctx.updateStatus("Task finished");
                        ctx.keyboard.clickKey(space);
                    } else {
                        ctx.updateStatus("Processing dialogue");
                        ctx.keyboard.clickKey(space);
                    }
                }

                if (playerText != null && !playerText.isHidden()) {
                    ctx.updateStatus("Processing dialogue");
                    ctx.keyboard.clickKey(space);
                }
            }

            if (!taskAquired && !finished && !ctx.dialogue.dialogueOpen()) {
                SimpleNpc theForester = ctx.npcs.populate().filter(freakyForester).next();
                if (theForester != null && theForester.validateInteractable()) {
                    theForester.click("Talk-to");
                    ctx.onCondition(() -> ctx.dialogue.dialogueOpen(), 3000);
                }
            }

            if (taskAquired && !finished && !ctx.dialogue.dialogueOpen()) {

                SimpleNpc taskPheasant = ctx.npcs.populate().filter(answerWithTails).nearest().next();
                SimpleNpc theForester = ctx.npcs.populate().filter(freakyForester).next();
                SimpleItem taskPheasantMeat = ctx.inventory.populate().filter(answerDrop).next();
                if (taskPheasantMeat != null && taskPheasantMeat.validateInteractable() && !ctx.dialogue.dialogueOpen()) {
                    ctx.updateStatus("Pheasant meat is in inventory");
                    if (theForester != null && theForester.validateInteractable()) {
                        theForester.click("Talk-to");
                        ctx.onCondition(() -> ctx.dialogue.dialogueOpen(), 250, 10);
                        taskAquired = false;
                    }
                } else {

                    if (taskPheasantMeat == null) {
                        if (taskPheasant != null && taskPheasant.validateInteractable() && ctx.groundItems.populate().filter(answerDrop).isEmpty()) {
                            taskPheasant.click("Kill");
                            ctx.onCondition(() -> !ctx.groundItems.populate().filter(answerDrop).isEmpty(), 250, 10);
                        }
                    }

                    if (!ctx.groundItems.populate().filter(answerDrop).isEmpty()) {
                        if (!ctx.inventory.inventoryFull()) {
                            SimpleGroundItem droppedMeat = ctx.groundItems.populate().filter(answerDrop).next();
                            if (droppedMeat != null && droppedMeat.validateInteractable()) {
                                ctx.updateStatus("Picking up pheasant meat");
                                droppedMeat.click("Take");
                                ctx.sleepCondition(() -> !ctx.inventory.populate().filter(answerDrop).isEmpty(), 3000);
                            }
                        } else {
                            freeUpSlots();
                        }
                    }
                }
            }

            if (finished) {
                if (droppedItem != -1) {
                    if (ctx.inventory.inventoryFull()) {
                        SimpleItem taskPheasantMeat = ctx.inventory.populate().filter(answerDrop).next();
                        if (taskPheasantMeat != null && taskPheasantMeat.validateInteractable()) {
                            taskPheasantMeat.click("Drop");
                            ctx.sleepCondition(() -> ctx.inventory.populate().filter(answerDrop).isEmpty(), 3000);
                        }

                    } else {

                        SimpleGroundItem droppedItemEarlier = ctx.groundItems.populate().filter(droppedItem).next();
                        if (droppedItemEarlier != null && droppedItemEarlier.validateInteractable()) {
                            droppedItemEarlier.click("Take");
                            int cached = ctx.inventory.populate().filter(droppedItem).population();
                            ctx.sleepCondition(() -> ctx.inventory.populate().filter(droppedItem).population() > cached, 10000);
                            ctx.updateStatus("Dropped item id: " + droppedItem + " picked up.");
                        }
                        droppedItem = -1;
                    }
                }

                SimpleObject finishedPortal = ctx.objects.populate().filter(20843).next(); // Exit portal
                if (finishedPortal != null && finishedPortal.validateInteractable() && droppedItem == -1) {
                    finishedPortal.click("Use");
                    ctx.sleepCondition(() -> !ctx.players.getLocal().isAnimating(), 5000);
                }
            }

        } else {
            ctx.stopScript();
        }
    }

    private void freeUpSlots() {
        if (droppedItem != -1) {
            return;
        }

        SimpleItem droppingItem = ctx.inventory.populate().filterHasAction("Drop").next();
        if (droppingItem == null || !droppingItem.validateInteractable()) {
            return;
        }

        ctx.inventory.dropItem(droppingItem);
        droppedItem = droppingItem.getId();
        ctx.updateStatus("Dropped item id: " + droppedItem + " saved.");
    }

    public static String currentTime() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    @Override
    public void onTerminate() {
        //vars
        taskAquired = false;
        finished = false;
        answerWithTails = -1;
        answerDrop = -1;

        ctx.updateStatus("------------------------------------");
        ctx.updateStatus("    eFreakyForesterSolver finished   ");
        ctx.updateStatus("------------ Time " + currentTime() + " -------------");
        ctx.updateStatus("------------------------------------");

    }

    @Override
    public void onChatMessage(ChatMessage m) {
    }

    @Override
    public void paint(Graphics g) {
    }

}

'''
'''--- src/eGlassblowingBotZenyte/eGui.java ---
package eGlassblowingBotZenyte;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.Objects;

public class eGui extends JFrame implements ActionListener {

    private final JComboBox<String> modeSelect;
    private final JButton startButton;
    private final JButton pauseButton;
    public static int widgetItem1 = 270;
    public static int widgetItem2;
    public static String nameOfItem;

    public eGui() {
        setTitle("eGlassblowingBot by Esmaabi");
        setLayout(new FlowLayout());
        setSize(550, 350);
        setLocationRelativeTo(null);
        setResizable(false);
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        addWindowListener(new WindowAdapter() {
            @Override
            public void windowOpened(WindowEvent e) {
                super.windowOpened(e);
                JOptionPane.showMessageDialog(null, "Please read the description!");
            }
        });

        ImageIcon eIcon = new ImageIcon(Objects.requireNonNull(eGui.class.getResource("esmaabi-icon.png")));
        setIconImage(eIcon.getImage());

        final JPanel topPanel = getjPanel();

        add(topPanel, BorderLayout.NORTH);

        JPanel middlePanel = new JPanel();
        middlePanel.setLayout(new BoxLayout(middlePanel, BoxLayout.PAGE_AXIS));

        JLabel modeLabel = new JLabel("Select Mode:");
        middlePanel.add(modeLabel);

        modeSelect = new JComboBox<>(new String[]{
                "Beer glass (lvl 1 & sell)",
                "Empty candle latern (lvl 4 & sell)",
                "Empty oil lamp (lvl 12 & sell)",
                "Vial (lvl 33 & sell)",
                "Empty fishbowl (lvl 42 & sell)",
                "Unpowered orb (lvl 46 & sell)",
                "Latern lens (lvl 49 & sell)",
                "Empty light orb (lvl 87 & drop)"
        });
        modeSelect.setSelectedIndex(0);
        middlePanel.add(modeSelect);

        add(middlePanel, BorderLayout.CENTER);

        JPanel bottomPanel = new JPanel();
        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.PAGE_AXIS));

        startButton = new JButton("Start");
        startButton.addActionListener(this);
        bottomPanel.add(startButton);

        pauseButton = new JButton("Pause");
        pauseButton.setVisible(false);
        pauseButton.addActionListener(this);
        bottomPanel.add(pauseButton);

        JButton closeButton = new JButton("Close Gui");
        closeButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                dispose();
            }
        });
        bottomPanel.add(closeButton);

        add(bottomPanel, BorderLayout.SOUTH);

        setVisible(true);
    }

    private static JPanel getjPanel() {
        JPanel topPanel = new JPanel();
        topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.PAGE_AXIS));

        JLabel descriptionLabel = new JLabel("<html><b>Please read <b>eGlassblowingBot</b> description first!</b></html>");
        topPanel.add(descriptionLabel);

        JLabel descriptionText = new JLabel("<html><br>" +
                "Introducing the most efficient glassblowing bot for Zenyte! " +
                "<br><br><b>Features and Recommendations:</b><br><br> " + "<ul>" +
                "<li>Start near <b>charter trader crewmember</b> or bot will stop.</li>" +
                "<li>The bot will sell all crafted items, except for empty light orbs.</li>" +
                "<li>It's recommended to wield <b>smoke battlestaff</b> or any elemental staff.</li>" +
                "<li>Make sure you have enough coins and air/fire/astral runes.</li>" +
                "<li>The bot will stop if you run out of coins or runes.</li></ul><br>" +
                "For more information, check out Esmaabi on SimpleBot!</html>");
        topPanel.add(descriptionText);
        return topPanel;
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (e.getSource() == startButton) {
            int selectedIndex = modeSelect.getSelectedIndex();
            Mode mode = Mode.values()[selectedIndex];
            nameOfItem = mode.itemName;
            eMain.status = "Making " + nameOfItem;
            widgetItem2 = mode.widgetItemNumber;

            startButton.setVisible(false);
            pauseButton.setVisible(true);
            modeSelect.setEnabled(false);
            eMain.started = true;
        } else if (e.getSource() == pauseButton) {
            eMain.started = false;
            pauseButton.setVisible(false);
            startButton.setVisible(true);
            modeSelect.setEnabled(true);
        }
    }

    private enum Mode {
        BEER_GLASS("beer glass", 14),
        EMPTY_CANDLE_LANTERN("empty candle latern", 15),
        EMPTY_OIL_LAMP("empty oil lamp", 16),
        EMPTY_VIAL("empty vial", 17),
        EMPTY_FISHBOWL("empty fishbowl", 18),
        EMPOWERED_ORB("enpowered orb", 19),
        LANTERN_LENS("latern lens", 20),
        EMPTY_LIGHT_ORB("empty light orb", 21);

        private final String itemName;
        private final int widgetItemNumber;

        Mode(String itemName, int widgetItemNumber) {
            this.itemName = itemName;
            this.widgetItemNumber = widgetItemNumber;
        }
    }

}
'''
'''--- src/eGlassblowingBotZenyte/eMain.java ---
package eGlassblowingBotZenyte;

import net.runelite.api.ChatMessageType;
import simple.hooks.filters.SimpleShop;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.queries.SimpleItemQuery;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Game;
import simple.hooks.simplebot.Magic;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleWidget;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.*;
import java.util.concurrent.CompletableFuture;

@ScriptManifest(author = "Esmaabi", category = Category.CRAFTING,
        description = "<html><br>" +
                "Introducing the most efficient glassblowing bot for Zenyte! " +
                "<br><br><b>Features and Recommendations:</b><br><br> " + "<ul>" +
                "<li>Start near <b>charter trader crewmember</b> or bot will stop.</li>" +
                "<li>The bot will sell all crafted items, except for empty light orbs.</li>" +
                "<li>It's recommended to wield <b>smoke battlestaff</b> or any elemental staff.</li>" +
                "<li>Make sure you have enough coins and air/fire/astral runes.</li>" +
                "<li>The bot will stop if you run out of coins or runes.</li></ul><br>" +
                "For more information, check out Esmaabi on SimpleBot!</html>",
        discord = "Esmaabi#5752",
        name = "eGlassblowingBotZenyte", servers = { "Zenyte" }, version = "2.1")

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.CRAFTING;
    private static final int BLOWING_PIPE = 1785;
    private static final int MOLTEN_GLASS = 1775;
    private static final int BUCKET_OF_SAND = 1783;
    private static final int SODA_ASH = 1781;
    private static final int REQUIRED_ITEMS = 10;
    private static final Set<Integer> CRAFTING_ITEMS = new HashSet<>(Arrays.asList(1919, 4527, 4525, 229, 6667, 567, 4542));

    // Vars
    private long startTime = 0L;
    private long startingSkillLevel;
    private long startingSkillExp;
    private int count;
    private int currentExp;
    private long lastAnimation = -1;
    public static String status = null;
    public static boolean started;
    private static boolean hidePaint = false;
    private static String playerGameName;
    private boolean errorAppeared;

    //Tasks
    List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        //tasks.addAll(Arrays.asList());

        System.out.println("Started eGlassblowingBot!");

        this.ctx.updateStatus("--------------- " + currentTime() + " ---------------");
        this.ctx.updateStatus("-------------------------------------");
        this.ctx.updateStatus("         eGlassblowingBotZenyte      ");
        this.ctx.updateStatus("-------------------------------------");
        started = false;

        status = "Setting up bot";
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        currentExp = this.ctx.skills.experience(CHOSEN_SKILL);// for actions counter by xp drop
        count = 0;
        ctx.viewport.angle(270);
        ctx.viewport.pitch(true);

        //GUI
        eGui gui = new eGui();
        gui.setVisible(true);
    }

    @Override
    public void onProcess() {
        super.onProcess();

        if (currentExp != this.ctx.skills.experience(SimpleSkills.Skills.CRAFTING)) {
            count++;
            currentExp = this.ctx.skills.experience(SimpleSkills.Skills.CRAFTING);
        }

        if (ctx.magic.spellBook() != Magic.SpellBook.LUNAR) {
            switchTabs(Game.Tab.MAGIC, Game.Tab.INVENTORY, 4);  // Switch tabs 4 times
            status = "Lunar spellbook required!";
            ctx.log("Stopping script");
            ctx.log("Please change spellbook to Lunar");
            ctx.sleep(5000);
            ctx.stopScript();
        }

        if (!started) {
            status = "Choose mode and start";

        } else {

            if (errorAppeared) {
                sellingGoods();
            }

            if (!ctx.shop.shopOpen() && hasItemsInInventory(10980) && !hasItemsInInventory(MOLTEN_GLASS, BUCKET_OF_SAND, SODA_ASH)) {
                status = "Dropping empty light orbs";
                getItemsFiltered(10980).forEach(item -> ctx.inventory.dropItem(item));
                ctx.onCondition(() -> !hasItemsInInventory(10980), 200, 10);
            }

            if (!hasItemsInInventory(MOLTEN_GLASS, BUCKET_OF_SAND, SODA_ASH)) {
                if (!ctx.shop.shopOpen()) {
                    openShopTask();
                }
                shoppingTask();
            }

            if (hasItemsInInventory(BUCKET_OF_SAND, SODA_ASH) && !hasItemsInInventory(MOLTEN_GLASS)) {
                if (ctx.shop.shopOpen()) {
                    updateStatus("Closing shop");
                    ctx.shop.closeShop();
                }

                if (hasItemsInInventory(SODA_ASH, BUCKET_OF_SAND) && !ctx.shop.shopOpen()) {
                    status = "Making molten glass";
                    ctx.magic.castSpellOnce("Superglass Make");
                    ctx.sleep(1200);
                    ctx.onCondition(() -> hasItemsInInventory(MOLTEN_GLASS), 200, 10);
                }
            }

            if (hasItemsInInventory(MOLTEN_GLASS) && !ctx.shop.shopOpen()) {
                glassblowingItems();
            }
        }
    }

    private void glassblowingItems() {
        SimpleItem glassblowingPipe = ctx.inventory.populate().filter(BLOWING_PIPE).next();
        SimpleItem moltenGlassInv = ctx.inventory.populate().filter(MOLTEN_GLASS).next();
        status = "Glassblowing";

        if (ctx.players.getLocal().getAnimation() != 884 && (System.currentTimeMillis() > (lastAnimation + 3000))) {

            if (glassblowingPipe != null && glassblowingPipe.validateInteractable()
                    && moltenGlassInv != null && moltenGlassInv.validateInteractable()
                    && !ctx.dialogue.dialogueOpen()) {
                glassblowingPipe.click("Use");
                ctx.sleep(100);
                moltenGlassInv.click(0);
                ctx.onCondition(() -> ctx.dialogue.dialogueOpen(), 250, 10);
            }

            if (ctx.dialogue.dialogueOpen()) {
                updateStatus("Making " + eGui.nameOfItem);
                SimpleWidget makeAllButton = ctx.widgets.getWidget(270, 12); //Make ALL button
                SimpleWidget itemToMake = ctx.widgets.getWidget(eGui.widgetItem1, eGui.widgetItem2); //Item from GUI
                if (itemToMake.validateInteractable() && !itemToMake.isHidden()) {
                    makeAllButton.click(0);
                    ctx.sleep(50);
                    itemToMake.click(0);
                }
                ctx.onCondition(() -> ctx.players.getLocal().isAnimating(), 250,10);
            }

        } else if (ctx.players.getLocal().isAnimating()) {
            lastAnimation = System.currentTimeMillis();
        }
    }

    private void sellingGoods() {
        if (!ctx.shop.shopOpen()) {
            openShopTask();
        }

        updateStatus("Selling items");

        if (errorAppeared) {
            ctx.shop.sell(BUCKET_OF_SAND, SimpleShop.Amount.FIFTY);
            ctx.shop.sell(SODA_ASH, SimpleShop.Amount.FIFTY);
            ctx.onCondition(() -> hasItemsInInventory(BUCKET_OF_SAND, SODA_ASH));
            errorAppeared = false;
        }

        for (int itemId : CRAFTING_ITEMS) {
            if (!ctx.inventory.populate().filter(itemId).isEmpty()) {
                ctx.shop.sell(itemId, SimpleShop.Amount.FIFTY);
                ctx.onCondition(() -> !hasItemsInInventory(itemId), 250, 8);
            }
        }
    }

    private boolean noCraftingItemsInInventory() {
        for (int itemId : CRAFTING_ITEMS) {
            if (hasItemsInInventory(itemId)) {
                return false;
            }
        }
        return true;
    }

    private void openShopTask() {

        SimpleNpc traderCrew = ctx.npcs.populate().filter("Trader Crewmember").filterHasAction("Trade").nearest().next();

        if (ctx.shop.shopOpen()) return;

        if (traderCrew == null) {
            ctx.log("Trader Crewmember not found");
            ctx.sendLogout();
        }

        if (traderCrew != null && traderCrew.validateInteractable()) {
            updateStatus("Opening shop");
            if (!traderCrew.visibleOnScreen()) {
                ctx.pathing.step(traderCrew.getLocation());
                ctx.viewport.turnTo(traderCrew);
            }
            traderCrew.menuAction("Trade");
            ctx.onCondition(() -> ctx.shop.shopOpen());
        }
    }

    private void shoppingTask() {

        if (!ctx.shop.shopOpen()) return;

        if (!noCraftingItemsInInventory()) {
            sellingGoods();
        }

        if (noCraftingItemsInInventory()) {
            CompletableFuture<Void> buyItemsFuture = CompletableFuture.runAsync(() -> {
                int blowingPipeCount = ctx.inventory.populate().filter(BLOWING_PIPE).population();
                int sandCount = ctx.inventory.populate().filter(BUCKET_OF_SAND).population();
                int sodaAshCount = ctx.inventory.populate().filter(SODA_ASH).population();

                if (blowingPipeCount < 1) {
                    buyItem(BLOWING_PIPE, SimpleShop.Amount.ONE, "glassblowing pipe");
                }

                if (sandCount < REQUIRED_ITEMS) {
                    buyItem(BUCKET_OF_SAND, SimpleShop.Amount.TEN, "soda ashes");
                }

                if (sodaAshCount < REQUIRED_ITEMS) {
                    buyItem(SODA_ASH, SimpleShop.Amount.TEN, "buckets of sand");
                }
            });

            buyItemsFuture.join();

            int sandPopulation = ctx.inventory.populate().filter(BUCKET_OF_SAND).population();
            int sodaAshPopulation = ctx.inventory.populate().filter(SODA_ASH).population();

            if (sandPopulation == REQUIRED_ITEMS && sodaAshPopulation == REQUIRED_ITEMS) {
                updateStatus("Closing shop");
                ctx.shop.closeShop();
            } else {
                sellingGoods();
                ctx.shop.sell(BUCKET_OF_SAND, SimpleShop.Amount.FIFTY);
                ctx.shop.sell(SODA_ASH, SimpleShop.Amount.FIFTY);
                ctx.shop.sell(MOLTEN_GLASS, SimpleShop.Amount.FIFTY);
            }
        }
    }

    private void buyItem(int itemId, SimpleShop.Amount amount, String itemName) {
        updateStatus("Buying " + itemName);
        ctx.shop.buy(itemId, amount);
        ctx.onCondition(() -> hasItemsInInventory(itemId), 100, 10);
    }

    private SimpleItemQuery<SimpleItem> getItemsFiltered(int... itemIds) {
        return ctx.inventory.populate().filter(itemIds);
    }

    private boolean hasItemsInInventory(int... itemIds) {
        return !getItemsFiltered(itemIds).isEmpty();
    }

    private void switchTabs(Game.Tab tabOne, Game.Tab tabTwo, int times) {
        for (int i = 0; i < times; i++) {
            ctx.game.tab(tabOne);
            ctx.game.tab(tabTwo);
        }
    }

    public String getPlayerName() {
        if (playerGameName == null) {
            playerGameName = ctx.players.getLocal().getName();
        }
        return playerGameName;
    }

    private void updateStatus(String newStatus) {
        status = newStatus;
        ctx.updateStatus(status);
        System.out.println(status);
    }

    public static String currentTime() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    @Override
    public void onTerminate() {
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.ctx.updateStatus("You made a total of " + count + " glass items.");
        count = 0;
        started = false;
        eGui.widgetItem2 = -1;

        this.ctx.updateStatus("--------------- " + currentTime() + " --------------");
        this.ctx.updateStatus("----------------------------------");
        this.ctx.updateStatus("      Thank You & Good Luck!      ");
        this.ctx.updateStatus("----------------------------------");
    }

    @Override
    public void onChatMessage(ChatMessage m) {

        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        playerGameName = getPlayerName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        String message = m.getMessage().toLowerCase();
        if (message.contains("don't have enough")) {
            ctx.updateStatus(currentTime() + " Out of coins");
            ctx.updateStatus(currentTime() + " Stopping script");
            ctx.sleep(3000);
            ctx.stopScript();
        } else if (message.contains("do not have enough")) {
            ctx.updateStatus(currentTime() + " Out of runes");
            ctx.updateStatus(currentTime() + " Stopping script");
            ctx.sleep(3000);
            ctx.stopScript();
        } else if (message.contains("need some sand to cast") || message.contains("need either some soda ash or seaweed to")) {
            errorAppeared = true;
        }

        if (getType == ChatMessageType.PUBLICCHAT) {
            String senderName = getEvent.getName();

            // Remove any text within angle brackets and trim
            senderName = senderName.replaceAll("<[^>]+>", "").trim();

            if (senderName.contains(playerGameName)) {
                ctx.updateStatus(currentTime() + " Someone asked for you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }
        }

        Utility.Trivia.eTriviaInfo.handleBroadcastMessage(getType, gameMessage);
    }

    @Override
    public int loopDuration() {
        return 200;
    }

    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString("eGlassblowingBot by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString("Actions made: " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + status, 15, 225);

        }
    }

}
'''
'''--- src/eHerbloreBotZenyte/eGui.java ---
package eHerbloreBotZenyte;

import javax.swing.*;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.PlainDocument;
import java.awt.*;
import java.util.Objects;

public class eGui extends JFrame {
    private static final long serialVersionUID = 1L;
    private static final String[] POTIONS = {"Super energy potion", "Staming potion", "Zamorak brew", "Super strenght potion", "Super attack potion", "Super defence potion", "Ranging potion", "Magic potion", "Prayer potion", "Super restore", "Saradomin brew", "Superantipoison", "Bastion potion", "Antifire potion", "Super antifire potion", "Super combat potion"};
    public static JComboBox<String> potionsComboBox;
    private JTextField itemTextField;
    private JButton startButton;
    private JButton pauseButton;

    public eGui() {
        setTitle("eHerbloreBot by Esmaabi");
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        setLocationRelativeTo(null);
        setIconImage(new ImageIcon(Objects.requireNonNull(getClass().getResource("esmaabi-icon.png"))).getImage());

        initGUI();

        pack();
    }

    private void initGUI() {
        JPanel contentPane = new JPanel(new GridBagLayout());
        contentPane.setBackground(Color.DARK_GRAY);
        setContentPane(contentPane);

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.insets = new Insets(5, 5, 5, 5);

        // Add title
        constraints.gridy = 0;
        constraints.gridx = 0;
        constraints.gridwidth = 2;
        constraints.anchor = GridBagConstraints.CENTER;
        addLabel("Please choose options below!", contentPane, constraints, true);

        constraints.gridwidth = 1; // Resetting gridwidth
        constraints.anchor = GridBagConstraints.WEST; // Resetting anchor

        constraints.gridy++; // Moving to next row
        constraints.gridx = 0; // Resetting x-axis position to 0

        // Select location
        addLabel("Select potions: ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        potionsComboBox = addComboBox(contentPane, constraints);
        potionsComboBox.setPreferredSize(new Dimension(150, potionsComboBox.getPreferredSize().height));

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row

        // Enter NPC ID only as digits
        addLabel("DO NOT USE: ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        itemTextField = addTextField(contentPane, constraints);
        itemTextField.setPreferredSize(new Dimension(150, itemTextField.getPreferredSize().height));

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row
        constraints.gridwidth = 2; // Resetting gridwidth
        constraints.anchor = GridBagConstraints.CENTER; // Resetting anchor

        // Start and Pause buttons
        JPanel buttonsPanel = new JPanel(new GridLayout(1, 2, 5, 0));
        startButton = new JButton("Start");
        startButton.addActionListener(e -> startBot());
        startButton.setBackground(Color.GREEN);
        buttonsPanel.add(startButton);
        pauseButton = new JButton("Pause");
        pauseButton.addActionListener(e -> pauseBot());
        pauseButton.setVisible(false); // Setting button invisible
        pauseButton.setBackground(Color.RED);
        buttonsPanel.add(pauseButton);
        contentPane.add(buttonsPanel, constraints);
    }

    private void addLabel(String text, Container container, GridBagConstraints constraints, boolean isTitle) {
        JLabel label = new JLabel(text);
        label.setForeground(Color.WHITE);
        if (isTitle) {
            label.setFont(label.getFont().deriveFont(Font.BOLD, 16));
        }
        container.add(label, constraints);
        constraints.gridx++;
    }

    private JComboBox<String> addComboBox(Container container, GridBagConstraints constraints) {
        JComboBox<String> comboBox = new JComboBox<>(POTIONS);
        container.add(comboBox, constraints);
        constraints.gridx = 0;
        constraints.gridy++;

        comboBox.addActionListener(e -> eMain.returnItem = getSelectedPotionIndex());

        return comboBox;
    }

    private JTextField addTextField(Container container, GridBagConstraints constraints) {
        JTextField textField = new JTextField();
        ((PlainDocument) textField.getDocument()).setDocumentFilter(new DigitDocumentFilter());
        container.add(textField, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
        return textField;
    }

    private void startBot() {
        eMain.botStarted = true;
        pauseButton.setVisible(true);
        startButton.setVisible(false);
        itemTextField.setEnabled(false);
        potionsComboBox.setEnabled(false);
        eMain.returnItem = getSelectedPotionIndex();
    }

    private void pauseBot() {
        eMain.botStarted = false;
        pauseButton.setVisible(false);
        startButton.setVisible(true);
        itemTextField.setEnabled(false);
        potionsComboBox.setEnabled(true);
    }

    public JTextField getItemTextField() {
        return itemTextField;
    }

    public int getSelectedPotionIndex() {
        int selectedPotionIndex = potionsComboBox.getSelectedIndex();
        return selectedPotionIndex;
    }

    public int getItemId() {
        String intAsText = getItemTextField().getText();
        int itemId = 0;
        try {
            itemId = Integer.parseInt(intAsText);
        } catch (NumberFormatException e) {
            // Handle the exception, e.g., show an error message or set a default value
        }
        return itemId;
    }

    // DocumentFilter class that accepts only digits
    private static class DigitDocumentFilter extends javax.swing.text.DocumentFilter {
        @Override
        public void insertString(FilterBypass fb, int offset, String string, AttributeSet attr) throws BadLocationException {
            if (string != null && string.chars().allMatch(Character::isDigit)) {
                super.insertString(fb, offset, string, attr);
            }
        }

        @Override
        public void replace(FilterBypass fb, int offset, int length, String text, AttributeSet attrs) throws BadLocationException {
            if (text != null && text.chars().allMatch(Character::isDigit)) {
                super.replace(fb, offset, length, text, attrs);
            }
        }
    }
}

'''
'''--- src/eHerbloreBotZenyte/eMain.java ---
package eHerbloreBotZenyte;

import eRandomEventSolver.eRandomEventForester;
import net.runelite.api.ChatMessageType;
import simple.hooks.filters.SimpleBank;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.*;

import java.awt.*;
import java.awt.event.KeyEvent;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.HERBLORE,
        description = "<html>"
                + "<p>The most effective anvil herblore bot on Zenyte!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>Start with a <strong>empty inventory</strong>.</li>"
                + "<li>Start <strong>near bank booth or bank chest</strong>.</li>"
                + "<li>Have unfinished potions and secondaries visible in bank</li>"
                + "<li>Zoom in to <strong>see bank close</strong> for better performance.</li>"
                + "<li>At the moment only <strong>making potions</strong> supported.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eHerbloreBotZenyte",
        servers = {"Zenyte"},
        version = "0.3"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final String[] BANK_NAME = {"Bank booth", "Bank chest"};
    private static final String[] BANKER_NAME = {"Banker","Bird's-Eye' Jack", "Arnold Lydspor", "Banker tutor", "Cornelius", "Emerald Benedict", "Eniola", "Fadli", "Financial Wizard", "Financial Seer", "Ghost banker", "Gnome banker", "Gundai", "Jade", "Jumaane", "Magnus Gram", "Nardah Banker", "Odovacar", "Peer the Seer", "Sirsal Banker", "Squire", "TzHaar-Ket-Yil", "TzHaar-Ket-Zuh", "Yusuf"};
    private final static int INVENTORY_BAG_WIDGET_ID = 548;
    private final static int INVENTORY_BAG_CHILD_ID = 58;

    // Variables
    private long startTime = 0L;
    private long startingSkillLevel;
    private long startingSkillExp;
    private long currentExp;
    private int count;
    private int unfinishedPotionID;
    public static String status = null;
    public static int returnItem;
    private static String nameOfItem = null;
    public int secondIngrediente;
    private long lastAnimation = -1;
    public static boolean botStarted;
    private static boolean hidePaint = false;
    private boolean makingSuperCombat = false;
    private boolean makingStamingPotions = false;
    private static String playerGameName;

    // Gui
    private static eGui gui;
    private void initializeGUI() {
        gui = new eGui();
        gui.setVisible(true);
        gui.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    public enum PotionItems {
        SUPER_ENERGY_POTIONS("super energy potions", 103, 2970),
        STAMINA_POTIONS("stamina potions", 3016, 12640),
        ZAMORAK_BREWS("zamorak brews", 111, 247),
        SUPER_STRENGTH_POTIONS("super strenght potions", 105, 225),
        SUPER_ATTACK_POTION("super attack potion", 101, 221),
        SUPER_DEFENCE_POTIONS("super defence potions", 107, 239),
        RANGING_POTIONS("ranging potions", 109, 245),
        MAGIC_POTIONS("magic potions", 2483, 3138),
        PRAYER_POTIONS("prayer potions", 99, 231),
        SUPER_RESTORE("super restores", 3004, 223),
        SARADOMIN_BREWS("saradomin brews", 3002, 6693),
        SUPERANTIPOISONS("superantipoisons", 101, 235),
        BASTION_POISONS("bastion potion", 22443, 245),
        ANTIFIRE_POTIONS("antifire potions", 2483, 241),
        SUPER_ANTIFIRE_POTIONS("super antifire potions", 2452, 21975),
        SUPER_COMBAT_POTIONS("super combat potions", 111, 0); // Set secondIngrediente to 0 since it's not needed for this item

        private final String nameOfItem;
        private final int unfinishedPotionID;
        private final int secondIngrediente;

        PotionItems(String nameOfItem, int unfinishedPotionID, int secondIngrediente) {
            this.nameOfItem = nameOfItem;
            this.unfinishedPotionID = unfinishedPotionID;
            this.secondIngrediente = secondIngrediente;
        }

        public String getNameOfItem() {
            return nameOfItem;
        }

        public int getUnfinishedPotionID() {
            return unfinishedPotionID;
        }

        public int getSecondIngrediente() {
            return secondIngrediente;
        }
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList());// Adds tasks to our {task} list for execution

        initializeGUI();

        // Other vars
        System.out.println("Started eHerbloreBot!");
        this.ctx.updateStatus("--------------- " + currentTime() + " ---------------");
        this.ctx.updateStatus("-------------------------------");
        this.ctx.updateStatus("           eHerbloreBot        ");
        this.ctx.updateStatus("-------------------------------");

        // Vars
        updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(SimpleSkills.Skills.HERBLORE);
        this.startingSkillExp = this.ctx.skills.experience(SimpleSkills.Skills.HERBLORE);
        currentExp = this.ctx.skills.experience(SimpleSkills.Skills.HERBLORE);
        lastAnimation = System.currentTimeMillis();
        botStarted = false;
        unfinishedPotionID = 0;
        secondIngrediente = 0;
        makingSuperCombat = false;
        makingStamingPotions = false;
        count = 0;
        ctx.viewport.pitch(true);
    }

    @Override
    public void onProcess() {
        super.onProcess();

        if (!botStarted) {
            getTaskItem();
            return;
        }

        if (currentExp != this.ctx.skills.experience(SimpleSkills.Skills.HERBLORE)) {
            count++;
            currentExp = this.ctx.skills.experience(SimpleSkills.Skills.HERBLORE);
        }

        if (ctx.dialogue.dialogueOpen() && !makingStamingPotions) {
            int SPACE_BUTTON = KeyEvent.VK_SPACE;
            ctx.keyboard.clickKey(SPACE_BUTTON);
        }

        SimplePlayer localPlayer = ctx.players.getLocal();
        boolean playerIsAnimating = localPlayer.isAnimating();

        if (makingSuperCombat) {
            if (makingSuperCombats()) {
                if (ctx.bank.bankOpen()) {
                    updateStatus("Closing bank task");
                    ctx.bank.closeBank();
                }

                if (!playerIsAnimating && (System.currentTimeMillis() > (lastAnimation + 3000))) {
                    herbSuperCombatsTask();
                } else if (playerIsAnimating) {
                    lastAnimation = System.currentTimeMillis();
                }
            } else {
                openingBank();
            }
        } else if (makingStamingPotions) {
            boolean unfPotionInv = !ctx.inventory.populate().filter(unfinishedPotionID).isEmpty();
            boolean secondIngredienteInv = !ctx.inventory.populate().filter(secondIngrediente).isEmpty();

            if (unfPotionInv && secondIngredienteInv) {
                if (ctx.bank.bankOpen()) {
                    updateStatus("Closing bank task");
                    ctx.bank.closeBank();
                }
                herbStaminaTask();
            } else {
                openingBank();
            }
        } else {

            boolean unfPotionInv = !ctx.inventory.populate().filter(unfinishedPotionID).isEmpty();
            boolean secondIngredienteInv = !ctx.inventory.populate().filter(secondIngrediente).isEmpty();

            if (unfPotionInv && secondIngredienteInv) {
                if (ctx.bank.bankOpen()) {
                    updateStatus("Closing bank task");
                    ctx.bank.closeBank();
                }

                if (!playerIsAnimating && (System.currentTimeMillis() > (lastAnimation + 3000))) {
                    herbTask();
                } else if (playerIsAnimating) {
                    lastAnimation = System.currentTimeMillis();
                }
            } else {
                openingBank();
            }
        }
    }

    // Banking

    private void openingBank() {
        if (ctx.bank.bankOpen()) {
            updateStatus("Depositing items");
            ctx.bank.depositAllExcept(12640); // Amylase
            updateStatus("Withdrawing herblore supplies");
            if (makingStamingPotions) {
                withdrawItem(unfinishedPotionID, 27);
                withdrawItem(secondIngrediente, 108);
            } else if (makingSuperCombat) {
                withdrawItem(unfinishedPotionID, 7);
                withdrawItem(2440, 7);
                withdrawItem(2436, 7);
                withdrawItem(2442, 7);
            } else {
                withdrawItem(unfinishedPotionID, 14);
                ctx.bank.withdraw(secondIngrediente, 14);
            }
            ctx.onCondition(() -> ctx.inventory.populate().population() > 14, 200, 12);
            updateStatus("Closing bank");
            ctx.bank.closeBank();
            return;
        }

        if (!ctx.bank.bankOpen() && !ctx.players.getLocal().isAnimating()) {
            SimpleObject bankChest = getBankChest();
            if (bankChest != null) {
                updateStatus("Refilling supplies");
                bankChest.click(1);
                ctx.onCondition(() -> ctx.bank.bankOpen(), 200, 12);
            } else {
                SimpleNpc bankerName = getBanker();
                if (bankerName != null) {
                    updateStatus("Refilling supplies");
                    bankerName.click("Bank");
                    ctx.onCondition(() -> ctx.bank.bankOpen(), 200, 12);
                }
            }
        }
    }

    private void withdrawItem(int id, int amount) {
        SimpleItem itemBank = ctx.bank.populate().filter(id).next();
        SimpleItem itemInv = ctx.inventory.populate().filter(id).next();
        if (itemBank != null && itemInv == null) {
            updateStatus("Withdrawing " + itemBank.getName());
            ctx.bank.withdraw(id, amount);
        }
    }
    private SimpleObject getBankChest() {
        SimpleObject bankChest = ctx.objects.populate().filter(BANK_NAME).nearest().next();
        if (bankChest != null && bankChest.distanceTo(ctx.players.getLocal()) <= 10 && bankChest.validateInteractable()) {
            return bankChest;
        }
        return null;
    }

    private SimpleNpc getBanker() {
        SimpleNpc bankerName = ctx.npcs.populate().filter(BANKER_NAME).nearest().next();
        if (bankerName != null && bankerName.distanceTo(ctx.players.getLocal()) <= 10 && bankerName.validateInteractable()) {
            return bankerName;
        }
        return null;
    }

    // Herblore

    private void herbTask() {
        SimpleItem unfPotionInv = ctx.inventory.populate().filter(unfinishedPotionID).reverse().next();
        SimpleItem secondIngredienteInv = ctx.inventory.populate().filter(secondIngrediente).reverse().next();
        boolean suppliesValid = unfPotionInv != null || secondIngredienteInv != null;

        if (!makingStamingPotions) {
            if (ctx.players.getLocal().isAnimating()) {
                return;
            }
        }

        if (!suppliesValid) {
            openingBank();
        } else {
            updateStatus("Making " + nameOfItem);
            clickOnBag();
            ctx.inventory.itemOnItem(unfPotionInv, secondIngredienteInv);
            lastAnimation = System.currentTimeMillis();
        }
    }

    private void herbStaminaTask() {
        SimpleItem unfPotionInv = ctx.inventory.populate().filter(unfinishedPotionID).reverse().next();
        SimpleItem secondIngredienteInv = ctx.inventory.populate().filter(secondIngrediente).next();
        boolean suppliesValid = unfPotionInv != null || secondIngredienteInv != null;

        if (!suppliesValid) {
            openingBank();
        } else {
            if (!ctx.dialogue.dialogueOpen()) {
                updateStatus("Making " + nameOfItem);
                ctx.inventory.itemOnItem(unfPotionInv, secondIngredienteInv);
            } else {
                int SPACE_BUTTON = KeyEvent.VK_SPACE;
                ctx.keyboard.clickKey(SPACE_BUTTON);
                ctx.sleepCondition(() -> unfPotionInv != null, 30000); // maybe ?
            }
        }
    }

    private void herbSuperCombatsTask() {
        SimpleItem unfPotionInv = ctx.inventory.populate().filter(unfinishedPotionID).next();
        SimpleItem superStrenght = ctx.inventory.populate().filter(2440).next();
        SimpleItem superAttack = ctx.inventory.populate().filter(2436).next();
        SimpleItem superDefence = ctx.inventory.populate().filter(2442).next();
        boolean suppliesValid = unfPotionInv != null && superStrenght != null && superAttack != null && superDefence != null;

        if (ctx.players.getLocal().isAnimating()) {
            return;
        }

        if (!suppliesValid) {
            openingBank();
        } else {
            updateStatus("Making " + nameOfItem);
            ctx.inventory.itemOnItem(unfPotionInv, superStrenght);
            lastAnimation = System.currentTimeMillis();
        }
    }

    private boolean makingSuperCombats() {
        boolean unfPotionInv = !ctx.inventory.populate().filter(unfinishedPotionID).isEmpty();
        boolean superStrenght = !ctx.inventory.populate().filter(2440).isEmpty();
        boolean superAttack = !ctx.inventory.populate().filter(2436).isEmpty();
        boolean superDefence = !ctx.inventory.populate().filter(2442).isEmpty();
        return unfPotionInv && superStrenght && superAttack && superDefence;
    }

    private void getTaskItem() {
        PotionItems item = PotionItems.values()[returnItem];
        nameOfItem = item.getNameOfItem();
        unfinishedPotionID = item.getUnfinishedPotionID();
        secondIngrediente = item.getSecondIngrediente();
        makingStamingPotions = item == PotionItems.STAMINA_POTIONS;
        makingSuperCombat = item == PotionItems.SUPER_COMBAT_POTIONS;
    }

    private void clickOnBag() {
        SimpleWidget inventoryBagWidget = ctx.widgets.getWidget(INVENTORY_BAG_WIDGET_ID, INVENTORY_BAG_CHILD_ID);
        if (inventoryBagWidget != null) {
            inventoryBagWidget.click(0);
        }
    }

    //Utility
    public static String currentTime() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    private void updateStatus(String newStatus) {
        status = newStatus;
        ctx.updateStatus(status);
        System.out.println(status);
    }

    public String getPlayerName() {
        if (playerGameName == null) {
            playerGameName = ctx.players.getLocal().getName();
        }
        return playerGameName;
    }

    @Override
    public void onTerminate() {

        // Other vars
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        secondIngrediente = 0;
        unfinishedPotionID = 0;
        makingSuperCombat = false;
        makingStamingPotions = false;
        gui.setVisible(false);

        this.ctx.updateStatus("-------------- " + currentTime() + " --------------");
        this.ctx.updateStatus("----------------------");
        this.ctx.updateStatus("Thank You & Good Luck!");
        this.ctx.updateStatus("----------------------");
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        playerGameName = getPlayerName();

        if (m.getMessage() == null) {
            return;
        }

        if (getType == ChatMessageType.PUBLICCHAT) {
            String senderName = getEvent.getName();

            // Remove any text within angle brackets and trim
            senderName = senderName.replaceAll("<[^>]+>", "").trim();

            if (senderName.contains(playerGameName)) {
                ctx.updateStatus(currentTime() + " Someone asked for you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }

        }
    }

    @Override
    public int loopDuration() {
        return 150;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        long runTime = System.currentTimeMillis() - this.startTime;
        long currentSkillLevel = this.ctx.skills.realLevel(SimpleSkills.Skills.HERBLORE);
        long currentSkillExp = this.ctx.skills.experience(SimpleSkills.Skills.HERBLORE);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = skillExpGained * 3600000L / runTime;
        long actionsPerHour = count * 3600000L / (System.currentTimeMillis() - this.startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString("eHerbloreBot by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + formatTime(runTime), 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString("Potions made: " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + status, 15, 225);

        }
    }

    private String formatTime(long ms) {
        long s = ms / 1000L;
        long m = s / 60L;
        long h = m / 60L;
        s %= 60L;
        m %= 60L;
        h %= 24L;
        return String.format("%02d:%02d:%02d", h, m, s);
    }

}
'''
'''--- src/eIronMinerBotZenyte/eMain.java ---
package eIronMinerBotZenyte;

import BotUtils.eActions;
import BotUtils.eBanking;
import BotUtils.eData;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ItemID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleObjects;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimplePlayer;

import java.awt.*;
import java.util.*;
import java.util.List;

import static eApiAccess.eAutoResponser.*;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.MINING,
        description = "<html>"
                + "<p>The most effective Iron Miner Bot on Zenyte!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>Start near Mining Guild banking chest;</li>"
                + "<li>Recommended <b>to zoom out</b>.</li>"
                + "<li><strong>Have any pickaxe equipped or in inventory.</strong>.</li>"
                + "<li>Dragon pickaxe special attack is supported.</li>"
                + "<li>Chat GPT answering is integrated.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eIronMinerBot",
        servers = {"Zenyte"},
        version = "1"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final String eBotName = "IronMinerBot";
    private static final String ePaintText = "Ores mined";
    private static eAutoResponderGui guiGpt;
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.MINING;
    private static final WorldPoint MINING_POSITION1 = new WorldPoint(3021, 9721, 0);
    private static final WorldPoint MINING_POSITION2 = new WorldPoint(3029, 9720, 0);
    private static final WorldPoint MINING_POSITION3 = new WorldPoint(3024, 9725, 0);
    private static final WorldPoint rockLocation1 = new WorldPoint(3021, 9720, 0);
    private static final WorldPoint rockLocation2 = new WorldPoint(3020, 9721, 0);
    private static final WorldPoint rockLocation3 = new WorldPoint(3021, 9722, 0);
    private static final WorldPoint rockLocation4 = new WorldPoint(3028, 9720, 0);
    private static final WorldPoint rockLocation5 = new WorldPoint(3029, 9721, 0);
    private static final WorldPoint rockLocation6 = new WorldPoint(3030, 9720, 0);
    private static final WorldPoint rockLocation7 = new WorldPoint(3025, 9725, 0);
    private static final WorldPoint rockLocation8 = new WorldPoint(3024, 9726, 0);
    private static final int[] IRON = {7488, 7455};
    private static final int[] INVENTORY_PICKAXE = {20014, 13243, 12797, 12297, 11920, 1275, 1273, 1271, 1269, 1267, 1265, 30742};

    // Variables
    private long startTime = 0L;
    private long startingSkillLevel;
    private long startingSkillExp;
    private int count;
    public static boolean hidePaint = false;
    private int currentExp;

    // Gui GPT
    private void initializeGptGui() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        eBanking bankingUtils = new eBanking(ctx);
        eActions actionUtils = new eActions(ctx);
        eData dataUtils = new eData(ctx);
        eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx)));
        initializeMethods(); // BotUtils
        initializeGptGui(); // GPT
        eAutoResponser.scriptPurpose = "you're mining iron for faster xp. ";
        gptDeactivation();

        // Other vars
        ctx.log("--------------- " + eActions.getCurrentTimeFormatted() + " ---------------");
        ctx.log("-------------------------------------");
        ctx.log("            " + eBotName + "         ");
        ctx.log("-------------------------------------");

        // Vars
        eActions.updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        count = 0;
        ctx.viewport.angle(0);
        ctx.viewport.pitch(true);
        eActions.specialAttackTool = true;
    }

    @Override
    public void onProcess() {
        super.onProcess();

        final SimplePlayer localPlayer = ctx.players.getLocal();

        if (!botStarted) {
            BotUtils.eActions.status = "Please start the bot!";
            return;
        }

        updateExperienceAndCount();

        BotUtils.eActions.handleRunning();

        if (ctx.dialogue.dialogueOpen()) {
            ctx.dialogue.clickContinue();
        }

        SimpleObjects miningRocks = (SimpleObjects) ctx.objects.populate().filter(IRON).filterHasAction("Mine");
        if (ctx.inventory.inventoryFull()) {
            bankTask();
        } else {
            miningTask(miningRocks);
        }

        if (localPlayer.isAnimating()) {
            if (eActions.specialAttackTool) {
                eActions.specialAttack(ItemID.DRAGON_PICKAXE);
            }
        }
    }

    public void bankTask() {
        SimpleObject bankChest = ctx.objects.populate().filter("Bank chest").nearest().next();
        if (bankChest == null || !bankChest.validateInteractable()) {
            return;
        }

        BotUtils.eActions.status = "Banking";
        if (BotUtils.eBanking.bankIsOpen()) {
            ctx.bank.depositAllExcept(INVENTORY_PICKAXE);
            ctx.bank.closeBank();
        } else {
            if (!bankChest.visibleOnScreen()) ctx.pathing.step(bankChest.getLocation());
            BotUtils.eActions.interactWith(bankChest,"Use");
            ctx.onCondition(() -> ctx.bank.bankOpen());
        }
    }

    public void miningTask(SimpleObjects ironObjects) {
        SimpleObject miningRock = ironObjects.nearest().next();

        if (ctx.bank.bankOpen()) ctx.bank.closeBank();

        if (miningRock == null || !miningRock.validateInteractable()) {
            return;
        }

        WorldPoint currentLocation = ctx.players.getLocal().getLocation();
        boolean movedToPosition = false;
        for (WorldPoint position : MINING_POSITION_TO_ORE_MAP.keySet()) {

            if (!miningSpotIsOccupied(position) && !currentLocation.equals(position)) {
                BotUtils.eActions.status = "Getting to mining spot";
                moveToPositionAndMine(miningRock, position);
                movedToPosition = true;
                break;
            }

            if (currentLocation.equals(position)) {
                BotUtils.eActions.status = "Mining...";
                startMining(miningRock);
                movedToPosition = true;
                break;
            }

        }
        if (!movedToPosition) {
            BotUtils.eActions.status = "Waiting for a mining position to free up";
        }
    }

    private void startMining(SimpleObject objectName) {
        if (!ctx.players.getLocal().isAnimating() && !ctx.pathing.inMotion()) BotUtils.eActions.interactWith(objectName, "Mine");
    }
    private static final Map<WorldPoint, WorldPoint[]> MINING_POSITION_TO_ORE_MAP = new LinkedHashMap<WorldPoint, WorldPoint[]>() {{
        put(MINING_POSITION1, new WorldPoint[]{rockLocation1, rockLocation2, rockLocation3});
        put(MINING_POSITION2, new WorldPoint[]{rockLocation4, rockLocation5, rockLocation6});
        put(MINING_POSITION3, new WorldPoint[]{rockLocation7, rockLocation8});
    }};

    private boolean miningSpotIsOccupied(WorldPoint position) {
        return !ctx.players.populate().filterWithin(position, 1)
                .filter(otherPlayer -> !otherPlayer.getName().equals(ctx.players.getLocal().getName())).isEmpty();
    }

    private void moveToPositionAndMine(SimpleObject miningRock, WorldPoint miningPosition) {
        if (miningRock == null) {
            return;
        }

        if (miningPosition == null) {
            return;
        }

        if (ctx.players.getLocal().getLocation() != miningPosition) {
            if (ctx.players.getLocal().getLocation().distanceTo(miningPosition) > 5) {
                ctx.pathing.step(miningPosition);
            }
            ctx.pathing.clickSceneTile(miningPosition, false, true);
            ctx.onCondition(() -> ctx.players.getLocal().getLocation().equals(miningPosition), 400, 4);
        } else {
            BotUtils.eActions.status = "Mining...";
            startMining(miningRock);
        }
    }

    private void updateExperienceAndCount() {
        int newExp = this.ctx.skills.experience(CHOSEN_SKILL);
        if (currentExp != newExp) {
            count++;
            currentExp = newExp;
        }
    }

    private boolean ironMineObjectAppeared(WorldPoint location) {
        return !ctx.objects.populate()
                .filter(o -> o.getLocation().equals(location))
                .filter(IRON)
                .filterHasAction("Mine").isEmpty();
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log(ePaintText + ": " + count);
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();
        eActions.specialAttackTool = false;
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        if (gptStarted && botStarted) eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        eTriviaInfo.handleBroadcastMessage(getType, gameMessage);
    }

    @Override
    public int loopDuration() {
        return 150;
    }

    @Override
    public void paint(Graphics g) {

        // Highlights availabe iron rocks
        if (gptStarted) {
            for (WorldPoint[] oreLocations : MINING_POSITION_TO_ORE_MAP.values()) {
                for (WorldPoint oreTile : oreLocations) {
                    if (oreTile != null) {
                        if (ironMineObjectAppeared(oreTile)) {
                            eActions.drawTileMatrix(ctx, (Graphics2D) g, oreTile, Color.GREEN);
                        } else {
                            eActions.drawTileMatrix(ctx, (Graphics2D) g, oreTile, Color.YELLOW);
                        }
                    }
                }
            }
        }

        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePaintText + ": " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + eActions.status, 15, 225);
        }
    }
}

'''
'''--- src/eMLMBotZenyte/eData.java ---
package eMLMBotZenyte;

import java.util.Arrays;
import java.util.List;

class eData {
    String examineResult;
    String objectName;
    String action;

    public eData(String examineResult, String objectName, String action) {
        this.examineResult = examineResult;
        this.objectName = objectName;
        this.action = action;
    }

    public static List<eData> rocksData = Arrays.asList(
            new eData("mineral vein.", "Ore vein", "Mine")

    );

}

'''
'''--- src/eMLMBotZenyte/eMain.java ---
package eMLMBotZenyte;

import BotUtils.eActions;
import BotUtils.eBanking;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleBank;
import simple.hooks.filters.SimpleInventory;
import simple.hooks.filters.SimpleObjects;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.interfaces.SimpleLocatable;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Game;
import simple.hooks.simplebot.Pathing;
import simple.hooks.wrappers.SimpleGroundItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimplePlayer;

import java.awt.*;
import java.util.List;
import java.util.*;
import java.util.logging.Logger;

import static eApiAccess.eAutoResponser.*;
import static simple.hooks.interaction.menuactions.SimpleMenuActionType.GAME_OBJECT_FIRST_OPTION;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.MINING,
        description = "<html>"
                + "<p>The most effective MLM miner bot!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>Chat GPT answering is integrated.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eMLMBot",
        servers = {"Zenyte"},
        version = "1"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final String eBotName = "eMLMBot";
    private static final String ePaintText = "Pay-dirt mined";
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.MINING;
    private static eAutoResponderGui guiGpt;
    private final Random random = new Random();
    private static final Logger logger = Logger.getLogger(eMain.class.getName());
    private static final String[] BIRD_NEST = {"Bird nest", "Clue nest (beginner)", "Clue nest (easy)", "Clue nest (medium)", "Clue nest (hard)", "Clue nest (elite)"};
    private static final String[] SPECIAL_ATTACK_TOOL = {
            "Dragon pickaxe (or)",
            "Dragon pickaxe"
    };

    private static final String[] MINING_PICKAXE = {
            "Bronze pickaxe",
            "Iron pickaxe",
            "Steel pickaxe",
            "Blessed pickaxe",
            "Gilded pickaxe",
            "3rd age pickaxe",
            "Black pickaxe",
            "Mithril pickaxe",
            "Adamant pickaxe",
            "Rune pickaxe",
            "Dragon pickaxe",
            "Crystal pickaxe"
    };
    private static final String[] BANK_NAME = {"Bank booth", "Bank chest", "Bank counter"};
    private static final String DEPOSIT_BOX = "Bank Deposit Box";
    private static final String[] BANKER_NAME = {"Banker","Bird's-Eye' Jack", "Arnold Lydspor", "Banker tutor", "Cornelius", "Emerald Benedict", "Eniola", "Fadli", "Financial Wizard", "Financial Seer", "Ghost banker", "Gnome banker", "Gundai", "Jade", "Jumaane", "Magnus Gram", "Nardah Banker", "Odovacar", "Peer the Seer", "Sirsal Banker", "Squire", "TzHaar-Ket-Yil", "TzHaar-Ket-Zuh", "Yusuf"};

    // Variables
    private long startTime = 0L;
    private long startingSkillLevel;
    private long startingSkillExp;
    private int count;
    static String status = null;
    public static boolean hidePaint = false;
    private static String objectName;
    private static String actionName;
    private long lastAnimation = -1;
    public static boolean specialAttackTool = true;
    public static boolean redwoodMode;
    private static String triviaAnswer;
    private boolean objectReachable;

    // Gui GPT
    private void initializeGptGUI() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        eBanking bankingUtils = new eBanking(ctx);
        eActions actionUtils = new eActions(ctx);
        BotUtils.eData dataUtils = new BotUtils.eData(ctx);
        eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx)));

        initializeGptGUI();
        eAutoResponser.scriptPurpose = "you're doing some mining. ";
        gptDeactivation();

        // Other vars
        ctx.log("--------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " ---------------");
        ctx.log("-------------------------------------");
        ctx.log("            " + eBotName + "         ");
        ctx.log("-------------------------------------");

        // Vars
        updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        count = 0;
        ctx.viewport.angle(270);
        ctx.viewport.pitch(true);
        lastAnimation = System.currentTimeMillis();
        specialAttackTool = true;
        redwoodMode = false;
        objectName = "Ore vein";
        actionName = "Mine";
    }

    @Override
    public void onProcess() {
        super.onProcess();

        final SimplePlayer localPlayer = ctx.players.getLocal();
        final Pathing pathing = ctx.pathing;
        final SimpleInventory myInventory = ctx.inventory;

        if (!botStarted) {
            BotUtils.eActions.status = "Please start the bot!";
            return;
        }

/*        if (redwoodMode) {
            if (!myInventory.inventoryFull() && !bankIsOpen()) {

                if (localPlayer.getLocation().getPlane() != 1 && ctx.players.getLocal().getLocation().getRegionID() == 6198) {
                    handleRopeLadder(localPlayer, "Climb-up", 1);

                } else {

                    if (!localPlayer.isAnimating() && !pathing.inMotion() && (System.currentTimeMillis() > (lastAnimation + getRandomInt(1200, 3200)))) {
                        miningVain(localPlayer, objectName);
                    } else if (localPlayer.isAnimating()) {
                        lastAnimation = System.currentTimeMillis();
                    }
                }

            } else {
                if (localPlayer.getLocation().getPlane() == 1 && ctx.players.getLocal().getLocation().getRegionID() == 6198) {
                    handleRopeLadder(localPlayer, "Climb-down", 0);
                } else {
                    bankTask();
                }
            }

        }*/

        if (!redwoodMode) {
            if (!myInventory.inventoryFull() && !bankIsOpen()) {

                if (!localPlayer.isAnimating() && !pathing.inMotion() && (System.currentTimeMillis() > (lastAnimation + getRandomInt(1000, 5000)))) {
                    miningVain(localPlayer, objectName);
                } else if (localPlayer.isAnimating()) {
                    lastAnimation = System.currentTimeMillis();
                }

            } else {
                status = "Ready to bank";
                //bankTask();
            }
        }

        if (pathing.energyLevel() > 30 && !pathing.running() && pathing.inMotion()) {
            pathing.running(true);
        }

        if (localPlayer.isAnimating()) {
            if (specialAttackTool) {
                specialAttack(localPlayer);
            }
        }
    }

    // Mining
    private void miningVain(SimplePlayer localPlayer, String objectName) {
        SimpleObjects nearbyVain = (SimpleObjects) ctx.objects.populate().filter(objectName);
        updateStatus("Looking for " + objectName.toLowerCase() + " spots...");

        while (!nearbyVain.isEmpty()) {
            SimpleObject nearestObject = nearbyVain.filterHasAction(actionName).nearest().next();
            WorldPoint theTreeLocation = nearestObject.getLocation();
            boolean isOtherPlayerMining = !ctx.players.populate().filterWithin(theTreeLocation, 2).filter(otherPlayer -> !otherPlayer.getName().equals(ctx.players.getLocal().getName())).isEmpty();

            if (nearbyVain.size() >= 2 && isOtherPlayerMining) {
                updateStatus("Another player is mining the nearest " + objectName.toLowerCase() + ".");
                updateStatus("Looking for another spot...");
                nearbyVain = (SimpleObjects) nearbyVain.filter(other -> !other.equals(nearestObject));
                continue;
            } else {
                if (nearestObject.validateInteractable()) {
                    WorldPoint objectLocation = nearestObject.getLocation();
                    objectReachable = isObjectReachable(objectLocation);

                    if (objectReachable) {
                        updateStatus(objectName + " found " + (objectLocation.distanceTo(ctx.players.getLocal().getLocation())) + " tile(s) away");
                        nearestObject.menuAction(actionName);
                        status = "Mining " + objectName.toLowerCase();
                        updateStatus(status);
                        ctx.onCondition(localPlayer::isAnimating, 250, 10);
                        return;
                    } else {
                        updateStatus("Next " + objectName.toLowerCase() + " spot is not reachable.");
                        nearbyVain = (SimpleObjects) nearbyVain.filter(otherTree -> !otherTree.equals(nearestObject));
                    }
                } else {
                    updateStatus("No " + objectName.toLowerCase() + " found in the vicinity.");
                    return;
                }
            }
        }
        updateStatus("No suitable " + objectName.toLowerCase() + " spot found nearby.");
    }

    private boolean isObjectReachable(WorldPoint objectLocation) {
        int[] offsets = { 0, 1, -1}; // Adjust these offsets as needed
        for (int offsetX : offsets) {
            for (int offsetY : offsets) {
                WorldPoint offsetLocation = new WorldPoint(objectLocation.getX() + offsetX, objectLocation.getY() + offsetY, objectLocation.getPlane());
                if (ctx.pathing.reachable(offsetLocation)) {
                    return true;
                }
            }
        }
        return false;
    }

    private void handleGroundItem() {
        SimpleGroundItem itemToPickup = ctx.groundItems.populate().filter(eMain.BIRD_NEST).nearest().next();

        if (itemToPickup != null && itemToPickup.validateInteractable()) {
            updateStatus(BotUtils.eActions.getCurrentTimeFormatted() + " Found " + itemToPickup.getName());
            if (itemToPickup.click("Take")) {
                ctx.onCondition(() -> ctx.groundItems.populate().filter(eMain.BIRD_NEST).isEmpty(), 250, 12);
            }
        }
    }

    private void specialAttack(SimplePlayer localPlayer) {
        int specialAttackPercentage = ctx.combat.getSpecialAttackPercentage();

        if (specialAttackPercentage != 100) {
            return;
        }

        boolean hasSpecialAttackTool = !ctx.equipment.populate()
                .filter(SPECIAL_ATTACK_TOOL)
                .isEmpty();

        if (!hasSpecialAttackTool) {
            updateStatus(BotUtils.eActions.getCurrentTimeFormatted() + " Special attack tool: NOT FOUND");
            updateStatus(BotUtils.eActions.getCurrentTimeFormatted() + " Special attack: Deactivated");
            specialAttackTool = false;
            return;
        }

        if (localPlayer.isAnimating() && ctx.combat.toggleSpecialAttack(true)) {
            updateStatus(BotUtils.eActions.getCurrentTimeFormatted() + " Used special attack");
            ctx.game.tab(Game.Tab.INVENTORY);
        }
    }

    // Banking
    private void bankTask() {
        int inventoryPopulation = ctx.inventory.populate().population();

        if (bankIsOpen() && inventoryPopulation > 1) {
            updateStatus("Depositing items");
            ctx.bank.depositAllExcept(MINING_PICKAXE);
        }

        if (bankIsOpen() && inventoryPopulation <= 1) {
            updateStatus("Closing bank");
            ctx.bank.closeBank();
            return;
        }

        if (!bankIsOpen()) {
            openClosestBank();
        }
    }

    private void openClosestBank() {
        status = "Banking";

        SimpleObject bankChest = getClosestBankChest();
        SimpleNpc banker = getClosestBanker();
        SimpleObject depositBox = getClosestDepositBox();

        double distToBankChest = (bankChest != null) ? ctx.players.getLocal().getLocation().distanceTo(bankChest.getLocation()) : Double.MAX_VALUE;
        double distToBanker = (banker != null) ? ctx.players.getLocal().getLocation().distanceTo(banker.getLocation()) : Double.MAX_VALUE;
        double distToDepositBox = (depositBox != null) ? ctx.players.getLocal().getLocation().distanceTo(depositBox.getLocation()) : Double.MAX_VALUE;

        // Introduce a preference offset for the bank chest.
        double bankChestPreferenceOffset = 5;  // you can adjust this value
        distToBankChest -= bankChestPreferenceOffset;

        // Determine the closest banking method
        double minDistance = Math.min(distToBankChest, Math.min(distToBanker, distToDepositBox));

        if (minDistance == distToBankChest) {
            useBankObject(bankChest);
        } else if (minDistance == distToBanker) {
            useBanker(banker);
        } else if (minDistance == distToDepositBox) {
            useBankObject(depositBox);
        } else {
            updateStatus("No bank found nearby");
        }
    }

    private void useBankObject(SimpleObject objectName) {
        if (objectName == null) return;
        boolean isBankReachabe = isObjectReachable(objectName.getLocation());

        if (!isBankReachabe) {
            SimpleObject rockFalls = ctx.objects.populate().filter("Rockfall").filter(o -> isObjectReachable(o.getLocation())).filterHasAction("Mine").next();

            if (rockFalls != null) {
                BotUtils.eActions.interactWith(rockFalls, "Mine");
                return;
            }
        }

        if (!objectName.visibleOnScreen() || isWithinRangeToPlayer(objectName)) {
            if (ctx.players.getLocal().getLocation().getRegionID() == 6198) {
                ctx.pathing.step(1591, 3477);
            } else {
                ctx.pathing.step(objectName.getLocation());
            }
        } else {
            objectName.menuAction(GAME_OBJECT_FIRST_OPTION);
            ctx.onCondition(this::bankIsOpen, 250, 20);
        }
    }

    private void useBanker(SimpleNpc bankerNpc) {
        if (bankerNpc == null) return;

        boolean isBankReachabe = isObjectReachable(bankerNpc.getLocation());

        if (!isBankReachabe) {
            SimpleObject rockFalls = ctx.objects.populate().filter("Rockfall").filter(o -> isObjectReachable(o.getLocation())).filterHasAction("Mine").next();

            if (rockFalls != null) {
                BotUtils.eActions.interactWith(rockFalls, "Mine");
                return;
            }
        }

        if (!bankerNpc.visibleOnScreen() || isWithinRangeToPlayer(bankerNpc)) {
            ctx.pathing.step(bankerNpc.getLocation());
        } else {
            bankerNpc.click("Bank");
            ctx.onCondition(this::bankIsOpen, 250, 20);
        }
    }

    private boolean isWithinRangeToPlayer(SimpleLocatable entity) {
        return entity.distanceTo(ctx.players.getLocal()) > 8;
    }

    private SimpleObject getClosestDepositBox() {
        return ctx.objects.populate().filter(DEPOSIT_BOX).nearest().next();
    }

    private SimpleObject getClosestBankChest() {
        return ctx.objects.populate().filter(BANK_NAME).filterHasAction("Bank", "Use").nearest().next();
    }

    private SimpleNpc getClosestBanker() {
        return ctx.npcs.populate().filter(BANKER_NAME).nearest().next();
    }

    private boolean bankIsOpen() {
        SimpleBank bank = ctx.bank;
        return bank.bankOpen() || bank.depositBoxOpen();
    }

    private int getDistanceToPlayer(SimpleLocatable entity) {
        return entity.distanceTo(ctx.players.getLocal());
    }

    private void handleRopeLadder(SimplePlayer localPlayer, String action, int expectedPlane) {
        SimpleObject ropeLadder = ctx.objects.populate().filter("Rope ladder").filterHasAction(action).nearest().next();
        if (!ropeLadder.visibleOnScreen()) {
            ctx.viewport.turnTo(ropeLadder);
            ctx.pathing.step(ropeLadder.getLocation());
        }
        ropeLadder.menuAction(action);
        ctx.onCondition(() -> localPlayer.getLocation().getPlane() == expectedPlane, 250, 4);
    }

    //Utility

    private int getRandomInt(int min, int max) {
        return min + random.nextInt(max - min + 1);
    }

    private void updateStatus(String newStatus) {
        status = newStatus;
        ctx.log(status);
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log(ePaintText + ": " + count);
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();
        objectName = null;
        actionName = null;
        specialAttackTool = false;
        redwoodMode = false;
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        if (getType == ChatMessageType.SPAM) {
            String spamMessage = getEvent.getMessage().toLowerCase();

            if (spamMessage.contains("manage to mine some")) {
                count++;
            }
        }

        if (getType == ChatMessageType.GAMEMESSAGE) {
            String gameMessageLowerCase = gameMessage.toLowerCase();

            if (gameMessageLowerCase.contains("t reach that")) {
                objectReachable = false;
            }
        }

        if (gptStarted && botStarted) eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        eTriviaInfo.handleBroadcastMessage(getType, gameMessage);

        /*        if (getType == ChatMessageType.OBJECT_EXAMINE) {
            String examineMessage = getEvent.getMessage();
            if (examineMessage == null) {
                return;
            }

            for (eData treeData : eData.rocksData) {
                if (examineMessage.contains(treeData.examineResult)) {
                    objectName = treeData.objectName;
                    actionName = treeData.action;
                    redwoodMode = Objects.equals(objectName, "Redwood");
                    updateStatus("New object selected: " + objectName);
                    break;
                }
            }
        }*/
    }

    @Override
    public int loopDuration() {
        return 150;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePaintText + ": " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + status, 15, 225);

        }
    }
}

'''
'''--- src/eMagicPro/eGui.java ---
package eMagicPro;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Objects;
import javax.swing.JOptionPane;

public class eGui extends WindowAdapter {

    public static int returnMode;
    public static int returnSuicide;
    public static String returnNpc;
    public static String returnItem;
    public static Component f;

    public static void eGuiDialogueMode() {
        String[] modeSelect  = {"Only Splashing", "Alch & Splash"};

        ImageIcon eIcon = new ImageIcon(Objects.requireNonNull(eGui.class.getResource("mage-book-logo.png")));

        returnMode = JOptionPane.showOptionDialog(f,
                "\n"
                        + "<html><b>Description:</b></html>\n"
                        + "\n"
                        + "Trains magic effectively while letting you to be away from keyboard. \n"
                        + "You must have required runes and target nearby.\n"
                        + "If you choose \"Only Splashing\" the bot will perform only splashing task.\n"
                        + "If you choose \"Alch & Splash\" the bot will perform both tasks for great xp.\n"
                        + "\n"
                        + "For more information check out Esmaabi on SimpleBot!",
                "eMagicPro by Esmaabi",
                JOptionPane.OK_CANCEL_OPTION, JOptionPane.ERROR_MESSAGE, eIcon, modeSelect, modeSelect[0]);
    }

    public static void eGuiDialogueTarget() {
        String[] targetSelect  = new String[] {"Duck", "Rat", "Man", "Woman", "Goblin", "Imp", "Chicken", "Cow"};

        ImageIcon eIcon = new ImageIcon(Objects.requireNonNull(eGui.class.getResource("mage-book-logo.png")));

        returnNpc = (String) JOptionPane.showInputDialog(f,
                "\n"
                        + "<html><b>Who will be your splashing target?</b></html>\n"
                        + "\n"
                        + "Before starting eMagicPro by Esmaabi you must\n"
                        + "select preferred autocast spell from combat tab\n"
                        + "and choose splashing target from below:\n"
                        + "\n",
                "Choose NPC to splash - eMagicPro by Esmaabi",
                JOptionPane.WARNING_MESSAGE, eIcon, targetSelect, targetSelect[0]);
    }

    public static void eGuiDialogueItem() {

        ImageIcon eIcon = new ImageIcon(Objects.requireNonNull(eGui.class.getResource("mage-book-logo.png")));

        returnItem = (String) JOptionPane.showInputDialog(f,
                "\n"
                        + "<html><b>What do you want to alch?</b></html>\n"
                        + "\n"
                        + "You can type full name of item or part of it.\n"
                        + "For example type: \"mind\" to alch \"Mind rune\"\n"
                        + "you could type \"arrow\" for \"Arrow shafts\" or \"Iron arrow\".\n"
                        + "\n",
                "Type item name to alch - eMagicPro by Esmaabi",
                JOptionPane.WARNING_MESSAGE, eIcon, null, "arrow");
    }

    public static void eGuiDialogueSuicide() {
        String[] suicideMode  = {"Activate", "Deactivate"};

        ImageIcon eIcon = new ImageIcon(Objects.requireNonNull(eGui.class.getResource("mage-book-logo.png")));

        returnSuicide = JOptionPane.showOptionDialog(f,
                "\n"
                        + "<html><b>Do you want to activate anti-ban?</b></html>\n"
                        + "\n"
                        + "Anti-ban will activate when other players are near you bot will\n"
                        + "stop alching task and will proceed only with splashing task\n"
                        + "as long as you are not alone, so you won't look suspicious.\n"
                        + "\n",
                "Anti-ban option - eMagicPro by Esmaabi",
                JOptionPane.OK_CANCEL_OPTION, JOptionPane.ERROR_MESSAGE, eIcon, suicideMode, suicideMode[0]);
    }

    public static void main(String[] args) {
        eGuiDialogueMode();
        eGuiDialogueTarget();
        eGuiDialogueSuicide();
        eGuiDialogueItem();
    }
}

'''
'''--- src/eMagicPro/eMain.java ---
package eMagicPro;

import java.awt.Color;
import java.awt.Graphics;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.stream.Stream;

import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;

import simple.hooks.wrappers.SimpleNpc;
import simple.robot.api.ClientContext;
import simple.robot.script.Script;

@ScriptManifest(author = "Esmaabi", category = Category.MAGIC, description = "<br>"
        + "It's fast & safe magic training method script for Zaros. "
        + "You can splash chosen target and alch specified item. "
        + "It's possible to select anti-ban option during setup.<br><br>"
        + "Script will offer two working modes:<br> \"<b>Only Splashing</b>\" or \"<b>Alch & Splash</b>\"<br><br>"
        + "Before starting script:<br>"
        + "1. You must select autocast spell from combat tab;<br>"
        + "2. You must magic attack: <b>-65</b> & auto retaliate activated;<br>"
        + "3. Also have required runes in inventory (and items if alching).<br>", discord = "Esmaabi#5752",
        name = "eMagicProZaros", servers = { "Zenyte" }, version = "3.1")

public class eMain extends Script{

    //vars
    private long startTime = 0L;
    private long startingSkillLevel;
    private long startingSkillExp;
    private int currentExp;
    private int count;
    static String status = null;
    static String npcName;
    public static State playerState;
    private long lastAnimation = -1;
    private boolean started;

    enum State{
        SPLASHING,
        ALCHING,
        WAITING,
    }

    @Override
    public void onExecute() {
        System.out.println("Started eMagicPro!");
        started = false;
        startTime = System.currentTimeMillis(); //paint
        this.startingSkillLevel = this.ctx.skills.realLevel(SimpleSkills.Skills.MAGIC);//paint
        this.startingSkillExp = this.ctx.skills.experience(SimpleSkills.Skills.MAGIC);//paint
        currentExp = this.ctx.skills.experience(SimpleSkills.Skills.MAGIC);// for actions counter by xp drop
        count = 0;
        npcName = null;
        eGui.returnItem = null;
        eGui.returnSuicide = -1;
        eGui.returnMode = -1;
        status = "Setting up config";

        this.ctx.updateStatus("---------------------");
        this.ctx.updateStatus("      eMagicPro      ");
        this.ctx.updateStatus("---------------------");

        //gui choosing gaming mode
        eGui.eGuiDialogueMode();
        if (eGui.returnMode == 0) {
            playerState = State.SPLASHING;
            ctx.updateStatus(currentTime() + " Starting splashing task");
            if (playerState == State.SPLASHING) {
                eGui.eGuiDialogueTarget();
            }
        } else if (eGui.returnMode == 1) {
            playerState = State.ALCHING;
            ctx.updateStatus(currentTime() + " Starting alching task");
            if (playerState == State.ALCHING) {
                eGui.eGuiDialogueTarget();
                eGui.eGuiDialogueItem();
                eGui.eGuiDialogueSuicide();
            }
        } else if (eGui.returnMode == -1) {
            playerState = State.WAITING;
        }

        // choosing NPC
        if (eGui.returnNpc != null) {
            npcName = eGui.returnNpc;
        } else {
            npcName = null;
        }

        // if script started
        started = eGui.returnMode != -1 && npcName != null;

    }

    @Override
    public void onProcess() {
        if (started) {
            if (playerState == State.ALCHING || playerState == State.SPLASHING) {
                if (currentExp != this.ctx.skills.experience(SimpleSkills.Skills.MAGIC)) {
                    count++;
                    currentExp = this.ctx.skills.experience(SimpleSkills.Skills.MAGIC);
                }
            }

            if (playerState == State.ALCHING) {
                if (ctx.players.population() == 1) {
                    if (!ctx.players.getLocal().isAnimating()) {
                        alchingItem();
                    } else if (ctx.players.getLocal().isAnimating()) {
                        splashingNpc();
                    } else {
                        alchingItem();
                    }
                } else if (ctx.players.population() > 1 && eGui.returnSuicide == 0) {
                    status = "Anti-ban activated";
                    if (!ctx.players.getLocal().isAnimating() && (System.currentTimeMillis() > (lastAnimation + 3000))) {
                        ctx.updateStatus(currentTime() + " Players around -> anti-ban");
                        splashingNpc();
                    } else if (ctx.players.getLocal().isAnimating()) {
                        lastAnimation = System.currentTimeMillis();
                    }
                } else if (ctx.players.population() > 1 && eGui.returnSuicide == 1) {
                    if (!ctx.players.getLocal().isAnimating()) {
                        alchingItem();
                    } else if (ctx.players.getLocal().isAnimating()) {
                        splashingNpc();
                    } else {
                        alchingItem();
                    }
                }

            } else if (playerState == State.WAITING) {
                ctx.updateStatus(currentTime() + " Please choose task");

            } else if (playerState == State.SPLASHING) {
                if (!ctx.players.getLocal().isAnimating() && (System.currentTimeMillis() > (lastAnimation + 3000))) {
                    splashingNpc();
                } else if (ctx.players.getLocal().isAnimating()) {
                    lastAnimation = System.currentTimeMillis();
                }
            }
        }
    }

    public void splashingNpc() {
        SimpleNpc castOn = ctx.npcs.populate().filter(npcName).nearest().next();
        status = "Casting on NPC";
        if (castOn != null && castOn.validateInteractable()) {
            castOn.click("Attack");
        } else {
            status = "NPC not found";
            ctx.updateStatus(currentTime() + " NPC not found");
            ctx.updateStatus(currentTime() + " Stopping script");
            ctx.stopScript();
        }
    }

    public void alchingItem() {
        if (ctx.inventory.populate().filter(getItem(eGui.returnItem)).population() != 0) {
            ctx.updateStatus(currentTime() + " Out of items to alch");
            ctx.updateStatus(currentTime() + " Changing task");
            playerState = State.SPLASHING;
        } else {
            status = "Alching item";
            ctx.magic.castSpellOnItem("High Level Alchemy", getItem(eGui.returnItem));
        }
    }

    public static int getItem(String... itemName) { //Scans for the name of item instead of exact name and gets itemID
        return ClientContext.instance().inventory.populate()
                .filter(p -> Stream.of(itemName).anyMatch(arr -> p.getName().toLowerCase().contains(arr.toLowerCase())))
                .next().getId();
    }

    public static String currentTime() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    @Override
    public void onTerminate() {
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        npcName = null;
        eGui.returnItem = null;
        eGui.returnSuicide = -1;
        eGui.returnMode = -1;

        this.ctx.updateStatus("----------------------");
        this.ctx.updateStatus("Thank You & Good Luck!");
        this.ctx.updateStatus("----------------------");
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        if (m.getMessage() != null) {
            String message = m.getMessage().toLowerCase();
            if (message.contains(ctx.players.getLocal().getName().toLowerCase())) {
                ctx.updateStatus(currentTime() + " Someone asked for you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }
        }
    }

    @Override
    public void paint(Graphics g) {
        Color PhilippineRed = new Color(196, 18, 48);
        Color RaisinBlack = new Color(35, 31, 32, 127);
        g.setColor(RaisinBlack);
        g.fillRect(5, 120, 200, 110);
        g.setColor(PhilippineRed);
        g.drawRect(5, 120, 200, 110);
        g.setColor(PhilippineRed);
        g.drawString("eMagicPro by Esmaabi", 15, 135);
        g.setColor(Color.WHITE);
        long runTime = System.currentTimeMillis() - this.startTime;
        long currentSkillLevel = this.ctx.skills.realLevel(SimpleSkills.Skills.MAGIC);
        long currentSkillExp = this.ctx.skills.experience(SimpleSkills.Skills.MAGIC);
        long SkillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long SkillExpGained = currentSkillExp - this.startingSkillExp;
        long SkillexpPhour = (int)((SkillExpGained * 3600000D) / runTime);
        g.drawString("Runtime: " + formatTime(runTime), 15, 150);
        g.drawString("Starting Level: " + this.startingSkillLevel + " (+" + SkillLevelsGained + ")", 15, 165);
        g.drawString("Current Level: " + currentSkillLevel, 15, 180);
        g.drawString("Exp gained: " + SkillExpGained + " (" + (SkillexpPhour / 1000L) + "k" + " xp/h)", 15, 195);
        g.drawString("Actions made: " + count, 15, 210);
        g.drawString("Status: " + status, 15, 225);
    }

    private String formatTime(long ms) {
        long s = ms / 1000L;
        long m = s / 60L;
        long h = m / 60L;
        s %= 60L;
        m %= 60L;
        h %= 24L;
        return String.format("%02d:%02d:%02d", new Object[] { Long.valueOf(h), Long.valueOf(m), Long.valueOf(s) });
    }

}

'''
'''--- src/eMasterFarmerTZenyte/eMain.java ---
package eMasterFarmerTZenyte;

import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import eRandomEventSolver.eRandomEventForester;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.*;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;

import static eApiAccess.eAutoResponser.*;

@ScriptManifest(author = "Esmaabi", category = Category.THIEVING, description =
                "<br>The most effective Master Farmer thieving bot on Zenyte!<br>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "Start <b>anywhere</b>.<br>"
                + "You must have thieving level 38.<br> "
                + "You must use normal spellbook.<br>"
                + "Healing as low as 6hp!<br>"
                + "Chat GPT answering is integrated.",
        discord = "Esmaabi#5752",
        name = "eMasterFarmerTZenyte", servers = { "Zenyte" }, version = "1")

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    public static eAutoResponderGui guiGpt;
    private static final Logger logger = Logger.getLogger(eMain.class.getName());
    private final SimpleSkills.Skills chosenSkill = SimpleSkills.Skills.THIEVING;

    private final WorldArea EDGE = new WorldArea(new WorldPoint(3110, 3474, 0), new WorldPoint(3074, 3516, 0));
    private final WorldPoint NEAR_BANK_TILE = new WorldPoint(3092, 3247, 0);
    private final WorldPoint NEAR_PORTAL_TILE = new WorldPoint(3096, 3500, 0);
    private static final WorldArea DRAYNOR = new WorldArea (
            new WorldPoint(3071, 3268, 0),
            new WorldPoint(3070, 3247, 0),
            new WorldPoint(3083, 3238, 0),
            new WorldPoint(3107, 3237, 0),
            new WorldPoint(3104, 3273, 0)
    );

    // Variables
    private long startTime = 0L;
    private long startingSkillLevel;
    private long startingSkillExp;
    private int count;
    static String status = null;
    public static boolean hidePaint = false;
    private boolean teleport;

    // Gui GPT
    public void initializeGptGUI() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx)));// Adds tasks to our {task} list for execution

        // Setting up GPT Gui
        eAutoResponser.scriptPurpose = "you're thieving Master Farmer for seeds.";
        eAutoResponser.gptStarted = false;
        initializeGptGUI();
        gptDeactivation();

        // Intro
        System.out.println("Started eMasterFarmerT!");
        this.ctx.log("--------------- " + getCurrentTimeFormatted() + " ---------------");
        this.ctx.log("------------------------------------");
        this.ctx.log("             eMasterFarmerT         ");
        this.ctx.log("------------------------------------");

        // Vars
        updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(chosenSkill);
        this.startingSkillExp = this.ctx.skills.experience(chosenSkill);
        count = 0;
        teleport = false;
        ctx.viewport.pitch(true);

    }

    @Override
    public void onProcess() {
        super.onProcess();

        final Pathing pathing = ctx.pathing;
        final boolean inMotion = ctx.pathing.inMotion();
        final int playerHealth = ctx.combat.health();
        boolean inDraynor = pathing.inArea(DRAYNOR);
        boolean inEdge = pathing.inArea(EDGE);

        if (!botStarted) {
            return;
        }

        if (pathing.energyLevel() > 30 && !pathing.running() && inMotion) {
            pathing.running(true);
        }

        // Check for level
        if (ctx.skills.realLevel(chosenSkill) < 38) {
            status = "Thieving level too low";
            ctx.updateStatus("Stopping script");
            ctx.updateStatus("Thieving level less than 38");
            ctx.stopScript();
        }

        if (inDraynor) {

            if (playerHealth > 6) {
                SimpleNpc masterFarmer = ctx.npcs.populate().filter("Master Farmer").nearest().next();
                if (!ctx.inventory.inventoryFull()) {

                    if (ctx.players.getLocal().getGraphic() != -1) {
                        status = "Stunned";
                        return;
                    }

                    if (masterFarmer != null && masterFarmer.validateInteractable()) {
                        status = "Thieving";
                        masterFarmer.click("Pickpocket");
                    }

                    if (masterFarmer == null) {
                        status = "Taking steps to farmer";
                        pathing.step(3081, 3251);
                        ctx.onCondition(() -> false, 250, 10);
                    }

                    if (ctx.bank.bankOpen()) {
                        ctx.bank.closeBank();
                        return;
                    }

                } else {

                    status = "Banking";

                    if (ctx.players.getLocal().getLocation().distanceTo(NEAR_BANK_TILE) < 10) {
                        SimpleObject bank = ctx.objects.populate().filter("Bank booth").nearest().next();

                        if (ctx.bank.bankOpen()) {
                            ctx.bank.depositInventory();
                            ctx.bank.closeBank();
                            return;
                        }

                        if (!ctx.bank.bankOpen()) {
                            if (bank != null && bank.validateInteractable()) {
                                bank.click("Bank", "Bank booth");
                                ctx.onCondition(() -> ctx.bank.bankOpen(), 250, 10);
                            } else {
                                status = "Taking steps to bank";
                                pathing.step(NEAR_BANK_TILE);
                            }
                        }

                    } else {
                        pathing.step(NEAR_BANK_TILE);
                        ctx.onCondition(() -> ctx.players.getLocal().getLocation().distanceTo(NEAR_BANK_TILE) < 10, 250, 10);
                    }
                }
            }

            if (playerHealth <= 6) {
                if (ctx.magic.castSpellOnce("Zenyte Home Teleport")) {
                    status = "Teleporting to home";
                    ctx.game.tab(Game.Tab.INVENTORY);
                    ctx.onCondition(() -> ctx.players.getLocal().isAnimating(), 300, 10);
                }
            }
        }

        if (inEdge) {

            if (playerHealth <= 6) {
                status = "Restoring hitpoints";
                SimpleObject healingBox = ctx.objects.populate().filter("Box of Restoration").nearest().next();
                if (healingBox != null && healingBox.validateInteractable()) {
                    ctx.sleep(randomSleeping(200, 1800));
                    healingBox.click("Restore", "Box of Restoration");
                    ctx.onCondition(() -> false, 250, 10);
                }
            }

            if (playerHealth > 6) {
                if (!ctx.portalTeleports.portalOpen()) {
                    SimpleObject zenytePortal = ctx.objects.populate().filter("Zenyte Portal").nearest().next();
                    if (zenytePortal != null) {
                        if (!zenytePortal.visibleOnScreen()) {
                            status = "Running to portal";
                            pathing.step(NEAR_PORTAL_TILE);
                        } else {
                            status = "Clicking portal";
                            zenytePortal.click("Teleport", "Zenyte Portal");
                            ctx.onCondition(() -> ctx.portalTeleports.portalOpen(), 250, 10);
                        }
                    }
                } else {
                    status = "Choosing destination...";
                    ctx.portalTeleports.sendTeleport("Cities", "Draynor Village");
                    ctx.game.tab(Game.Tab.INVENTORY);
                    ctx.onCondition(() -> inDraynor, 250, 10);
                }
            }
        }

        if (!inDraynor && !inEdge && !eRandomEventForester.inForesterRandom(ctx) || teleport) {
            status = "I'm lost again...";
            if (ctx.magic.castSpellOnce("Zenyte Home Teleport")) {
                status = "Teleporting to home";
                ctx.game.tab(Game.Tab.INVENTORY);
                ctx.onCondition(() -> ctx.players.getLocal().isAnimating(), 300, 10);
                teleport = false;
            }
        }

    }

    //Utility
    public static String getCurrentTimeFormatted() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    private void updateStatus(String newStatus) {
        status = newStatus;
        ctx.updateStatus(status);
        System.out.println(status);
    }

    @Override
    public void onTerminate() {

        this.ctx.log("-------------- " + getCurrentTimeFormatted() + " --------------");
        this.ctx.log("-----------------------------------");
        this.ctx.log("----- Thank You & Good Luck! ------");
        this.ctx.log("-----------------------------------");

        // Other vars
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();

    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();
        String message = getEvent.getMessage().toLowerCase();

        if (m.getMessage() == null) {
            return;
        }

        if (gptStarted && botStarted) eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        eTriviaInfo.handleBroadcastMessage(getType, gameMessage);

        if (getType == ChatMessageType.SPAM) {
            if (message.contains("successfully pick the master farmer")) {
                count++;
            }
        }

        if (getType == ChatMessageType.SPAM) {
            if (message.contains("this while in combat.")) {
                teleport = true;
            }
        }
    }

    @Override
    public int loopDuration() {
        return 150;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(chosenSkill);
        long currentSkillExp = this.ctx.skills.experience(chosenSkill);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 205, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 205, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString("eMasterFarmerT by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString("Stole seeds: " + count + " (" + ctx.paint.valuePerHour(count, startTime) + " per/h)", 15, 210);
            g.drawString("Status: " + status, 15, 225);

        }
    }
}

'''
'''--- src/eMortMyreFungusZenyte/eMain.java ---
package eMortMyreFungusZenyte;

import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleBank;
import simple.hooks.filters.SimplePrayers;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Game;
import simple.hooks.simplebot.Pathing;
import simple.hooks.wrappers.*;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.MONEYMAKING,
        description = "<html>"
                + "<p>The most effective mort myre fungus collector bot on Zenyte!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>Start with a <strong>Silver Sickle (b)</strong> in your inventory.</li>"
                + "<li>Start with <strong>Dramen staff equipped</strong>.</li>"
                + "<li>Set spiritual tree last location to <strong>BKR</strong></li>"
                + "<li>Zoom out to <strong>center</strong> for best performance.</li>"
                + "<li>Bot will collect Mort Myre Fungus for you!</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eMortMyreFungusZenyte",
        servers = {"Zenyte"},
        version = "0.2"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final int SILVER_SICKLE_ID = 2963;
    private static final int FUNGI_ON_LOG_ID = 3509; //action "Pick" "Fungi on log"
    private static final int MORT_MYRE_FUNGUS_ID = 2970;
    private static final int SPIRITUAL_FAIRY_THEE_ID = 35003; //Ring-last-destination
    private static final int BANKER_ID = 10029;
    private static final String BOX_OF_RESTORATION = "Box of Restoration"; // Restore
    private static String playerGameName;
    public static final WorldArea EDGE_HOME_AREA = new WorldArea(new WorldPoint(3110, 3474, 0), new WorldPoint(3074, 3516, 0));

    // Coordinates
    private final WorldArea homeArea = new WorldArea(new WorldPoint(3101, 3181, 0), new WorldPoint(3074, 3504, 0));
    private final WorldArea swampArea = new WorldArea(new WorldPoint(3480,3449, 0), new WorldPoint(3417,3424, 0));
    private final WorldArea altarArea = new WorldArea(new WorldPoint(2584, 3228, 0), new WorldPoint(2629, 3199, 0));
    private final WorldPoint bloomLocation = new WorldPoint(3431, 3433, 0);
    private final WorldPoint bankerLocation = new WorldPoint(3089, 3495, 0);

    private final WorldPoint[] pathToBloomLocation = {
            new WorldPoint(3463, 3432, 0),
            new WorldPoint(3455, 3433, 0),
            new WorldPoint(3447, 3434, 0),
            new WorldPoint(3438, 3435, 0),
            new WorldPoint(3431, 3434, 0)
    };

    // Variables
    private long startTime = 0L;
    private long prayerLevel;
    private int count;

    public static String status = null;
    private static boolean hidePaint = false;
    private boolean inHome;

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList());// Adds tasks to our {task} list for execution

        // Other vars
        System.out.println("Started eMortMyreFungus!");
        this.ctx.updateStatus("--------------- " + currentTime() + " ---------------");
        this.ctx.updateStatus("-------------------------------");
        this.ctx.updateStatus("         eMortMyreFungus       ");
        this.ctx.updateStatus("-------------------------------");

        // Vars
        updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.prayerLevel = this.ctx.skills.realLevel(SimpleSkills.Skills.PRAYER);
        count = 0;
        ctx.viewport.pitch(true);

    }

    @Override
    public void onProcess() {
        super.onProcess();

        SimplePlayer localPlayer = ctx.players.getLocal();
        Pathing pathing = ctx.pathing;

        if (pathing.energyLevel() > 30 && !pathing.running()) {
            pathing.running(true);
        }

        if (ctx.prayers.points() == 0) {
            teleportToAltar();
        }

        if (pathing.inArea(homeArea)) {

            if (playerReady()) {
                teleportToSwamp();
            } else {
                openingBank();
            }
        }

        if (pathing.inArea(altarArea)) {
            if (ctx.prayers.points() < prayerLevel) {
                restorePrayer();
            } else {
                teleportHomeSpellbook();
            }
        }

        if (pathing.inArea(swampArea)) {
            inHome = false;

            if (!ctx.inventory.inventoryFull()) {
                if (checkFungiOnLog()) {
                    pickingFungi();
                } else {
                    if (pathing.onTile(bloomLocation)) {
                        ctx.viewport.angle(0);
                        ctx.viewport.pitch(true);
                        castBloom();
                    } else {
                        if (localPlayer.getLocation().distanceTo(bloomLocation) > 5) {
                            status = "Getting to blooming location";
                            pathing.walkPath(pathToBloomLocation);
                        } else {
                            pathing.clickSceneTile(bloomLocation, false, true);
                        }
                    }
                }

                if (!ctx.groundItems.populate().filter(MORT_MYRE_FUNGUS_ID).isEmpty()) {
                    SimpleGroundItem groundFungus = ctx.groundItems.populate().filter(MORT_MYRE_FUNGUS_ID).next();

                    if (groundFungus != null && groundFungus.validateInteractable()) {
                        updateStatus("Picking up fungus");
                        groundFungus.menuAction("Take");
                    }
                }

            } else {
                teleportToAltar();
            }
        }
    }

    // Banking
    private void openingBank() {
        if (ctx.bank.bankOpen()) {
            updateStatus("Depositing items");
            int fungiAmount = ctx.inventory.populate().filter(MORT_MYRE_FUNGUS_ID).population();
            count += fungiAmount;
            ctx.bank.depositAllExcept(SILVER_SICKLE_ID);
            handleSickleBank();
            updateStatus("Closing bank");
            ctx.bank.closeBank();
            return;
        }

        SimpleNpc bankerHome = ctx.npcs.populate().filter(BANKER_ID).nearest(bankerLocation).next();
        if (!ctx.bank.bankOpen() && !ctx.pathing.inMotion()) {
            if (bankerHome != null && bankerHome.validateInteractable()) {
                updateStatus("Opening bank");
                bankerHome.click("Bank");
                ctx.onCondition(() -> ctx.bank.bankOpen(), 250, 10);
            }
        }
    }

    private boolean getSickleInventory() {
        SimpleItem silverSicle = ctx.inventory.populate().filter(SILVER_SICKLE_ID).next();
        return silverSicle != null;
    }

    private void handleSickleBank() {
        boolean sicleInInv = getSickleInventory();
        if (sicleInInv) {
            return;
        }

        SimpleItem sickleInBank = ctx.bank.populate().filter(SILVER_SICKLE_ID).next();
        if (sickleInBank == null) {
            updateStatus("No Silver Sickle (b) in bank");
            ctx.updateStatus("Stopping script");
            ctx.sleep(10000);
            ctx.stopScript();
        } else {
            withdrawSickle();
            clearBankSearch();
        }
    }

    private void withdrawSickle() {
        updateStatus("Withdrawing Silver Sickle");
        SimpleWidget quantityOne = ctx.widgets.getWidget(12, 29);
        if (quantityOne != null && !quantityOne.isHidden()) {
            quantityOne.click(0);
        }
        ctx.bank.withdraw(SILVER_SICKLE_ID, SimpleBank.Amount.ONE);
    }

    private void clearBankSearch() {
        SimpleWidget searchButton = ctx.widgets.getWidget(12, 40);
        if (searchButton != null && !searchButton.isHidden()) {
            searchButton.click(0);
        }
    }

    private void restorePrayer() {
        SimplePrayers getPrayPoints = ctx.prayers;
        updateStatus("Restoring prayer points");
        SimpleObject restorBox = ctx.objects.populate().filter("Altar").nearest().next();
        if (restorBox != null && restorBox.validateInteractable()) {
            ctx.pathing.step(2606, 3210);
            int prayerPoints = getPrayPoints.points();
            restorBox.menuAction("Pray-at");
            ctx.sleepCondition(() -> prayerPoints == prayerLevel, randomSleeping(6000, 8000));
        }
    }

    // Mort Myre Swamp tasks
    private void castBloom() {
        if (ctx.prayers.points() == 0) return;
        SimpleItem silverSicle = ctx.inventory.populate().filter(SILVER_SICKLE_ID).next();
        if (silverSicle != null && silverSicle.validateInteractable()) {
            updateStatus("Casting bloom");
            silverSicle.click(2);
            ctx.onCondition(() -> ctx.objects.populate().filter(FUNGI_ON_LOG_ID).population() > 0, randomSleeping(1000, 2000));
        }
    }

    private void pickingFungi() {
        SimpleObject fungiOnLog = ctx.objects.populate().filter(FUNGI_ON_LOG_ID).next();
        updateStatus("Picking up fungi");
        if (fungiOnLog != null && fungiOnLog.validateInteractable()) {
            int funi = ctx.inventory.getFreeSlots();
            fungiOnLog.menuAction("Pick");
            //ctx.sleepCondition(() -> ctx.players.getLocal().getAnimation() != 827 && !ctx.pathing.inMotion(), randomSleeping(2000, 4000));
            ctx.onCondition(() -> ctx.inventory.getFreeSlots() < funi, 200, 20);
        }
    }

    private boolean checkFungiOnLog() {
        return !ctx.objects.populate().filter(FUNGI_ON_LOG_ID).isEmpty();
    }

    private boolean playerReady() {
        boolean dramenStaff = !ctx.equipment.populate().filter(772).isEmpty();
        if (!dramenStaff) {
            updateStatus("No Dramen staff equipped");
        }
        boolean silverSickle = getSickleInventory();
        if (!silverSickle) {
            updateStatus("No Silver Sickle (b) found");
        }
        boolean prayerPoints = ctx.prayers.points() > 50;
        boolean inventoryPopulation = ctx.inventory.populate().population() <= 2;
        return dramenStaff && silverSickle && prayerPoints && inventoryPopulation;
    }

    // Teleproting
    public void teleportToAltar() {
        updateStatus("Teleporting to Home");
        ctx.game.tab(Game.Tab.EQUIPMENT);
        SimpleItem cape = ctx.equipment.populate().filter(n -> n.getItemDefinitions().getName().toLowerCase().contains("ardougne cloak")).next();
        if (cape != null) {
            cape.click("Kandarin Monastery");
            ctx.onCondition(() -> ctx.pathing.inArea(altarArea), 500, 5);
        }
    }

    public void teleportToSwamp() {
        updateStatus("Teleporting to Mort Myre Swamp");

        if (ctx.bank.bankOpen()) {
            ctx.bank.closeBank();
        }

        SimpleObject spiritualTree = ctx.objects.populate().filter(SPIRITUAL_FAIRY_THEE_ID).next();
        if (spiritualTree != null && spiritualTree.validateInteractable()) {
            updateStatus("Clicking the Spiritual tree");
            spiritualTree.menuAction("Ring-last-destination");
            ctx.sleepCondition(() -> swampArea.containsPoint(ctx.players.getLocal().getLocation()), randomSleeping(9000, 12000));
        }
        ctx.game.tab(Game.Tab.INVENTORY);
    }

    public void teleportHomeSpellbook() {
        if (ctx.pathing.inArea(EDGE_HOME_AREA)) return;

        BotUtils.eActions.status = "Teleporting to home";
        BotUtils.eActions.openTab(Game.Tab.MAGIC);

        int widgetNumber;
        switch (ctx.magic.spellBook()) {
            case MODERN:
                widgetNumber = 4;
                ctx.log("Normal magic book");
                break;
            case LUNAR:
                widgetNumber = 99;
                ctx.log("Lunar magic book");
                break;
            case ANCIENT:
                widgetNumber = 98;
                ctx.log("Ancient magic book");
                break;
            case ARCEUUS:
                widgetNumber = 143;
                ctx.log("Areceuus magic book");
                break;
            default:
                widgetNumber = -1;
        }

        if (widgetNumber != -1) {
            ctx.log("Widget: 218, " + widgetNumber);
            clickWidget(widgetNumber);
        }

        //ctx.onCondition(() -> ctx.players.getLocal().getGraphic() != -1 || ctx.pathing.inArea(EDGE_HOME_AREA), 500, 20);
        ctx.sleepCondition(() -> !ctx.pathing.inArea(EDGE_HOME_AREA), randomSleeping(9000, 12000));
        ctx.game.tab(Game.Tab.INVENTORY);
    }

    private void clickWidget(int childId) {
        SimpleWidget widgetToClick = ctx.widgets.getWidget(218, childId);
        if (widgetToClick == null) return;
        widgetToClick.click(0);
    }

    //Utility
    public static int randomSleeping(int minimum, int maximum) {
        return (int)(Math.random() * (maximum - minimum)) + minimum;
    }

    public static String currentTime() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    private void updateStatus(String newStatus) {
        status = newStatus;
        ctx.updateStatus(status);
        System.out.println(status);
    }
    public String getPlayerName() {
        if (playerGameName == null) {
            playerGameName = ctx.players.getLocal().getName();
        }
        return playerGameName;
    }

    @Override
    public void onTerminate() {

        // Other vars
        this.count = 0;

        this.ctx.updateStatus("-------------- " + currentTime() + " --------------");
        this.ctx.updateStatus("----------------------");
        this.ctx.updateStatus("Thank You & Good Luck!");
        this.ctx.updateStatus("----------------------");
    }

    @Override
    public void onChatMessage(ChatMessage m) {

        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        playerGameName = getPlayerName();

        if (m.getMessage() == null) {
            return;
        }

        if (m.getMessage() != null) {
            String message = m.getMessage().toLowerCase();
            if (message.contains("you need to wait")) {
                updateStatus("Cannot restore prayer yet");
            }
        }

        if (getType == ChatMessageType.PUBLICCHAT) {
            String senderName = getEvent.getName();

            // Remove any text within angle brackets and trim
            senderName = senderName.replaceAll("<[^>]+>", "").trim();

            if (senderName.contains(playerGameName)) {
                ctx.updateStatus(currentTime() + " Someone asked for you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }
        }
    }

    @Override
    public int loopDuration() {
        return 150;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        long runTime = System.currentTimeMillis() - this.startTime;

        // Calculate experience and actions per hour
        long actionsPerHour = count * 3600000L / (System.currentTimeMillis() - this.startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            Graphics2D g2d = (Graphics2D) g;
            GradientPaint gradientPaint = new GradientPaint(5, 120, raisinBlack, 220, 230, philippineRed, true);
            g2d.setPaint(gradientPaint);
            g.fillRoundRect(5, 120, 200, 85, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 85, 20, 20);

            Font title = new Font("Arial", Font.BOLD, 12);
            Font text = new Font("Arial", Font.PLAIN, 11);

            g.setFont(title);
            g.setColor(Color.WHITE);
            g.drawString("eMortMyreFungus by Esmaabi", 15, 140);

            g.setFont(text);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + formatTime(runTime), 15, 160);
            g.drawString("Fungi picked: " + count + " (" + actionsPerHour + " per/h)", 15, 175);
            g.drawString("Status: " + status, 15, 190);
        }
    }

    private String formatTime(long ms) {
        long s = ms / 1000L;
        long m = s / 60L;
        long h = m / 60L;
        s %= 60L;
        m %= 60L;
        h %= 24L;
        return String.format("%02d:%02d:%02d", h, m, s);
    }

}
'''
'''--- src/ePlankMakerZenyte/eGui.java ---
package ePlankMakerZenyte;

import javax.swing.*;
import java.awt.*;
import java.util.Objects;

public class eGui extends JFrame {
    public static final String[] ACTION = {"Logs", "Oak", "Teak", "Mahogany"};
    private JComboBox<String> actionComboBox;
    private JCheckBox useStaminaPotionsCheckBox;
    private JButton startButton;
    private JButton pauseButton;

    public eGui() {
        setTitle("ePlankMakerBot");
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        setLocationRelativeTo(null);
        setIconImage(new ImageIcon(Objects.requireNonNull(getClass().getResource("esmaabi-icon.png"))).getImage());

        initGUI();

        pack();
    }

    private void initGUI() {
        JPanel contentPane = new JPanel(new GridBagLayout());
        contentPane.setBackground(Color.DARK_GRAY);
        setContentPane(contentPane);

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.insets = new Insets(5, 5, 5, 5);

        // Add title
        constraints.gridy = 0;
        constraints.gridx = 0;
        constraints.gridwidth = 2;
        constraints.anchor = GridBagConstraints.CENTER;
        addLabel("Please choose options below!", contentPane, constraints, true);

        constraints.gridwidth = 1; // Resetting gridwidth
        constraints.anchor = GridBagConstraints.WEST; // Resetting anchor

        constraints.gridy++; // Moving to next row
        constraints.gridx = 0; // Resetting x-axis position to 0

        // Wood type
        addLabel("Select wood type: ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        actionComboBox = addComboBox(contentPane, constraints);
        actionComboBox.setPreferredSize(new Dimension(150, actionComboBox.getPreferredSize().height));

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row

        // Stamina potions
        addLabel("Use stamina potions? ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        useStaminaPotionsCheckBox = addCheckBox(contentPane, constraints);

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row
        constraints.gridwidth = 2; // Resetting gridwidth
        constraints.anchor = GridBagConstraints.CENTER; // Resetting anchor

        // Start and Pause buttons
        JPanel buttonsPanel = new JPanel(new GridLayout(1, 2, 5, 0));
        startButton = new JButton("Start");
        startButton.addActionListener(e -> startBot());
        startButton.setBackground(Color.GREEN);
        buttonsPanel.add(startButton);
        pauseButton = new JButton("Pause");
        pauseButton.addActionListener(e -> pauseBot());
        pauseButton.setVisible(false); // Setting button invisible
        pauseButton.setBackground(Color.RED);
        buttonsPanel.add(pauseButton);
        contentPane.add(buttonsPanel, constraints);
    }

    private void addLabel(String text, Container container, GridBagConstraints constraints, boolean isTitle) {
        JLabel label = new JLabel(text);
        label.setForeground(Color.WHITE);
        if (isTitle) {
            label.setFont(label.getFont().deriveFont(Font.BOLD, 16));
        }
        container.add(label, constraints);
        constraints.gridx++;
    }

    private JComboBox<String> addComboBox(Container container, GridBagConstraints constraints) {
        JComboBox<String> comboBox = new JComboBox<>(eGui.ACTION);
        container.add(comboBox, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
        return comboBox;
    }

    private void startBot() {
        eMain.botStarted = true;
        pauseButton.setVisible(true);
        startButton.setVisible(false);
        actionComboBox.setEnabled(false);
        useStaminaPotionsCheckBox.setEnabled(false);
        eMain.useStaminaPotions = useStaminaPotionsCheckBox.isSelected();
        getSelectedWoodType();

        if (!eMain.hasStaminaPotions) {
            useStaminaPotionsCheckBox.setEnabled(true);
            useStaminaPotionsCheckBox.setSelected(false); // uncheck the checkbox if there are no stamina potions left
            useStaminaPotionsCheckBox.setEnabled(false);
        }
    }

    private void pauseBot() {
        eMain.botStarted = false;
        pauseButton.setVisible(false);
        startButton.setVisible(true);
        useStaminaPotionsCheckBox.setEnabled(true);
        actionComboBox.setEnabled(true);

        if (!eMain.hasStaminaPotions) {
            useStaminaPotionsCheckBox.setEnabled(true);
            useStaminaPotionsCheckBox.setSelected(false); // uncheck the checkbox if there are no stamina potions left
        }
    }

    private JCheckBox addCheckBox(Container container, GridBagConstraints constraints) {
        JCheckBox checkBox = new JCheckBox();
        container.add(checkBox, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
        return checkBox;
    }

    private void getSelectedWoodType() {
        // Retrieve the selected wood type from the combo box
        String selectedAction = (String) actionComboBox.getSelectedItem();
        eMain.woodTypeEnum selectedWoodTypeEnum = null;

        // Find the corresponding wood type enum based on the selected action
        for (eMain.woodTypeEnum woodName : eMain.woodTypeEnum.values()) {
            if (woodName.name().equalsIgnoreCase(selectedAction)) {
                selectedWoodTypeEnum = woodName;
                break;
            }
        }

        if (selectedWoodTypeEnum != null) {
            eMain.woodType = selectedWoodTypeEnum;
        }
    }
}

'''
'''--- src/ePlankMakerZenyte/eMain.java ---
package ePlankMakerZenyte;

import eRandomEventSolver.eRandomEventForester;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimpleWidget;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.logging.Logger;
import java.util.regex.Pattern;

@ScriptManifest(author = "Esmaabi", category = Category.MONEYMAKING, description =
        "<br>Most effective plank maker bot on Zenyte! <br><br><b>Features & recommendations:</b><br><br>" +
        "<ul>" +
        "<li>This bot will make chosen planks at Woodcutting Guild;</li>" +
        "<li>You must start at Woodcutting Guild near Sawmill operator</li>" +
        "<li>You must have noted logs and GP in inventory or bot will stop</li>" +
        "<li>It's recommended to wear full Graceful or have few stamina potions in inventory</li>" +
        "<li>The bot will stop if you run out of noted logs or coins.</li></ul><br>" +
        "For more information, check out Esmaabi on SimpleBot!", discord = "Esmaabi#5752",
        name = "ePlankMakerBotZenyte", servers = { "Zenyte" }, version = "2")

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private final static int SAWMILL_OPERATOR = 5422;
    private final static int WIDGET_ID = 403;
    private final static int INVENTORY_BAG_WIDGET_ID = 548;
    private final static int INVENTORY_BAG_CHILD_ID = 58;
    private final WorldPoint DEPOSIT_BOX_LOCATION = new WorldPoint(1649, 3494, 0);
    private final WorldPoint NEAR_SAWMILL_LOCATION = new WorldPoint(1624, 3500, 0);

    // Variables
    private static eGui gui;
    private static final Logger logger = Logger.getLogger(eMain.class.getName());
    private long startTime = 0L;
    private int count;
    private int cachedCount;
    private boolean countActive;
    static String status = null;
    public static boolean botStarted = false;
    public static boolean hidePaint = false;
    public static boolean useStaminaPotions;
    public static boolean outOfMoney = false;
    public static woodTypeEnum woodType;
    public static boolean hasStaminaPotions = true;
    private int[] lastCoordinates;
    private static String playerGameName;

    @Override
    public int loopDuration() {
        return 150;
    }

    public enum woodTypeEnum {
        LOGS("normal", 101, 1512, 1511, 961, 960),
        OAK("oak",107, 1522, 1521, 8779, 8778),
        TEAK("teak",112, 6334, 6333, 8781, 8780),
        MAHOGANY("mahogany",117, 8836, 6332, 8783, 8782);

        private final String name;
        private final int widgetId;
        private final int logsNoted;
        private final int logs;
        private final int plankNoted;
        private final int plank;

        woodTypeEnum(String name, int widgetId, int logsNoted, int logs, int plankNoted, int plank) {
            this.name = name;
            this.widgetId = widgetId;
            this.logsNoted = logsNoted;
            this.logs = logs;
            this.plankNoted = plankNoted;
            this.plank = plank;
        }

        public String getName() {
            return name;
        }

        public int getWidgetId() {
            return widgetId;
        }

        public int getLogsNotedId() {
            return logsNoted;
        }

        public int getLogsId() {
            return logs;
        }

        public int getPlankNotedId() {
            return plankNoted;
        }

        public int getPlankId() {
            return plank;
        }
    }

    // Gui
    private void initializeGUI() {
        gui = new eGui();
        gui.setVisible(true);
        gui.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    //Tasks
    List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {
        tasks.addAll(Arrays.asList());
        System.out.println("Started ePlankMakerBot!");
        this.startTime = System.currentTimeMillis(); //paint
        ctx.viewport.angle(90);
        ctx.viewport.pitch(true);
        initializeGUI();

        this.ctx.updateStatus("-------------------------------------");
        this.ctx.updateStatus("--------------- " + currentTime() + " ---------------");
        this.ctx.updateStatus("-------------------------------------");
        status = "Setting up bot";
        count = 0;
        botStarted = false;
        hidePaint = false;
        useStaminaPotions = false;
        countActive = false;
        lastCoordinates = null;
    }

    @Override
    public void onProcess() {
        super.onProcess();

        if (botStarted) {

            int currentCount = getNotedPlanks(woodType.getPlankNotedId());
            handleCount(currentCount);

            if (ctx.pathing.energyLevel() > 30 && !ctx.pathing.running()) {
                ctx.pathing.running(true);
            }

            if (useStaminaPotions) {
                handleDrinkingForEnergy();
            }

            if (ctx.dialogue.dialogueOpen()) {
                processDialogueText();
            }

            if (!outOfMoney) {
                int planksInInventory = getItemsInventory(woodType.getPlankId());
                int logsInInventory = getItemsInventory(woodType.getLogsId());

                // If there are no planks and some logs in the inventory, make planks
                if (planksInInventory == 0 && logsInInventory > 0) {
                    makePlanks(woodType.getWidgetId(), woodType.getLogsId(), woodType.getName());
                }
                // If there are planks and no logs, or no planks and no logs in the inventory, perform note task
                else if ((planksInInventory > 0 && logsInInventory == 0) || (planksInInventory == 0 && logsInInventory == 0)) {
                    noteTask(woodType.getLogsNotedId(), woodType.getLogsId(), woodType.getPlankId(), woodType.getName());
                }
            } else {
                // If out of money, update status and stop the script
                updateStatus("Out of GP. Stopping bot.");
                ctx.stopScript();
            }
        } else {
            status = "Start the bot";
        }
    }

    private void processDialogueText() {
        SimpleWidget operatorText = ctx.widgets.getWidget(231, 4);
        if (operatorText != null && !operatorText.isHidden()) {
            String lowerCaseText = operatorText.getText().toLowerCase();
            if (lowerCaseText.contains("money for all of them")) {
                outOfMoney = true;
            }
        }
    }

    private void makePlanks(int widget, int wood, String name) {
        SimpleWidget plankWindow = ctx.widgets.getWidget(WIDGET_ID, widget);
        SimpleNpc sawmillOperator = ctx.npcs.populate().filter(SAWMILL_OPERATOR).next();
        int woodInv = ctx.inventory.populate().filter(wood).population();
        boolean widgetScreenVisible = plankWindow != null && !plankWindow.isHidden();

        if (woodInv == 0) {
            updateStatus("Out of " + name + " logs");
            ctx.updateStatus(currentTime());
            updateStatus("Stopping script");
            ctx.stopScript();
            return;
        }

        if (!widgetScreenVisible) {
            if (ctx.players.getLocal().getLocation().distanceTo(NEAR_SAWMILL_LOCATION) < 5) {
                if (sawmillOperator != null && sawmillOperator.validateInteractable()) {
                    updateStatus("Clicking Sawmill operator");
                    ctx.viewport.turnTo(sawmillOperator);
                    if (sawmillOperator.click("Buy-plank")) {
                        ctx.onCondition(() -> ctx.widgets.getWidget(WIDGET_ID, widget) != null, 250, 10);
                    }
                }
            } else {
                status = "Running to Sawmill operator";
                ctx.pathing.step(NEAR_SAWMILL_LOCATION);
            }
        } else {
            updateStatus("Making " + name + " planks");
            if (plankWindow.click(5)) {
                ctx.sleepCondition(() -> ctx.widgets.getWidget(WIDGET_ID, widget) != null, 600);
            }
        }
    }

    private void noteTask(int woodNoted, int wood, int plank, String name) {
        SimpleObject depositBox = ctx.objects.populate().filter(26254).nearest(DEPOSIT_BOX_LOCATION).next();

        if (ctx.players.getLocal().getLocation().distanceTo(DEPOSIT_BOX_LOCATION) < 5) {
            if (depositBox != null && depositBox.validateInteractable()) {
                SimpleItem planksInv = ctx.inventory.populate().filter(plank).next();
                SimpleItem notedWoodInv = ctx.inventory.populate().filter(woodNoted).next();
                SimpleItem woodInv = ctx.inventory.populate().filter(wood).next();

                if (woodInv == null && notedWoodInv == null) {
                    updateStatus("Out of " + name + " logs");
                    ctx.updateStatus(currentTime());
                    updateStatus("Stopping script");
                    ctx.stopScript();
                    return;
                }

                if (planksInv != null && woodInv == null) {
                    lastCoordinates = null; // reset lastCoordinates for the next run
                    clickOnBag();
                    updateStatus("Getting " + name + " planks noted");
                    planksInv.click("Use");
                    ctx.sleep(200);
                    if (depositBox.click("Use")) {
                        ctx.onCondition(() -> ctx.inventory.populate().filter(plank).isEmpty(), 250, 10);
                    }
                }

                if (planksInv == null && woodInv == null) {
                    if (notedWoodInv != null) {
                        clickOnBag();
                        updateStatus("Getting " + name + " logs unnoted");
                        notedWoodInv.click("Use");
                        ctx.sleep(200);
                        if (depositBox.click("Use")) {
                            ctx.onCondition(() -> !ctx.inventory.populate().filter(wood).isEmpty(), 250, 10);
                        }
                    }
                }
            }
        } else {
            status = "Running to Bank deposit box";
            choosingPathToBank();
        }
    }

    private void handleDrinkingForEnergy() {
        if (!ctx.pathing.running()) {
            ctx.pathing.running(true);
        }

        if (ctx.pathing.energyLevel() <= 19) {
            final SimpleItem potionInv = ctx.inventory.populate().filter(Pattern.compile("Stamina potion\\(\\d+\\)")).next();
            final int cached = ctx.pathing.energyLevel();
            if (potionInv == null) {
                updateStatus("Stamina potions: deactivated");
                useStaminaPotions = false;
                hasStaminaPotions = false;
                return;
            }

            updateStatus("Drinking stamina potion");
            if (potionInv != null && potionInv.click("Drink")) {
                hasStaminaPotions = true;
                ctx.onCondition(() -> ctx.pathing.energyLevel() > cached, 250, 12);
            }
        }
    }

    private void clickOnBag() {
        SimpleWidget inventoryBagWidget = ctx.widgets.getWidget(INVENTORY_BAG_WIDGET_ID, INVENTORY_BAG_CHILD_ID);
        if (inventoryBagWidget != null) {
            inventoryBagWidget.click(0);
        }
    }

    private void handleCount(int currentCount) {
        if (!countActive) {
            if (count == 0) {
                cachedCount = currentCount;
                countActive = true;
            }
        } else {
            count += (currentCount - cachedCount);
            cachedCount = currentCount;
        }
    }

    private int getNotedPlanks(int notedPlanksId) {
        return ctx.inventory.populate().filter(notedPlanksId).population(true);
    }

    private int getItemsInventory(int itemId) {
        return ctx.inventory.populate().filter(itemId).population();
    }

    public void choosingPathToBank() {
        int max = 6;
        int min = 1;
        int[][] coordinates = {{1649, 3498}, {1649, 3494}, {1647, 3497}, {1650, 3497}, {1647, 3494}, {1648, 3498}};

        if (lastCoordinates == null) {
            // first time running the function, generate a new random location
            int randomNum = ThreadLocalRandom.current().nextInt(min, max + min);
            lastCoordinates = coordinates[randomNum - 1];
        }
        //logger.info(String.valueOf(new WorldPoint(lastCoordinates[0], lastCoordinates[1], 0))); // debug
        ctx.pathing.step(lastCoordinates[0], lastCoordinates[1]);
    }

    private void updateStatus(String newStatus) {
        status = newStatus;
        ctx.updateStatus(status);
        logger.info(status); //debug
    }

    public static String currentTime() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    public String getPlayerName() {
        if (playerGameName == null) {
            playerGameName = ctx.players.getLocal().getName();
        }
        return playerGameName;
    }

    @Override
    public void onTerminate() {
        status = "Stopping bot";
        gui.setVisible(false);
        hidePaint = true;
        outOfMoney = false;

        this.ctx.updateStatus("-------------------------------------");
        this.ctx.updateStatus("--------------- " + currentTime() + " ---------------");
        this.ctx.updateStatus("-------------------------------------");
        this.ctx.updateStatus("------- Thank You & Good Luck! -------");
        this.ctx.updateStatus("-------------------------------------");
        this.ctx.updateStatus("Planks made: " + count);
        this.ctx.updateStatus("-------------------------------------");
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        playerGameName = getPlayerName();

        if (m.getMessage() == null) {
            return;
        }

        if (getType == ChatMessageType.PUBLICCHAT) {
            String senderName = getEvent.getName();

            // Remove any text within angle brackets and trim
            senderName = senderName.replaceAll("<[^>]+>", "").trim();

            if (senderName.contains(playerGameName)) {
                ctx.updateStatus(currentTime() + " Someone asked for you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }

        }
    }

    @Override
    public void paint(Graphics g) {

        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);

        // Calculate experience and actions per hour
        //long actionsPerHour = count * 3600000L / (System.currentTimeMillis() - this.startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            Graphics2D g2d = (Graphics2D) g;
            GradientPaint gradientPaint = new GradientPaint(5, 120, raisinBlack, 220, 230, philippineRed, true);
            g2d.setPaint(gradientPaint);
            g.fillRoundRect(5, 120, 200, 85, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 85, 20, 20);

            Font title = new Font("Arial", Font.BOLD, 12);
            Font text = new Font("Arial", Font.PLAIN, 11);

            g.setFont(title);
            g.setColor(Color.WHITE);
            g.drawString("ePlankMakerBot by Esmaabi", 15, 140);

            g.setFont(text);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 160);
            g.drawString("Planks made: " + count + " (" + actionsPerHour + " per/h)", 15, 175);
            g.drawString("Status: " + status, 15, 190);
        }
    }
}

'''
'''--- src/ePotionBuyerZenyte/eGui.java ---
package ePotionBuyerZenyte;

import javax.swing.*;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.PlainDocument;
import java.awt.*;
import java.util.Arrays;
import java.util.Objects;

public class eGui extends JFrame {
    private static final long serialVersionUID = 1L;
    public static final String[] ACTION = {"Decant", "Bank"};

    private JComboBox<String> actionComboBox;
    private JTextField itemTextField;
    private JButton startButton;
    private JButton pauseButton;

    public eGui() {
        setTitle("ePotionBuyer");
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        setLocationRelativeTo(null);
        setIconImage(new ImageIcon(Objects.requireNonNull(getClass().getResource("esmaabi-icon.png"))).getImage());

        initGUI();

        pack();
    }

    private void initGUI() {
        JPanel contentPane = new JPanel(new GridBagLayout());
        contentPane.setBackground(Color.DARK_GRAY);
        setContentPane(contentPane);

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.insets = new Insets(5, 5, 5, 5);

        // Add title
        constraints.gridy = 0;
        constraints.gridx = 0;
        constraints.gridwidth = 2;
        constraints.anchor = GridBagConstraints.CENTER;
        addLabel("Please choose options below!", contentPane, constraints, true);

        constraints.gridwidth = 1; // Resetting gridwidth
        constraints.anchor = GridBagConstraints.WEST; // Resetting anchor

        constraints.gridy++; // Moving to next row
        constraints.gridx = 0; // Resetting x-axis position to 0

        // Select action
        addLabel("Select action: ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        actionComboBox = addComboBox(contentPane, constraints);
        actionComboBox.setPreferredSize(new Dimension(150, actionComboBox.getPreferredSize().height));

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row

        // Enter NPC ID only as digits
        addLabel("Enter item ID: ", contentPane, constraints, false);
        constraints.gridx = 1; // Setting x-axis position to 1
        itemTextField = addTextField(contentPane, constraints);
        itemTextField.setPreferredSize(new Dimension(150, itemTextField.getPreferredSize().height));

        constraints.gridx = 0; // Resetting x-axis position to 0
        constraints.gridy++; // Moving to next row
        constraints.gridwidth = 2; // Resetting gridwidth
        constraints.anchor = GridBagConstraints.CENTER; // Resetting anchor

        // Start and Pause buttons
        JPanel buttonsPanel = new JPanel(new GridLayout(1, 2, 5, 0));
        startButton = new JButton("Start");
        startButton.addActionListener(e -> startBot());
        startButton.setBackground(Color.GREEN);
        buttonsPanel.add(startButton);
        pauseButton = new JButton("Pause");
        pauseButton.addActionListener(e -> pauseBot());
        pauseButton.setVisible(false); // Setting button invisible
        pauseButton.setBackground(Color.RED);
        buttonsPanel.add(pauseButton);
        contentPane.add(buttonsPanel, constraints);
    }

    private void addLabel(String text, Container container, GridBagConstraints constraints, boolean isTitle) {
        JLabel label = new JLabel(text);
        label.setForeground(Color.WHITE);
        if (isTitle) {
            label.setFont(label.getFont().deriveFont(Font.BOLD, 16));
        }
        container.add(label, constraints);
        constraints.gridx++;
    }

    private JComboBox<String> addComboBox(Container container, GridBagConstraints constraints) {
        JComboBox<String> comboBox = new JComboBox<>(eGui.ACTION);
        container.add(comboBox, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
        return comboBox;
    }

    private JTextField addTextField(Container container, GridBagConstraints constraints) {
        JTextField textField = new JTextField();
        ((PlainDocument) textField.getDocument()).setDocumentFilter(new DigitDocumentFilter());
        container.add(textField, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
        return textField;
    }

    private void startBot() {
        eMain.botStarted = true;
        pauseButton.setVisible(true);
        startButton.setVisible(false);
        itemTextField.setEnabled(false);
        actionComboBox.setEnabled(false);
        //eMain.npcId = getNpcTextField().getText();
        eMain.itemId = getItemId();
        String selectedAction = (String) actionComboBox.getSelectedItem();
        if (Arrays.asList(eGui.ACTION).contains(selectedAction)) {
            eMain.actionName = selectedAction;
        }
    }

    private void pauseBot() {
        eMain.botStarted = false;
        pauseButton.setVisible(false);
        startButton.setVisible(true);
        itemTextField.setEnabled(true);
        actionComboBox.setEnabled(true);
    }

    public JComboBox<String> getActionComboBox() {
        return actionComboBox;
    }

    public JTextField getItemTextField() {
        return itemTextField;
    }

    public int getItemId() {
        String intAsText = getItemTextField().getText();
        int itemId = 0;
        try {
            itemId = Integer.parseInt(intAsText);
        } catch (NumberFormatException e) {
            // Handle the exception, e.g., show an error message or set a default value
        }
        return itemId;
    }

    // DocumentFilter class that accepts only digits
    private static class DigitDocumentFilter extends javax.swing.text.DocumentFilter {
        @Override
        public void insertString(FilterBypass fb, int offset, String string, AttributeSet attr) throws BadLocationException {
            if (string != null && string.chars().allMatch(Character::isDigit)) {
                super.insertString(fb, offset, string, attr);
            }
        }

        @Override
        public void replace(FilterBypass fb, int offset, int length, String text, AttributeSet attrs) throws BadLocationException {
            if (text != null && text.chars().allMatch(Character::isDigit)) {
                super.replace(fb, offset, length, text, attrs);
            }
        }
    }
}

'''
'''--- src/ePotionBuyerZenyte/eMain.java ---
package ePotionBuyerZenyte;

import eRandomEventSolver.eRandomEventForester;
import net.runelite.api.ChatMessageType;
import simple.hooks.filters.SimpleShop;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimpleWidget;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.*;

@ScriptManifest(author = "Esmaabi", category = Category.MONEYMAKING, description =
        "<br>Most effective potion buyer bot on Zenyte! <br><br><b>Features & recommendations:</b><br><br>" +
        "<ul>" +
        "<li>This bot will buy any potion from John and decant it;</li>" +
        "<li>You must start at home with coins in inventory;</li>" +
        "<li>It's also possible to bank other resources from John</li>" +
        "<li>Insert the item ID in GUI and choose starting mode to start</li>" +
        "<li>The bot will stop if you run out of coins.</li></ul><br>" +
        "For more information, check out Esmaabi on SimpleBot!", discord = "Esmaabi#5752",
        name = "ePotionBuyerZenyte", servers = { "Zenyte" }, version = "1")

public class eMain extends TaskScript implements LoopingScript {

    // Variables
    private static eGui gui;
    private long startTime = 0L;
    private int count;
    static String status = null;
    public static boolean botStarted = false;
    public static boolean hidePaint = false;
    public static boolean outOfMoney = false;
    public static String actionName = null;
    private static String playerGameName;

    // Constants
    public static int itemId;
    private static final String[] BANK_TYPES = {"Bank booth", "Bank chest", "Bank deposit box"};
    private static final Set<String> BANKER_NAME_SET = new HashSet<>(Arrays.asList("Banker","Bird's-Eye' Jack", "Arnold Lydspor", "Banker tutor", "Cornelius", "Emerald Benedict", "Eniola", "Fadli", "Financial Wizard", "Financial Seer", "Ghost banker", "Gnome banker", "Gundai", "Jade", "Jumaane", "Magnus Gram", "Nardah Banker", "Odovacar", "Peer the Seer", "Sirsal Banker", "Squire", "TzHaar-Ket-Yil", "TzHaar-Ket-Zuh", "Yusuf"));
    private final static int NPC_ZAHUR = 4753;

    private final static int NPC_JOHN = 10007;

    // Gui
    private void initializeGUI() {
        gui = new eGui();
        gui.setVisible(true);
        gui.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    //Tasks
    List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {
        tasks.addAll(Arrays.asList());
        System.out.println("Started ePotionBuyer!");
        initializeGUI();

        status = "Setting up bot";
        this.startTime = System.currentTimeMillis(); //paint
        count = 0;
        botStarted = false;
        hidePaint = false;
    }

    @Override
    public void onProcess() {
        super.onProcess();

        if (botStarted) {
            if (!outOfMoney) {
                int buyItem = ctx.inventory.populate().filter(itemId).population();
                if (buyItem == 0) {
                    buyingTask(NPC_JOHN, itemId);
                } else if (buyItem > 0) {
                    if (Objects.equals(actionName, "Decant")) {
                        decantTask(NPC_ZAHUR);
                    } else if (Objects.equals(actionName, "Bank")) {
                        openingBank();
                    }
                }
            } else {
                updateStatus("Out of GP. Stopping bot.");
                ctx.stopScript();
            }

        }

    }

    private void buyingTask(int npcId, int itemId) {
        final int SLEEP_DURATION = randomSleeping(4000, 10000);

        if (ctx.inventory.inventoryFull()) {
            updateStatus("Closing shop");
            ctx.shop.closeShop();
            return;
        }

        if (!ctx.shop.shopOpen()) {
            updateStatus("Opening shop");
            SimpleNpc tradeTo = ctx.npcs.populate().filter(npcId).nearest().next();
            if (tradeTo != null && tradeTo.validateInteractable()) {
                tradeTo.click("Trade");
                ctx.sleepCondition(() -> ctx.shop.shopOpen(), 5000);
            }
        }

        if (ctx.shop.shopOpen()) {
            int buyItem = ctx.shop.populate().filter(itemId).population(true);
            updateStatus("Items left in store: " + buyItem);
            if (buyItem < 27) {
                updateStatus("Too few items");
                updateStatus("Sleeping for " + formatToSeconds(SLEEP_DURATION));
                ctx.sleep(SLEEP_DURATION);
            } else {
                updateStatus("Buying from shop");
                ctx.shop.buy(itemId, SimpleShop.Amount.FIFTY);
            }
        }
    }

    private void decantTask(int npcId) {
        int chosenItem = getItemPopulation();

        if (ctx.shop.shopOpen()) {
            updateStatus("Closing shop");
            ctx.shop.closeShop();
        }

        if (chosenItem != 0) {
            chooseWidget(npcId);
        } else {
            updateStatus("No buy item in inventory");
            buyingTask(NPC_JOHN, itemId);
        }
    }

    private void chooseWidget(int npcId) {
        SimpleWidget dialogueOption = ctx.widgets.getWidget(582, 6);

        if (dialogueOption != null) {
            updateStatus("Decanting");
            dialogueOption.click(0);
            int chosenItem = getItemPopulation();
            ctx.onCondition(() -> chosenItem != getItemPopulation(), 250, 10);
            count += chosenItem;
        } else {
            SimpleNpc zahurNpc = ctx.npcs.populate().filter(npcId).nearest().next();
            if (zahurNpc != null && zahurNpc.validateInteractable()) {
                updateStatus("Clicking Zahur");
                zahurNpc.click("Decant");
                ctx.sleepCondition(() -> dialogueOption != null, 1200);
            }
        }
    }

    // Banking
    private void openingBank() {

        if (ctx.shop.shopOpen()) {
            updateStatus("Closing shop");
            ctx.shop.closeShop();
        }

        if (ctx.bank.bankOpen()) {
            updateStatus("Depositing items");
            ctx.bank.depositAllExcept(995); // Coins
            updateStatus("Closing bank");
            ctx.bank.closeBank();
        } else {
            SimpleObject bankObject = getBankObject();
            if (bankObject != null) {
                updateStatus("Banking");
                bankObject.click(1);
                ctx.sleepCondition(() -> ctx.bank.bankOpen(), 5000);
            } else {
                SimpleNpc banker = getBanker();
                if (banker != null) {
                    updateStatus("Banking");
                    banker.click("Bank");
                    ctx.sleepCondition(() -> ctx.bank.bankOpen(), 5000);
                }
            }
        }
    }

    private SimpleObject getBankObject() {
        SimpleObject bankObject = ctx.objects.populate().filter(obj -> Arrays.asList(BANK_TYPES).contains(obj.getName())).nearest().next();
        if (bankObject != null && bankObject.distanceTo(ctx.players.getLocal()) <= 15 && bankObject.validateInteractable()) {
            return bankObject;
        }
        return null;
    }

    private SimpleNpc getBanker() {
        SimpleNpc banker = ctx.npcs.populate().filter(npc -> BANKER_NAME_SET.contains(npc.getName())).nearest().next();
        if (banker != null && banker.distanceTo(ctx.players.getLocal()) <= 15 && banker.validateInteractable()) {
            return banker;
        }
        return null;
    }

    private int getItemPopulation() {
        return ctx.inventory.populate().filter(itemId).population();
    }

    private void updateStatus(String newStatus) {
        status = newStatus;
        ctx.updateStatus(status);
        System.out.println(status);
    }

    public static String currentTime() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    public static int randomSleeping(int minimum, int maximum) {
        return (int)(Math.random() * (maximum - minimum)) + minimum;
    }

    public String getPlayerName() {
        if (playerGameName == null) {
            playerGameName = ctx.players.getLocal().getName();
        }
        return playerGameName;
    }

    @Override
    public void onTerminate() {
        status = "Stopping bot";
        gui.setVisible(false);
        hidePaint = true;
        outOfMoney = false;
        ctx.updateStatus("Bought: " + count + " items");

        this.ctx.updateStatus("-------------- " + currentTime() + " --------------");
        this.ctx.updateStatus("----------------------");
        this.ctx.updateStatus("Thank You & Good Luck!");
        this.ctx.updateStatus("----------------------");
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String message = m.getMessage().toLowerCase();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        playerGameName = getPlayerName();

        if (m.getMessage() == null) {
            return;
        }

        if (message.contains("cannot buy")) {
            outOfMoney = true;
        }

        if (getType == ChatMessageType.PUBLICCHAT) {
            String senderName = getEvent.getName();

            // Remove any text within angle brackets and trim
            senderName = senderName.replaceAll("<[^>]+>", "").trim();

            if (senderName.contains(playerGameName)) {
                ctx.updateStatus(currentTime() + " Someone asked for you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }
        }
    }

    @Override
    public void paint(Graphics g) {

        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);

        // Calculate experience and actions per hour
        //long actionsPerHour = count * 3600000L / (System.currentTimeMillis() - this.startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            Graphics2D g2d = (Graphics2D) g;
            GradientPaint gradientPaint = new GradientPaint(5, 120, raisinBlack, 220, 230, philippineRed, true);
            g2d.setPaint(gradientPaint);
            g.fillRoundRect(5, 120, 200, 85, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 85, 20, 20);

            Font title = new Font("Arial", Font.BOLD, 12);
            Font text = new Font("Arial", Font.PLAIN, 11);

            g.setFont(title);
            g.setColor(Color.WHITE);
            g.drawString("ePotionBuyer by Esmaabi", 15, 140);

            g.setFont(text);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 160);
            g.drawString("Bought: " + count + " (" + actionsPerHour + " per/h)", 15, 175);
            g.drawString("Status: " + status, 15, 190);
        }
    }

    public String formatToSeconds(long ms) {
        double seconds = ms / 1000.0;
        return String.format("%.2f", seconds) + "sec";
    }

    @Override
    public int loopDuration() {
        return 150;
    }
}

'''
'''--- src/eRandomEventSolver/eRandomEventForester.java ---
package eRandomEventSolver;

import net.runelite.api.coords.WorldPoint;
import simple.hooks.scripts.task.Task;
import simple.hooks.wrappers.*;
import simple.robot.api.ClientContext;
import simple.robot.utils.WorldArea;

import java.awt.event.KeyEvent;

public class eRandomEventForester extends Task {

    // Variables
    public static boolean finished;
    public static boolean taskAquired;
    public static int answerPheasantToKill;
    public static int answerDropId;
    public static int droppedItemId;

    static {
        // Initializing the variables
        finished = false;
        taskAquired = false;
        answerPheasantToKill = -1;
        answerDropId = -1;
        droppedItemId = -1;
    }

    // Constants

    public static final int SPACE_BUTTON = KeyEvent.VK_SPACE;

    // Forest area
    public static final WorldArea forestArea = new WorldArea(new WorldPoint(2586, 4788, 0), new WorldPoint(2618, 4762, 0));

    // NPC IDs
    private static final int FREAKY_FORESTER = 372;
    private static final int ONE_TAILED_PHEASANT = 373;
    private static final int TWO_TAILED_PHEASANT = 5500;
    private static final int THREE_TAILED_PHEASANT = 374;
    private static final int FOUR_TAILED_PHEASANT = 5502;

    // Pheasant meat IDs
    private static final int ONE_TAILED_PHEASANT_MEAT = 6178;
    private static final int TWO_TAILED_PHEASANT_MEAT = 6179;
    private static final int THREE_TAILED_PHEASANT_MEAT = 11704;
    private static final int FOUR_TAILED_PHEASANT_MEAT = 28890;

    public eRandomEventForester(ClientContext ctx) {
        super(ctx);
    }

    @Override
    public boolean condition() { // Condition to run this task
        return ctx.pathing.inArea(forestArea);
    }

    @Override
    public void run() {
        processDialogue();

        if (!taskAquired && !finished) {
            talkToForester();
        }

        if (taskAquired && !finished) {
            handleTask();
        }

        if (finished) {
            handleFinishing();
        }
    }

    private void processDialogue() {
        SimpleWidget foresterText = ctx.widgets.getWidget(231, 4);
        SimpleWidget playerText = ctx.widgets.getWidget(217, 4);
        if (ctx.dialogue.dialogueOpen()) {
            if (foresterText != null && !foresterText.isHidden()) {
                processForesterDialogue(foresterText);
            }

            if (playerText != null && !playerText.isHidden()) {
                updateStatus("Processing dialogue");
                ctx.keyboard.clickKey(SPACE_BUTTON);
            }
        }
    }

    private void processForesterDialogue(SimpleWidget foresterText) {
        String lowerCaseText = foresterText.getText().toLowerCase();
        if (lowerCaseText.contains("meat of a pheasant with one")) {
            updatingTask(ONE_TAILED_PHEASANT, ONE_TAILED_PHEASANT_MEAT, "Task acquired: one tail");
        } else if (lowerCaseText.contains("meat of a pheasant with two")) {
            updatingTask(TWO_TAILED_PHEASANT, TWO_TAILED_PHEASANT_MEAT, "Task acquired: two tails");
        } else if (lowerCaseText.contains("meat of a pheasant with three")) {
            updatingTask(THREE_TAILED_PHEASANT, THREE_TAILED_PHEASANT_MEAT, "Task acquired: three tails");
        } else if (lowerCaseText.contains("meat of a pheasant with four")) {
            updatingTask(FOUR_TAILED_PHEASANT, FOUR_TAILED_PHEASANT_MEAT, "Task acquired: four tails");
        } else if (lowerCaseText.contains("well done")) {
            finished = true;
            updateStatus("Task finished");
            ctx.keyboard.clickKey(SPACE_BUTTON);
        } else {
            updateStatus("Processing dialogue");
            ctx.keyboard.clickKey(SPACE_BUTTON);
        }
    }

    private void updatingTask(int pheasantToKill, int dropId, String status) {
        answerPheasantToKill = pheasantToKill;
        answerDropId = dropId;
        updateStatus(status);
        taskAquired = true;
        ctx.keyboard.clickKey(SPACE_BUTTON);
    }

    private void talkToForester() {
        if (!ctx.dialogue.dialogueOpen()) {
            SimpleNpc theForester = ctx.npcs.populate().filter(FREAKY_FORESTER).next();
            if (theForester != null && theForester.validateInteractable()) {
                theForester.click("Talk-to");
                ctx.onCondition(() -> ctx.dialogue.dialogueOpen(), 3000);
            }
        }
    }

    private void handleTask() {
        if (!ctx.dialogue.dialogueOpen()) {
            SimpleNpc taskPheasant = ctx.npcs.populate().filter(answerPheasantToKill).nearest().next();
            SimpleNpc theForester = ctx.npcs.populate().filter(FREAKY_FORESTER).next();
            SimpleItem taskPheasantMeat = ctx.inventory.populate().filter(answerDropId).next();
            if (taskPheasantMeat != null && taskPheasantMeat.validateInteractable()) {
                handleTaskCompletion(theForester);
            } else {
                handlePheasantKillAndPickup(taskPheasant);
            }
        }
    }

    private void handleTaskCompletion(SimpleNpc theForester) {
        updateStatus("Pheasant meat is in inventory");
        if (theForester != null && theForester.validateInteractable()) {
            theForester.click("Talk-to");
            ctx.onCondition(() -> ctx.dialogue.dialogueOpen(), 250, 10);
            taskAquired = false;
        }
    }

    private void handlePheasantKillAndPickup(SimpleNpc taskPheasant) {
        if (ctx.groundItems.populate().filter(answerDropId).isEmpty()) {
            killingPheasant(taskPheasant);
        } else {
            pickupDroppedMeat();
        }
    }

    private void killingPheasant(SimpleNpc taskPheasant) {
        if (taskPheasant != null && taskPheasant.validateInteractable()) {
            taskPheasant.click("Kill");
            ctx.onCondition(() -> !ctx.groundItems.populate().filter(answerDropId).isEmpty(), 250, 10);
        }
    }

    private void pickupDroppedMeat() {
        if (!ctx.inventory.inventoryFull()) {
            SimpleGroundItem droppedMeat = ctx.groundItems.populate().filter(answerDropId).next();
            if (droppedMeat != null && droppedMeat.validateInteractable()) {
                updateStatus("Picking up pheasant meat");
                droppedMeat.click("Take");
                ctx.sleepCondition(() -> !ctx.inventory.populate().filter(answerDropId).isEmpty(), 3000);
            }
        } else {
            freeUpSlots();
        }
    }

    private void handleFinishing() {
        if (droppedItemId != -1) {
            handleDroppedItem();
        }

        SimpleObject finishedPortal = ctx.objects.populate().filter(20843).next(); // Exit portal
        if (finishedPortal != null && finishedPortal.validateInteractable() && droppedItemId == -1) {
            finishedPortal.click("Use");
            ctx.sleepCondition(() -> !ctx.players.getLocal().isAnimating(), 5000);
            if (ctx.players.getLocal().isAnimating()) { // 2110 animation
                resetTaskVariables();
            }
        }
    }

    private void handleDroppedItem() {
        if (ctx.inventory.inventoryFull()) {
            dropTaskPheasantMeat();
        } else {
            pickUpDroppedItem();
        }
    }

    private void dropTaskPheasantMeat() {
        SimpleItem taskPheasantMeat = ctx.inventory.populate().filter(answerDropId).next();
        if (taskPheasantMeat != null && taskPheasantMeat.validateInteractable()) {
            taskPheasantMeat.click("Drop");
            ctx.sleepCondition(() -> ctx.inventory.populate().filter(answerDropId).isEmpty(), 3000);
        }
    }

    private void pickUpDroppedItem() {
        SimpleGroundItem droppedItemEarlier = ctx.groundItems.populate().filter(droppedItemId).next();
        if (droppedItemEarlier != null && droppedItemEarlier.validateInteractable()) {
            droppedItemEarlier.click("Take");
            int cached = ctx.inventory.populate().filter(droppedItemId).population();
            ctx.sleepCondition(() -> ctx.inventory.populate().filter(droppedItemId).population() > cached, 10000);
            updateStatus("Dropped item id: " + droppedItemId + " picked up.");
            droppedItemId = -1;
        }
    }

    private void resetTaskVariables() {
        finished = false;
        taskAquired = false;
        answerPheasantToKill = -1;
        answerDropId = -1;
        droppedItemId = -1;
    }

    private void freeUpSlots() {
        if (droppedItemId != -1) {
            return;
        }

        SimpleItem droppingItem = ctx.inventory.populate().filterHasAction("Drop").next();
        if (droppingItem == null || !droppingItem.validateInteractable()) {
            return;
        }

        ctx.inventory.dropItem(droppingItem);
        droppedItemId = droppingItem.getId();
        updateStatus("Dropped item id: " + droppingItem + " saved.");
    }

    public static boolean inForesterRandom(ClientContext ctx) {
        return ctx.pathing.inArea(forestArea);
    }

    private void updateStatus(String newStatus) {
        String status = newStatus;
        ctx.updateStatus(status);
        System.out.println(status);
    }

    @Override
    public String status() {
        return "eRandom Event Solver Started";
    }
}

'''
'''--- src/eRunecraftingBotZenyte/eGui.java ---
package eRunecraftingBotZenyte;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Objects;

import static eRunecraftingBotZenyte.eMain.status;

public class eGui extends JFrame implements ActionListener {

    private final JComboBox<String> modeSelect;
    private final JButton startButton;
    private final JButton pauseButton;
    private final JButton closeButton;

    public eGui() {
        setTitle("eRunecraftingBot by Esmaabi");
        setLayout(new FlowLayout());
        setSize(550, 250);
        setLocationRelativeTo(null);
        setResizable(false);
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        addWindowListener(new WindowAdapter() {
            @Override
            public void windowOpened(WindowEvent e) {
                super.windowOpened(e);
                JOptionPane.showMessageDialog(null, "Please read the description!");
            }
        });

        ImageIcon eIcon = new ImageIcon(Objects.requireNonNull(eGui.class.getResource("esmaabi-icon.png")));
        setIconImage(eIcon.getImage());

        JPanel topPanel = new JPanel();
        topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.PAGE_AXIS));

        JLabel descriptionLabel = new JLabel("<html><b>Please read <b>eRunecraftingBot</b> description first!</b></html>");
        topPanel.add(descriptionLabel);

        JLabel descriptionText = new JLabel("<html><br><b>Description</b>:<br> " +
                "It is required to have chisel in inventory for <b>Mining</b> and <b>Running Bloods</b> tasks<br> " +
                "Start near dense runestone for <b>Mining</b> task while Zenyte deposit chest is activated<br> " +
                "Start at Crafting Guild with <b>Max cape</b> for other tasks<br><br> " +
                "For more information check out Esmaabi on SimpleBot!</html>");
        topPanel.add(descriptionText);

        add(topPanel, BorderLayout.NORTH);

        JPanel middlePanel = new JPanel();
        middlePanel.setLayout(new BoxLayout(middlePanel, BoxLayout.PAGE_AXIS));

        JLabel modeLabel = new JLabel("Select Mode:");
        middlePanel.add(modeLabel);

        modeSelect = new JComboBox<>(new String[]{
                "Mining",
                "Making dark blocks",
                "Running bloods"
        });
        modeSelect.setSelectedIndex(0);
        middlePanel.add(modeSelect);

        add(middlePanel, BorderLayout.CENTER);

        JPanel bottomPanel = new JPanel();
        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.PAGE_AXIS));

        startButton = new JButton("Start");
        startButton.addActionListener(this);
        bottomPanel.add(startButton);

        pauseButton = new JButton("Pause");
        pauseButton.setVisible(false);
        pauseButton.addActionListener(this);
        bottomPanel.add(pauseButton);

        closeButton = new JButton("Close Gui");
        closeButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                dispose();
            }
        });
        bottomPanel.add(closeButton);

        add(bottomPanel, BorderLayout.SOUTH);

        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (e.getSource() == startButton) {
            if (modeSelect.getSelectedIndex() == 0) {
                eMain.playerState = eMain.State.MINING;
                status = "Mining task started";
                startButton.setVisible(false);
                pauseButton.setVisible(true);
                modeSelect.setEnabled(false);
            } else if (modeSelect.getSelectedIndex() == 1) {
                eMain.playerState = eMain.State.CRAFTING;
                status = "Making dark block task started";
                startButton.setVisible(false);
                pauseButton.setVisible(true);
                modeSelect.setEnabled(false);
            } else if (modeSelect.getSelectedIndex() == 2) {
                eMain.playerState = eMain.State.BLOODCRAFTING;
                status = "Blood rune running task started";
                startButton.setVisible(false);
                pauseButton.setVisible(true);
                modeSelect.setEnabled(false);
            } else {
                eMain.playerState = eMain.State.WAITING;
                status = "Please choose a mode to start";
            }
            eMain.started = modeSelect.getSelectedIndex() != -1;
        } else if (e.getSource() == pauseButton) {
            pauseButton.setVisible(false);
            startButton.setVisible(true);
            modeSelect.setEnabled(true);
            eMain.playerState = eMain.State.WAITING;
            status = "Script is paused";
        }
    }

}
'''
'''--- src/eRunecraftingBotZenyte/eMain.java ---
package eRunecraftingBotZenyte;

import eRandomEventSolver.eRandomEventForester;
import eRunecraftingBotZenyte.listeners.SkillListener;
import eRunecraftingBotZenyte.listeners.SkillObserver;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleBank;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Game;
import simple.hooks.simplebot.Pathing;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.awt.Point;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.BooleanSupplier;
import java.util.regex.Pattern;

import static simple.hooks.filters.SimpleSkills.Skills.*;

@ScriptManifest(author = "Esmaabi", category = Category.RUNECRAFTING, description = " "
        + "Please read <b>eRunecraftingBot</b> description first!</b><br>"
        + "<br><b>Description</b>:<br>"
        + "It is required to have chisel in inventory for <b>Mining</b> and <b>Running Bloods</b> tasks<br>"
        + "Start near dense runestone for <b>Mining</b> task while <b>Zenyte deposit chest</b> is activated<br>"
        + "Start at Crafting Guild with <b>Max cape</b> for other tasks<br><br> "
        + "For more information check out Esmaabi on SimpleBot!", discord = "Esmaabi#5752",
        name = "eRunecraftingBotZenyte", servers = { "Zenyte" }, version = "2.1")

public class eMain extends TaskScript implements SkillListener, LoopingScript {

    // Vars
    public static boolean started;
    private long startTime = 0L;
    public static String status = null;
    public static State playerState;
    private long lastAnimation = -1;
    private int darkBlocks;
    private int bloodRunes;
    private int denseEssence;
    private boolean chiselTask = false;
    boolean runningSkillListener = true;
    private boolean scriptStopped = false;
    private static String playerGameName;
    private static boolean hidePaint;

    // Vars for Paint / Stats
    private static final Color PhilippineRed = new Color(196, 18, 48);
    private static final Color RaisinBlack = new Color(35, 31, 32, 127);
    private static int runecraftingXp, miningXp, craftingXp = 0;
    private static int runecraftingLvl, miningLvl, craftingLvl = 0;
    private static int runecraftingLvlGained, miningLvlGained, craftingLvlGained = 0;
    private static int startingSkillLevelMining, startingSkillLevelCrafting, startingSkillLevelRunecrafting;
    private static int startingSkillExpMining, startingSkillExpCrafting, startingSkillExpRunecrafting;

    // Areas
    private final WorldArea craftingGuild = new WorldArea (new WorldPoint(2938, 3288, 0), new WorldPoint(2929, 3279, 0));
    private final WorldArea arecuusAltarArea = new WorldArea (new WorldPoint(1683, 3893, 0), new WorldPoint(1726, 3872, 0));
    private final WorldArea bloodAltarArea = new WorldArea(new WorldPoint(1710,3836, 0), new WorldPoint(1722,3822, 0));
    private final WorldArea arecuusWholeArea = new WorldArea(new WorldPoint(1745,3898, 0), new WorldPoint(1652,3821, 0));
    private final WorldPoint northDenseObjectLocation = new WorldPoint(1764, 3858, 0);
    private final WorldPoint southDenseObjectLocation = new WorldPoint(1764, 3846, 0);

    private static final WorldArea miningArea = new WorldArea (
            new WorldPoint(1769, 3849, 0),
            new WorldPoint(1770, 3854, 0),
            new WorldPoint(1771, 3860, 0),
            new WorldPoint(1770, 3865, 0),
            new WorldPoint(1762, 3866, 0),
            new WorldPoint(1757, 3862, 0),
            new WorldPoint(1757, 3854, 0),
            new WorldPoint(1758, 3842, 0),
            new WorldPoint(1766, 3840, 0),
            new WorldPoint(1769, 3846, 0));

    private final WorldPoint[] darkAltarToBloodAltar = {
            new WorldPoint(1697, 3880, 0),
            new WorldPoint(1690, 3880, 0),
            new WorldPoint(1684, 3881, 0),
            new WorldPoint(1678, 3881, 0),
            new WorldPoint(1672, 3881, 0),
            new WorldPoint(1667, 3881, 0),
            new WorldPoint(1662, 3881, 0),
            new WorldPoint(1658, 3879, 0),
            new WorldPoint(1658, 3874, 0),
            new WorldPoint(1659, 3870, 0),
            new WorldPoint(1661, 3866, 0),
            new WorldPoint(1665, 3863, 0),
            new WorldPoint(1670, 3862, 0),
            new WorldPoint(1674, 3860, 0),
            new WorldPoint(1679, 3859, 0),
            new WorldPoint(1686, 3858, 0),
            new WorldPoint(1691, 3857, 0),
            new WorldPoint(1696, 3857, 0),
            new WorldPoint(1702, 3857, 0),
            new WorldPoint(1707, 3857, 0),
            new WorldPoint(1713, 3857, 0),
            new WorldPoint(1718, 3856, 0),
            new WorldPoint(1723, 3856, 0),
            new WorldPoint(1728, 3854, 0),
            new WorldPoint(1734, 3851, 0),
            new WorldPoint(1735, 3848, 0),
            new WorldPoint(1735, 3843, 0),
            new WorldPoint(1734, 3837, 0),
            new WorldPoint(1735, 3833, 0),
            new WorldPoint(1733, 3828, 0),
            new WorldPoint(1728, 3826, 0),
            new WorldPoint(1721, 3826, 0),
            new WorldPoint(1719, 3828, 0)
    };

    public static int randomSleeping(int minimum, int maximum) {
        return (int)(Math.random() * (maximum - minimum)) + minimum;
    }

    // Tasks
    private final java.util.List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public int loopDuration() {
        return 150;
    }

    enum State {
        MINING,
        CRAFTING,
        BLOODCRAFTING,
        WAITING,
    }

    @Override
    public void onExecute() {
        tasks.addAll(Arrays.asList());

        System.out.println("Started eRunecraftingBot Zenyte!");
        started = false;
        status = "Setting up config";
        startTime = System.currentTimeMillis(); //paint
        ctx.viewport.angle(90);
        ctx.viewport.pitch(true);
        darkBlocks = 0;
        bloodRunes = 0;
        denseEssence = 0;

        this.ctx.updateStatus("----------------------------------");
        this.ctx.updateStatus("      eRunecraftingBotZenyte      ");
        this.ctx.updateStatus("----------------------------------");

        //Mining
        startingSkillLevelMining = this.ctx.skills.realLevel(SimpleSkills.Skills.MINING);
        startingSkillExpMining = this.ctx.skills.experience(SimpleSkills.Skills.MINING);

        //Crafting
        startingSkillLevelCrafting = this.ctx.skills.realLevel(SimpleSkills.Skills.CRAFTING);
        startingSkillExpCrafting = this.ctx.skills.experience(SimpleSkills.Skills.CRAFTING);

        //Runecrafting
        startingSkillLevelRunecrafting = this.ctx.skills.realLevel(RUNECRAFT);
        startingSkillExpRunecrafting = this.ctx.skills.experience(RUNECRAFT);

        //GUI
        eGui gui = new eGui();
        gui.setVisible(true);

        //skill listener
        runningSkillListener = true;
        SkillObserver skillObserver = new SkillObserver(ctx, new BooleanSupplier() {

            public boolean getAsBoolean() {
                return runningSkillListener;
            }
        });
        skillObserver.addListener(this);
        skillObserver.start();

    }

    @Override
    public void onProcess() {
        super.onProcess();
        if (!started) {
            playerState = State.WAITING;
            return;
        }

        // Running
        if (!ctx.pathing.running()) {
            handleEnergy();
        }

        switch (playerState) {
            case MINING:
                onMiningState();
                break;

            case CRAFTING:
                onCraftingState();
                break;

            case BLOODCRAFTING:
                onBloodCraftingState();
                break;

            default:
                break;
        }
    }

    private void onMiningState() {
        if (!miningArea.containsPoint(ctx.players.getLocal().getLocation())) {
            return;
        }

        if (ctx.inventory.inventoryFull() || ctx.bank.depositBoxOpen()) {
            depositTask();
        } else {
            if (!ctx.players.getLocal().isAnimating() && (System.currentTimeMillis() > (lastAnimation + randomSleeping(600, 8000)))) {
                miningTask();
            } else if (ctx.players.getLocal().isAnimating()) {
                lastAnimation = System.currentTimeMillis();
            }
        }
    }

    private void onCraftingState() {
        if (ctx.inventory.populate().filter(13445).isEmpty()) {
            if (!craftingGuild.containsPoint(ctx.players.getLocal().getLocation())) {
                teleportToBankTask();
            } else {
                bankTask();
            }
        }
        if (!ctx.inventory.populate().filter(13445).isEmpty()) {
            if (craftingGuild.containsPoint(ctx.players.getLocal().getLocation())) {
                teleportToArceuusTask();
            }

            if (arecuusAltarArea.containsPoint(ctx.players.getLocal().getLocation())) {
                venerateTask();
            }
        }
    }

    private void onBloodCraftingState() {
        if (chiselTask) {
            chiselTaskStart();
            return;
        }

        if (!ctx.inventory.populate().filter(13446, 1755).isEmpty()
                && ctx.inventory.populate().filter(7938).isEmpty()
                && (craftingGuild.containsPoint(ctx.players.getLocal().getLocation()) || ctx.pathing.inArea(bloodAltarArea))
                && !chiselTask) {
            status = "Making fragments";
            chiselTask = true;
            chiselTaskStart();
        }

        if (!ctx.inventory.populate().filter(13446).isEmpty() &&
                !ctx.inventory.populate().filter(7938).isEmpty() &&
                craftingGuild.containsPoint(ctx.players.getLocal().getLocation())) {
            teleportToArceuusTask();
            return;
        }

        if (!ctx.inventory.populate().filter(13446).isEmpty() &&
                !ctx.inventory.populate().filter(7938).isEmpty() &&
                arecuusWholeArea.containsPoint(ctx.players.getLocal().getLocation()) &&
                !bloodAltarArea.containsPoint(ctx.players.getLocal().getLocation())) {
            status = "Getting to Blood Altar";
            walkPath(bloodAltarArea, darkAltarToBloodAltar, false);
            return;
        }

        if (ctx.pathing.inArea(bloodAltarArea) && !chiselTask) {
            if (!ctx.inventory.populate().filter(13446).isEmpty() || !ctx.inventory.populate().filter(7938).isEmpty()) {
                status = "Making Blood runes";
                SimpleObject bloodAltar = ctx.objects.populate().filter(27978).nearest().next();
                bloodAltar.click("Bind", "Blood Altar");
                ctx.sleep(2000);
            } else if (ctx.inventory.populate().filter(7938).isEmpty() && ctx.inventory.populate().filter(13446).isEmpty()) {
                bloodRunes += ctx.inventory.populate().filter(565).population(true);
                teleportToBankTask();
            }
        } else if (craftingGuild.containsPoint(ctx.players.getLocal().getLocation()) && !chiselTask &&
                (ctx.inventory.populate().filter(13446).isEmpty() || ctx.inventory.populate().filter(7938).isEmpty())) {
            bankTask();
        }
    }

    // Mining
    private void depositTask() {
        final int BANK_CHEST_ID = 29090;
        SimpleObject depositBox = ctx.objects.populate().filter(BANK_CHEST_ID).filterHasAction("Deposit").nearest().next();

        if (depositBox == null || !depositBox.validateInteractable()) {
            return;
        }

        if (!ctx.bank.depositBoxOpen()) {
            status = "Opening deposit box";
            depositBox.click("Deposit");
            ctx.onCondition(() -> ctx.bank.depositBoxOpen());
        }

        if (ctx.bank.depositBoxOpen()) {
            status = "Depositing inventory";
            ctx.bank.depositAllExcept("Chisel");
            ctx.bank.closeBank();
            ctx.onCondition(() -> !ctx.bank.depositBoxOpen());
        }
    }

    private void miningTask() {
        int southRunestoneImposter = ctx.getClient().getObjectDefinition(10796).getImpostor().getId();
        int northRunestoneImposter = ctx.getClient().getObjectDefinition(8981).getImpostor().getId();

        if (southRunestoneImposter == ObjectID.DEPLETED_RUNESTONE && northRunestoneImposter == ObjectID.DEPLETED_RUNESTONE) {
            status = "Both runestones are depleted";
            //ctx.log("Both runestones are depleted");
            ctx.sleep(3000);
            return;
        }

        if (ctx.combat.getSpecialAttackPercentage() == 100) {
            specialAttack();
        }

        WorldPoint playerLocation = ctx.players.getLocal().getLocation();

        if (southRunestoneImposter == ObjectID.DENSE_RUNESTONE
                && (northRunestoneImposter == ObjectID.DEPLETED_RUNESTONE || playerLocation.distanceTo(southDenseObjectLocation) <= playerLocation.distanceTo(northDenseObjectLocation))) {
            status = "Mining south runestone...";
            clickRunestone(southDenseObjectLocation);
            return;
        }

        if (northRunestoneImposter == ObjectID.DENSE_RUNESTONE) {
            status = "Mining north runestone...";
            clickRunestone(northDenseObjectLocation);
            return;
        }
    }

    private void clickRunestone(WorldPoint location) {
        SimpleObject runestone = ctx.objects.populate().filter("Dense runestone").filterHasAction("Chip").nearest(location).next();
        runestone.click("Chip");
        ctx.onCondition(() -> ctx.players.getLocal().isAnimating(), 250, 20);
    }

    private void specialAttack() { //special attack for mining state
        if (ctx.equipment.populate().filter("Dragon pickaxe").isEmpty()) {
            return;
        }

        if (ctx.pathing.inArea(miningArea)) {
            ctx.combat.toggleSpecialAttack(true);
            ctx.game.tab(Game.Tab.INVENTORY);
        }
    }

    // Banking task for crafting and bloodcrafting states
    private void bankTask() {
        final Pattern STAMINA_POTION_PATTERN = Pattern.compile("Stamina potion\\(\\d+\\)");
        int[] EXCLUDE_STAMINA_POTS = {12625, 12627, 12629, 12631}; // Stamina potions
        int[] EXCLUDE_DEPOSIT_ITEMS = {1755, 7938, 12625, 12627, 12629, 12631}; // Stamina potions and other items
        int ENERGY_THRESHOLD = 30;

        status = "Starting banking task";
        SimpleObject bankChest = ctx.objects.populate().filter(14886).filterHasAction("Use").nearest().next(); // bank chest
        if (bankChest == null || !bankChest.validateInteractable()) {
            return;
        }
        if (!ctx.bank.bankOpen()) {
            status = "Opening bank";
            bankChest.click("Use");
            ctx.onCondition(() -> ctx.bank.bankOpen(), 250, 8);
        } else {

            if (playerState == State.CRAFTING) {
                ctx.bank.depositAllExcept(EXCLUDE_STAMINA_POTS);
                if (ctx.pathing.energyLevel() <= ENERGY_THRESHOLD && ctx.inventory.populate().filter(STAMINA_POTION_PATTERN).isEmpty()) {
                    withdrawItem(12625); // Stamina potion(4)
                }
                if (!ctx.bank.populate().filter(13445).isEmpty()) { // check if there are dense essence blocks in the bank
                    ctx.bank.withdraw(13445, SimpleBank.Amount.ALL);
                } else {
                    ctx.log("No dense blocks in bank");
                    playerState = State.BLOODCRAFTING;
                }
            }
            if (playerState == State.BLOODCRAFTING) {
                ctx.bank.depositAllExcept(EXCLUDE_DEPOSIT_ITEMS); //chisel and dark fragments
                if (ctx.pathing.energyLevel() <= ENERGY_THRESHOLD && ctx.inventory.populate().filter(STAMINA_POTION_PATTERN).isEmpty()) {
                    withdrawItem(12625); // Stamina potion(4)
                }
                if (ctx.inventory.populate().filter(1755).isEmpty()) {
                    System.out.println("Chisel not found in inventory. Withdrawing it.");
                    SimpleWidget quantityOne = ctx.widgets.getWidget(12, 29);
                    if (quantityOne != null && !quantityOne.isHidden()) {
                        quantityOne.click(0);
                    }
                    ctx.bank.withdraw(1755, SimpleBank.Amount.ONE);
                    ctx.onCondition(() -> !ctx.inventory.populate().filter(1755).isEmpty(), randomSleeping(1000, 1500));
                }
                if (!ctx.bank.populate().filter(13446).isEmpty()) { // check if there are dense essence blocks in the bank
                    ctx.bank.withdraw(13446, SimpleBank.Amount.ALL);
                }
            }
            status = "Closing bank";
            ctx.bank.closeBank();
            ctx.onCondition(() -> !ctx.bank.bankOpen());
        }
    }

    // Making dark blocks using altar for crafting state
    private void venerateTask() {
        status = "Clicking Dark Altar";
        SimpleObject darkAltar = ctx.objects.populate().filter(27979).filterHasAction("Venerate").nearest().next();
        if (darkAltar != null && darkAltar.validateInteractable()) {
            darkAltar.click("Venerate");
            ctx.sleepCondition(() -> ctx.inventory.populate().filter(13445).isEmpty(), randomSleeping(2000, 4000));
        }
        darkBlocks += ctx.inventory.populate().filter(13446).population();
    }

    private void walkPath(WorldArea toArea, WorldPoint[] walkPath, boolean reverse) {
        while (!ctx.pathing.inArea(toArea)) {
            if (!ctx.pathing.running()) {
                handleEnergy();
            }

            if (playerState == State.WAITING || scriptStopped) {
                break;
            }

            if (!ctx.pathing.inArea(arecuusWholeArea)) {
                break;
            }

            ctx.pathing.walkPath(walkPath, reverse);
            ctx.sleep(1000);
        }
    }

    private void handleEnergy() {
        Pathing pathing = ctx.pathing;

        if (pathing.energyLevel() >= 30 && !pathing.running()) {
            pathing.running(true);
        }

        if (pathing.energyLevel() < 30) {
            final SimpleItem potion = ctx.inventory.populate().filter(Pattern.compile("Stamina potion\\(\\d+\\)")).filterHasAction("Drink").next();
            final int cached = pathing.energyLevel();
            if (potion == null) {
                return;
            }
            status = ("Drinking " + potion.getName().toLowerCase());
            if (potion != null && potion.click("Drink")) {
                ctx.onCondition(() -> pathing.energyLevel() > cached, 250, 8);
            }
        }
    }

    private void chiselTaskStart() { // Making dark fragments for bloodcrafting state (altar / bank)
        SimpleItem chiselTool = ctx.inventory.populate().filter(1755).next();
        SimpleItem darkEssence = ctx.inventory.populate().filter(13446).reverse().next();
        int sleepTime = randomSleeping(20, 75);
        if (chiselTool != null && chiselTool.validateInteractable()
                && darkEssence != null && darkEssence.validateInteractable()) {
            while (!ctx.inventory.populate().filter(13446).isEmpty()) {
                if (playerState == State.WAITING || scriptStopped) {
                    break;
                }
                chiselTool.click(0);
                ctx.sleep(sleepTime);
                darkEssence.click(0);
                ctx.sleep(sleepTime);
            }
        }
        chiselTask = false;
    }

    //teleporting
    private void teleportToBankTask() { // teleporting for crafting or bloodcrafting state
        status = "Teleporting to Crafting Guild";
        ctx.game.tab(Game.Tab.EQUIPMENT);
        if (!ctx.equipment.populate().filter("Crafting cape(t)").isEmpty()) { // max cape 13342
            SimpleWidget maxCape = ctx.widgets.getWidget(387, 7);//cape slot
            if (maxCape != null && !maxCape.isHidden()) {
                //maxCape.click("Crafting Guild", "Max cape");
                maxCape.click("Teleport", "Crafting cape(t)");
                ctx.sleepCondition(() -> craftingGuild.containsPoint(ctx.players.getLocal().getLocation()), randomSleeping(1000, 3000));
            }
        }
        ctx.game.tab(Game.Tab.INVENTORY);
    }

    private void withdrawItem(int ID) {
        SimpleWidget quantityOne = ctx.widgets.getWidget(12, 29);
        if (quantityOne != null && !quantityOne.isHidden()) {
            quantityOne.click(0);
        }
        ctx.bank.withdraw(ID, SimpleBank.Amount.ONE);
        clearBankSearch();
    }

    private void clearBankSearch() {
        SimpleWidget searchButton = ctx.widgets.getWidget(12, 40);
        if (searchButton != null && !searchButton.isHidden()) {
            searchButton.click(0);
        }
    }

    private void teleportToArceuusTask() { // teleporting for crafting or bloodcrafting state
        status = "Teleporting to Arceuus";
        ctx.game.tab(Game.Tab.MAGIC);
        SimpleWidget homeTeleport = ctx.widgets.getWidget(218, 143);//home teleport
        if (homeTeleport != null & !homeTeleport.isHidden()) {
            homeTeleport.click("Arceuus", "Home Teleport");
            ctx.sleepCondition(() -> arecuusAltarArea.containsPoint(ctx.players.getLocal().getLocation()), randomSleeping(9000, 12000));
        }
        ctx.game.tab(Game.Tab.INVENTORY);
    }

    private static String currentTime() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    private String getPlayerName() {
        if (playerGameName == null) {
            playerGameName = ctx.players.getLocal().getName();
        }
        return playerGameName;
    }

    @Override
    public void onTerminate() {
        if (playerState == State.MINING) {
            this.ctx.updateStatus("Dense runestones mined: " + denseEssence);
        } else if (playerState == State.CRAFTING) {
            this.ctx.updateStatus("Dark blocks made: " + darkBlocks);
        } else if (playerState == State.BLOODCRAFTING) {
            this.ctx.updateStatus("Blood runes crafted: " + bloodRunes);
        }

        //listener
        runningSkillListener = false;

        ///vars
        denseEssence = 0;
        darkBlocks = 0;
        bloodRunes = 0;
        chiselTask = false;
        scriptStopped = true;

        this.ctx.updateStatus("----------------------");
        this.ctx.updateStatus("Thank You & Good Luck!");
        this.ctx.updateStatus("----------------------");
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        playerGameName = getPlayerName();

        if (m.getMessage() == null) {
            return;
        }

        if (getType == ChatMessageType.PUBLICCHAT) {
            String senderName = getEvent.getName();

            // Remove any text within angle brackets and trim
            senderName = senderName.replaceAll("<[^>]+>", "").trim();

            if (senderName.contains(playerGameName) && !getEvent.getMessage().toLowerCase().contains("smashing")) {
                ctx.updateStatus(currentTime() + " Someone asked from you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }

            if (!senderName.contains(playerGameName) && getEvent.getMessage().toLowerCase().contains(playerGameName.toLowerCase())) {
                ctx.updateStatus(currentTime() + " Someone asked for you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }
        }
    }

    @Override
    public void paint(Graphics g) {
        Point mousePos = ctx.mouse.getPoint();

        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 225, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        if (!hidePaint) {
            // Settings for Paint
            g.setColor(RaisinBlack);
            g.fillRoundRect(5, 120, 225, 110, 20, 20);
            g.setColor(PhilippineRed);
            g.drawRoundRect(5, 120, 225, 110, 20, 20);
            g.setColor(PhilippineRed);
            g.drawString("eRunecraftingBot by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Status: " + status, 15, 225);

            // Settings for playerState
            if (playerState == State.MINING) {
                long SkillExpGained = miningXp - startingSkillExpMining;
                long SkillExpGained2 = craftingXp - startingSkillExpCrafting;
                long expGainedTotal = SkillExpGained + SkillExpGained2;
                long totalExpPerHour = ctx.paint.valuePerHour((int) expGainedTotal, startTime);
                long itemsPerHour = ctx.paint.valuePerHour(denseEssence, startTime);
                g.drawString("Starting: Mining " + startingSkillLevelMining + " (+" + miningLvlGained + ")," + " Crafting " + startingSkillLevelCrafting + " (+" + craftingLvlGained + ")", 15, 165);
                g.drawString("Current: Mining " + miningLvl + ", Crafting " + craftingLvl, 15, 180);
                g.drawString("Exp gained: " + expGainedTotal + " (" + (totalExpPerHour / 1000L) + "k" + " xp/h)", 15, 195);
                g.drawString("Dense mined: " + denseEssence + " (" + itemsPerHour + " / h)", 15, 210);

            } else {
                long SkillExpGained = runecraftingXp - startingSkillExpRunecrafting;
                long SkillExpGained2 = craftingXp - startingSkillExpCrafting;
                long expGainedTotal = SkillExpGained + SkillExpGained2;
                long totalExpPerHour = ctx.paint.valuePerHour((int) expGainedTotal, startTime);
                long itemsPerHour1 = ctx.paint.valuePerHour(darkBlocks, startTime);
                long itemsPerHour2 = ctx.paint.valuePerHour(bloodRunes, startTime);
                g.drawString("Starting: RuneCraft " + startingSkillLevelRunecrafting + " (+" + runecraftingLvlGained + ")," + " Crafting " + startingSkillLevelCrafting + " (+" + craftingLvlGained + ")", 15, 165);
                g.drawString("Current: RuneCraft " + runecraftingLvl + ", Crafting " + craftingLvl, 15, 180);
                g.drawString("Exp gained: " + expGainedTotal + " (" + (totalExpPerHour / 1000L) + "k" + " xp/h)", 15, 195);
                g.drawString("Blocks: " + darkBlocks + " (" + itemsPerHour1 + " / h), Bloods: " + bloodRunes + " (" + itemsPerHour2 + " / h)", 15, 210);
            }
        }
    }

    @Override
    public void skillLevelAdded(SimpleSkills.Skills skill, int current, int previous, int gained) {
        //ctx.log("We gained %d levels in %s, we went from +%d to %d. ", gained, skill.toString(), previous, current);
        if (skill == CRAFTING) {
            craftingLvl = current;
            craftingLvlGained = gained;
        }

        if (skill == RUNECRAFT) {
            runecraftingLvl = current;
            runecraftingLvlGained = gained;
        }

        if (skill == MINING) {
            miningLvl = current;
            miningLvlGained = gained;
        }

    }

    @Override
    public void skillExperienceAdded(SimpleSkills.Skills skill, int current, int previous, int gained) {
        //ctx.log("We gained %d experience in %s, we went from +%d to %d. ", gained, skill.toString(), previous, current);

        if (skill == CRAFTING) {
            craftingXp = current;
        }

        if (skill == RUNECRAFT) {
            runecraftingXp = current;
        }

        if (skill == MINING) {
            miningXp = current;
        }

        if (playerState == State.MINING) {
            if (skill == CRAFTING) {
                denseEssence++;
            }
        }
    }

}

'''
'''--- src/eRunecraftingBotZenyte/listeners/SkillListener.java ---
package eRunecraftingBotZenyte.listeners;

import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.task.Task;

import java.util.List;

public interface SkillListener {
    boolean prioritizeTasks();

    List<Task> tasks();

    void skillLevelAdded(SimpleSkills.Skills skill, int current, int previous, int gained);
    void skillExperienceAdded(SimpleSkills.Skills skill, int current, int previous, int gained);
}

'''
'''--- src/eRunecraftingBotZenyte/listeners/SkillObserver.java ---
package eRunecraftingBotZenyte.listeners;

import net.runelite.api.GameState;
import simple.hooks.filters.SimpleSkills;
import simple.robot.api.ClientContext;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.function.BooleanSupplier;

public class SkillObserver extends Thread {

    private ArrayList<SkillListener> listeners;
    private BooleanSupplier condition;
    private ClientContext ctx;

    public SkillObserver(ClientContext ctx, BooleanSupplier condition) {
        this.ctx = ctx;
        this.listeners = new ArrayList<>();
        this.condition = condition;
    }

    @Override
    public void run() {
        while (ctx.getClient().getGameState() != GameState.LOGGED_IN) {
            ctx.sleep(500);
        }

        HashMap<SimpleSkills.Skills, Integer> experienceMap = skillExperienceHashMap();
        HashMap<SimpleSkills.Skills, Integer> levelMap = skillLevelHashMap();
        while (true) {
            ctx.sleep(100);
            if (ctx.getClient().getGameState() != GameState.LOGGED_IN) continue;
            if (!condition.getAsBoolean()) {
                experienceMap = skillExperienceHashMap();
                levelMap = skillLevelHashMap();
                continue;
            }

            HashMap<SimpleSkills.Skills, Integer> updatedExperienceMap = skillExperienceHashMap();
            HashMap<SimpleSkills.Skills, Integer> updatedLevelMap = skillLevelHashMap();

            for (Map.Entry<SimpleSkills.Skills, Integer> entry : updatedExperienceMap.entrySet()) {
                if (experienceMap.containsKey(entry.getKey())) {
                    int cached = experienceMap.get(entry.getKey());
                    if (entry.getValue() != cached) {
                        experienceTrigger(entry.getKey(), entry.getValue(), cached, (entry.getValue() - cached));
                    }
                }
            }

            for (Map.Entry<SimpleSkills.Skills, Integer> entry : updatedLevelMap.entrySet()) {
                if (levelMap.containsKey(entry.getKey())) {
                    int cached = levelMap.get(entry.getKey());
                    if (entry.getValue() != cached) {
                        levelTrigger(entry.getKey(), entry.getValue(), cached, (entry.getValue() - cached));
                    }
                }
            }

            experienceMap = skillExperienceHashMap();
            levelMap = skillLevelHashMap();
        }
    }

    private HashMap<SimpleSkills.Skills, Integer> skillExperienceHashMap() {
        HashMap<SimpleSkills.Skills, Integer> map = new HashMap<>();
        for (SimpleSkills.Skills skill : SimpleSkills.Skills.values()) {
            map.put(skill, ctx.skills.experience(skill));
        }
        return map;
    }

    private HashMap<SimpleSkills.Skills, Integer> skillLevelHashMap() {
        HashMap<SimpleSkills.Skills, Integer> map = new HashMap<>();
        for (SimpleSkills.Skills skill : SimpleSkills.Skills.values()) {
            map.put(skill, ctx.skills.level(skill));
        }
        return map;
    }

    public void addListener(SkillListener skillListener) {
        listeners.add(skillListener);
    }

    public void experienceTrigger(SimpleSkills.Skills skill, int current, int previous, int gained) {
        for (SkillListener l : listeners) l.skillExperienceAdded(skill, current, previous, gained);
    }

    public void levelTrigger(SimpleSkills.Skills skill, int current, int previous, int gained) {
        for (SkillListener l : listeners) l.skillLevelAdded(skill, current, previous, gained);
    }

}

'''
'''--- src/eSacredEelBotZenyte/eGui.java ---
package eSacredEelBotZenyte;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Objects;

public class eGui extends JFrame implements ActionListener {

    private final JButton startButton;
    private final JButton pauseButton;
    private final JButton closeButton;

    public eGui() {
        setTitle("eSacredEelZenyte by Esmaabi");
        setLayout(new FlowLayout());
        setSize(450, 225);
        setLocationRelativeTo(null);
        setResizable(false);
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

        ImageIcon eIcon = new ImageIcon(Objects.requireNonNull(eGui.class.getResource("esmaabi-icon.png")));
        setIconImage(eIcon.getImage());

        JPanel topPanel = new JPanel();
        topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.PAGE_AXIS));

        JLabel descriptionLabel = new JLabel("<html><b>Please read <b>eSacredEelBotZenyte</b> description first!</b></html>");
        topPanel.add(descriptionLabel);

        JLabel descriptionText = new JLabel("<html><br><b>Description</b>:<br> " +
                "It is required to have <b>Fishing rod</b>, <b>Fishing bait</b> & a <b>Knife</b> in inventory.<br> " +
                "Start the scrip near fishing spots at <b>Zul-Andra</b><br> " +
                "Bot will equip Angler equipment if acquired.<br><br> " +
                "For more information check out Esmaabi on SimpleBot!</html>");
        topPanel.add(descriptionText);
        add(topPanel, BorderLayout.NORTH);

        JPanel bottomPanel = new JPanel();
        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.X_AXIS));

        startButton = new JButton("Start");
        startButton.addActionListener(this);
        bottomPanel.add(startButton);

        pauseButton = new JButton("Pause");
        pauseButton.setVisible(false);
        pauseButton.addActionListener(this);
        bottomPanel.add(pauseButton);

        closeButton = new JButton("Close Gui");
        closeButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                dispose();
            }
        });
        bottomPanel.add(closeButton);

        add(bottomPanel, BorderLayout.SOUTH);

        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (e.getSource() == startButton) {
            eMain.started = true;
            eMain.playerState = eMain.State.FISHING;
            eMain.status = "Script is started";
            startButton.setVisible(false);
            pauseButton.setVisible(true);
        } else if (e.getSource() == pauseButton) {
            eMain.playerState = eMain.State.WAITING;
            eMain.status = "Script is paused";
            pauseButton.setVisible(false);
            startButton.setVisible(true);
        }

        if (eMain.botTerminated) {
            dispose();
        }
    }

}

'''
'''--- src/eSacredEelBotZenyte/eMain.java ---
package eSacredEelBotZenyte;

import eRandomEventSolver.eRandomEventForester;
import eRunecraftingBotZenyte.listeners.SkillListener;
import eSacredEelBotZenyte.listeners.SkillObserver;
import net.runelite.api.ChatMessageType;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.BooleanSupplier;

@ScriptManifest(author = "Esmaabi", category = Category.FISHING, description = " "
        + "Please read <b>eSacredEelBotZenyte</b> description first!</b><br>"
        + "<br><b>Description</b>:<br>"
        + "It is required to have <b>Fishing rod</b>, <b>Fishing bait</b> & a <b>Knife</b> in inventory.<br>"
        + "Start the scrip near fishing spots at <b>Zul-Andra</b><br>"
        + "Bot will equip Angler equipment if acquired.<br><br> "
        + "For more information check out Esmaabi on SimpleBot!", discord = "Esmaabi#5752",
        name = "eSacredEelBotZenyte", servers = { "Zenyte" }, version = "0.2")

public class eMain extends TaskScript implements SkillListener, LoopingScript {

    //vars
    public static boolean started;
    private long startTime = 0L;
    static String status = null;
    public static State playerState;
    private long lastAnimation = -1;
    private int levelsGained;
    private int experienceGained;
    boolean runningSkillListener = true;
    static boolean botTerminated = false;
    private static String playerGameName;

    //NPC
    private final int sacredEelSpot = 6488;

    //Inventory
    private final int sacredEel = 13339;
    private final int zulrahScales = 12934;
    private final int knife = 946;
    private final int fishingRod = 307;
    private final int fishingBait = 313;
    private final int anglerHat = 13258;
    private final int anglerTop = 13259;
    private final int anglerWaders = 13260;
    private final int anglerBoots = 13261;

    //Vars
    private int fishCount;
    private int zulrahScalesBeginnging;
    private int zulrahScalesCount;

    //Stats
    private long startingSkillLevelFishing, startingSkillLevelCooking;
    private long startingSkillExpFishing, startingSkillExpCooking;

    @Override
    public int loopDuration() {
        return 150;
    }

    enum State{
        FISHING,
        COOKING,
        WAITING,
    }

    //Tasks
    java.util.List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {
        tasks.addAll(Arrays.asList());
        System.out.println("Started eSacredEelBot Zenyte!");
        started = false;
        status = "Setting up config";
        startTime = System.currentTimeMillis(); //paint
        ctx.viewport.angle(180);
        ctx.viewport.pitch(true);
        fishCount = 0;
        zulrahScalesCount = 0;
        zulrahScalesBeginnging = getScalesCount();

        this.ctx.updateStatus("----------------------------------");
        this.ctx.updateStatus("        eSacredEelBotZenyte       ");
        this.ctx.updateStatus("----------------------------------");

        //FISHING
        startingSkillLevelFishing = this.ctx.skills.realLevel(SimpleSkills.Skills.FISHING);
        startingSkillExpFishing = this.ctx.skills.experience(SimpleSkills.Skills.FISHING);

        //COOKING
        startingSkillLevelCooking = this.ctx.skills.realLevel(SimpleSkills.Skills.COOKING);
        startingSkillExpCooking = this.ctx.skills.experience(SimpleSkills.Skills.COOKING);

        //GUI
        eGui gui = new eGui();
        gui.setVisible(true);

        //skill listener
        runningSkillListener = true;
        SkillObserver skillObserver = new SkillObserver(ctx, new BooleanSupplier() {

            public boolean getAsBoolean() {
                return runningSkillListener;
            }
        });
        skillObserver.addListener((eSacredEelBotZenyte.listeners.SkillListener) this);
        skillObserver.start();

    }

    @Override
    public void onProcess() {
        super.onProcess();
        if (!started) {
            playerState = State.WAITING;

        } else {

            if (ctx.inventory.populate().filter(knife).isEmpty()) {
                ctx.updateStatus("Knife missing");
                status = "Knife missing";
                ctx.updateStatus("Stopping script");
                botTerminated = true;
                ctx.sleep(5000);
                ctx.stopScript();
            }

            if (ctx.dialogue.dialogueOpen()) {
                if (ctx.widgets.getWidget(229,1).getText().contains("need a fishing rod")) {
                    ctx.updateStatus("The fishing rod missing");
                    status = "The fishing rod missing";
                    ctx.updateStatus("Stopping script");
                    botTerminated = true;
                    ctx.sleep(5000);
                    ctx.stopScript();
                } else if (ctx.widgets.getWidget(229,1).getText().contains("have any bait")) {
                    ctx.updateStatus("The fish bait has run out.");
                    status = "The fish bait has run out.";
                    ctx.updateStatus("Stopping script");
                    botTerminated = true;
                    ctx.sleep(5000);
                    ctx.stopScript();
                } else {
                    ctx.dialogue.clickContinue();
                }

            }

            if (ctx.dialogue.dialogueOpen()) {
                ctx.dialogue.clickContinue();
            }

            if (!ctx.inventory.populate().filter(anglerHat, anglerTop, anglerWaders, anglerBoots).isEmpty()) {
                ctx.inventory.populate().filter(anglerHat, anglerTop, anglerWaders, anglerBoots).forEach((item) -> item.click("Wear"));
            }

            if (playerState == State.FISHING) {
                if (ctx.inventory.populate().population() < 28) {
                    if (ctx.players.getLocal().getAnimation() == -1 && (System.currentTimeMillis() > (lastAnimation + randomSleeping(3000, 4000)))) {
                        status = "Activating fishing task";
                        fishingTask();
                    } else if (ctx.players.getLocal().getAnimation() != -1) {
                        lastAnimation = System.currentTimeMillis();
                    }
                } else {
                    playerState = State.COOKING;
                }
            }

            if (playerState == State.COOKING) {
                if (ctx.inventory.populate().filter(sacredEel).population() > 0) {
                    if (ctx.players.getLocal().getAnimation() == -1 && (System.currentTimeMillis() > (lastAnimation + randomSleeping(3000, 4000)))) {
                        status = "Activating cooking task";
                        dissectTask();
                    } else if (ctx.players.getLocal().getAnimation() != -1) {
                        lastAnimation = System.currentTimeMillis();
                    }
                } else {
                    playerState = State.FISHING;
                }
            }
        }
    }

    //tasks
    private void dissectTask() {
        SimpleItem knifeInv = ctx.inventory.populate().filter(knife).next();
        SimpleItem eelInv = ctx.inventory.populate().filter(sacredEel).next();
        status = "Dissecting sacred eels";
        ctx.inventory.itemOnItem(knifeInv, eelInv);
        ctx.sleepCondition(() -> ctx.players.getLocal().getAnimation() != -1, 3000);
    }

    private void fishingTask() {
        SimpleNpc fishingSpot = ctx.npcs.populate().filter(sacredEelSpot).nearest().next();

        if (fishingSpot != null && fishingSpot.validateInteractable()) {
            status = "Fishing";
            fishingSpot.click("Bait");
        }
    }

    public int getScalesCount() {
        return ctx.inventory.populate().filter(zulrahScales).population(true);
    }

    public static String currentTime() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    public static int randomSleeping(int minimum, int maximum) {
        return (int)(Math.random() * (maximum - minimum)) + minimum;
    }

    public String getPlayerName() {
        if (playerGameName == null) {
            playerGameName = ctx.players.getLocal().getName();
        }
        return playerGameName;
    }

    @Override
    public void onTerminate() {
        this.ctx.updateStatus("Sacred eel caught: " + fishCount);
        this.ctx.updateStatus("Zulrah scales dissected: " + zulrahScalesCount);

        //listener
        runningSkillListener = false;
        started = false;
        botTerminated = true;

        ///vars
        fishCount = 0;
        zulrahScalesCount = 0;

        this.ctx.updateStatus("----------------------");
        this.ctx.updateStatus("Thank You & Good Luck!");
        this.ctx.updateStatus("----------------------");
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        playerGameName = getPlayerName();

        if (m.getMessage() == null) {
            return;
        }

        if (getType == ChatMessageType.PUBLICCHAT) {
            String senderName = getEvent.getName();

            // Remove any text within angle brackets and trim
            senderName = senderName.replaceAll("<[^>]+>", "").trim();

            if (senderName.contains(playerGameName)) {
                ctx.updateStatus(currentTime() + " Someone asked from you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }

            if (!senderName.contains(playerGameName) && getEvent.getMessage().toLowerCase().contains(playerGameName.toLowerCase())) {
                ctx.updateStatus(currentTime() + " Someone asked for you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            }
        }
    }

    @Override
    public void paint(Graphics g) {
        Color PhilippineRed = new Color(196, 18, 48);
        Color RaisinBlack = new Color(35, 31, 32, 127);
        g.setColor(RaisinBlack);
        g.fillRect(5, 120, 250, 110);
        g.setColor(PhilippineRed);
        g.drawRect(5, 120, 250, 110);
        g.setColor(PhilippineRed);
        g.drawString("eSacredEelBot by Esmaabi", 15, 135);
        g.setColor(Color.WHITE);
        long runTime = System.currentTimeMillis() - this.startTime;
        long currentSkillLevel = this.ctx.skills.realLevel(SimpleSkills.Skills.FISHING);
        long currentSkillLevel2 = this.ctx.skills.realLevel(SimpleSkills.Skills.COOKING);
        long currentSkillExp = this.ctx.skills.experience(SimpleSkills.Skills.FISHING);
        long currentSkillExp2 = this.ctx.skills.experience(SimpleSkills.Skills.COOKING);
        long SkillLevelsGained = currentSkillLevel - this.startingSkillLevelFishing;
        long SkillLevelsGained2 = currentSkillLevel2 - this.startingSkillLevelCooking;
        long SkillExpGained = currentSkillExp - this.startingSkillExpFishing;
        long SkillExpGained2 = currentSkillExp2 - this.startingSkillExpCooking;
        long ExPGainedinSum = SkillExpGained + SkillExpGained2;
        long SkillexpPhour = (int) ((ExPGainedinSum * 3600000D) / runTime);
        long ThingsPerHour = (int) (fishCount / ((System.currentTimeMillis() - this.startTime) / 3600000.0D));
        long ThingsPerHour2 = (int) (zulrahScalesCount / ((System.currentTimeMillis() - this.startTime) / 3600000.0D));
        g.drawString("Runtime: " + formatTime(runTime), 15, 150);
        g.drawString("Starting: Fishing " + this.startingSkillLevelFishing + " (+" + SkillLevelsGained + ")," + " Cooking " + this.startingSkillLevelCooking + " (+" + SkillLevelsGained2 + ")", 15, 165);
        g.drawString("Current: Fishing " + currentSkillLevel + ", Cooking " + currentSkillLevel2, 15, 180);
        g.drawString("Exp gained: " + ExPGainedinSum + " (" + (SkillexpPhour / 1000L) + "k" + " xp/h)", 15, 195);
        g.drawString("Fish caught: " + fishCount + " (" + ThingsPerHour + " / h), Scales: " + zulrahScalesCount + " (" + ThingsPerHour2 + " / h)", 15, 210);
        g.drawString("Status: " + status, 15, 225);

    }

    @Override
    public void skillLevelAdded(SimpleSkills.Skills skill, int current, int previous, int gained) {
        //System.out.printf("We gained %d levels in %s, we went from +%d to %d", gained, skill.toString(), previous, current);
        //levelsGained += gained;

    }

    @Override
    public void skillExperienceAdded(SimpleSkills.Skills skill, int current, int previous, int gained) {
        //System.out.printf("We gained %d experience in %s, we went from +%d to %d", gained, skill.toString(), previous, current);
        //experienceGained += gained;

        zulrahScalesCount = (getScalesCount() - zulrahScalesBeginnging);

        if (playerState == State.FISHING) {
            fishCount++;
        }
    }

    private String formatTime(long ms) {
        long s = ms / 1000L;
        long m = s / 60L;
        long h = m / 60L;
        s %= 60L;
        m %= 60L;
        h %= 24L;
        return String.format("%02d:%02d:%02d", h, m, s);
    }

}

'''
'''--- src/eSacredEelBotZenyte/listeners/SkillListener.java ---
package eSacredEelBotZenyte.listeners;

import simple.hooks.filters.SimpleSkills;

public interface SkillListener {
    void skillLevelAdded(SimpleSkills.Skills skill, int current, int previous, int gained);
    void skillExperienceAdded(SimpleSkills.Skills skill, int current, int previous, int gained);
}

'''
'''--- src/eSacredEelBotZenyte/listeners/SkillObserver.java ---
package eSacredEelBotZenyte.listeners;

import net.runelite.api.GameState;
import simple.hooks.filters.SimpleSkills;
import simple.robot.api.ClientContext;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.function.BooleanSupplier;

public class SkillObserver extends Thread {

    private ArrayList<eSacredEelBotZenyte.listeners.SkillListener> listeners;
    private BooleanSupplier condition;
    private ClientContext ctx;

    public SkillObserver(ClientContext ctx, BooleanSupplier condition) {
        this.ctx = ctx;
        this.listeners = new ArrayList<>();
        this.condition = condition;
    }

    @Override
    public void run() {
        while (ctx.getClient().getGameState() != GameState.LOGGED_IN) {
            ctx.sleep(500);
        }

        HashMap<SimpleSkills.Skills, Integer> experienceMap = skillExperienceHashMap();
        HashMap<SimpleSkills.Skills, Integer> levelMap = skillLevelHashMap();
        while (true) {
            ctx.sleep(100);
            if (ctx.getClient().getGameState() != GameState.LOGGED_IN) continue;
            if (!condition.getAsBoolean()) {
                experienceMap = skillExperienceHashMap();
                levelMap = skillLevelHashMap();
                continue;
            }

            HashMap<SimpleSkills.Skills, Integer> updatedExperienceMap = skillExperienceHashMap();
            HashMap<SimpleSkills.Skills, Integer> updatedLevelMap = skillLevelHashMap();

            for (Map.Entry<SimpleSkills.Skills, Integer> entry : updatedExperienceMap.entrySet()) {
                if (experienceMap.containsKey(entry.getKey())) {
                    int cached = experienceMap.get(entry.getKey());
                    if (entry.getValue() != cached) {
                        experienceTrigger(entry.getKey(), entry.getValue(), cached, (entry.getValue() - cached));
                    }
                }
            }

            for (Map.Entry<SimpleSkills.Skills, Integer> entry : updatedLevelMap.entrySet()) {
                if (levelMap.containsKey(entry.getKey())) {
                    int cached = levelMap.get(entry.getKey());
                    if (entry.getValue() != cached) {
                        levelTrigger(entry.getKey(), entry.getValue(), cached, (entry.getValue() - cached));
                    }
                }
            }

            experienceMap = skillExperienceHashMap();
            levelMap = skillLevelHashMap();
        }
    }

    private HashMap<SimpleSkills.Skills, Integer> skillExperienceHashMap() {
        HashMap<SimpleSkills.Skills, Integer> map = new HashMap<>();
        for (SimpleSkills.Skills skill : SimpleSkills.Skills.values()) {
            map.put(skill, ctx.skills.experience(skill));
        }
        return map;
    }

    private HashMap<SimpleSkills.Skills, Integer> skillLevelHashMap() {
        HashMap<SimpleSkills.Skills, Integer> map = new HashMap<>();
        for (SimpleSkills.Skills skill : SimpleSkills.Skills.values()) {
            map.put(skill, ctx.skills.level(skill));
        }
        return map;
    }

    public void addListener(eSacredEelBotZenyte.listeners.SkillListener skillListener) {
        listeners.add(skillListener);
    }

    public void experienceTrigger(SimpleSkills.Skills skill, int current, int previous, int gained) {
        for (eSacredEelBotZenyte.listeners.SkillListener l : listeners) l.skillExperienceAdded(skill, current, previous, gained);
    }

    public void levelTrigger(SimpleSkills.Skills skill, int current, int previous, int gained) {
        for (SkillListener l : listeners) l.skillLevelAdded(skill, current, previous, gained);
    }
}

'''
'''--- src/eTeleporterBot/eMain.java ---
package eTeleporterBot;

import BotUtils.eActions;
import BotUtils.eBanking;
import BotUtils.eData;
import BotUtils.eLogGenius;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimplePlayer;

import java.awt.*;
import java.util.*;
import java.util.List;

import static eApiAccess.eAutoResponser.botStarted;
import static eApiAccess.eAutoResponser.gptDeactivation;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.MAGIC,
        description = "<html>"
                + "<p>The most effective Teleport based Magic training bot on Zenyte!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>---</li>"
                + "<li>---</li>"
                + "<li>Chat GPT answering is integrated.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eTeleporterBot",
        servers = {"Zenyte"},
        version = "0.1"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final String eBotName = "eTeleporterBot";
    private static final String ePaintText = "Teleported";
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.MAGIC;

    // Variables
    private int count;
    private static eAutoResponderGui guiGpt;
    public static boolean hidePaint = false;
    private long startTime = 0L;
    private long startingSkillExp;
    private long startingSkillLevel;

    private final Map<Integer, String> regionTeleportMap;
    eLogGenius elog = new eLogGenius(ctx);

    public eMain() {
        regionTeleportMap = new HashMap<>();
        regionTeleportMap.put(11062, "Camelot Teleport");
        regionTeleportMap.put(12853, "Varrock Teleport");
        regionTeleportMap.put(11577, "Trollheim Teleport");
        regionTeleportMap.put(11828, "Falador Teleport");
        regionTeleportMap.put(10547, "Ardougne Teleport");
        regionTeleportMap.put(12850, "Lumbridge Teleport");
        regionTeleportMap.put(10032, "Watchtower Teleport");
        regionTeleportMap.put(10288, "Watchtower Teleport");
    }

    // Gui GPT
    private void initializeGptGui() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        eBanking bankingUtils = new eBanking(ctx);
        eActions actionUtils = new eActions(ctx);
        eData dataUtils = new eData(ctx);
        eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx)));
        initializeMethods(); // BotUtils
        initializeGptGui(); // GPT
        eAutoResponser.scriptPurpose = "you're just training magic by teleporting " + getString(ctx.players.getLocal().getLocation().getRegionID()).split(" ")[0];
        gptDeactivation();

        // Other vars
        ctx.log("--------------- " + eActions.getCurrentTimeFormatted() + " ---------------");
        ctx.log("-------------------------------------");
        ctx.log("            " + eBotName + "         ");
        ctx.log("-------------------------------------");

        // Vars
        eActions.updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        count = 0;
        ctx.viewport.angle(180);
        ctx.viewport.pitch(true);
        eActions.zoomOutViewport();
    }

    @Override
    public void onProcess() {
        super.onProcess();

        final SimplePlayer localPlayer = ctx.players.getLocal();
        final int getRegion = localPlayer.getLocation().getRegionID();

        if (!botStarted) {
            eActions.status = "Please start the bot!";
            return;
        }

        if (!localPlayer.isAnimating()) {
            final String teleportAction = getString(getRegion);
            if (teleportAction != null) {
                eActions.status = "Teleporting to " + teleportAction.split(" ")[0];
                ctx.magic.castSpellOnce(teleportAction);
            } else {
                eActions.status = "Unknown location";
                elog.print("Unknown location");
                ctx.stopScript();
                ctx.sendLogout();
            }
            count++;
        }

        eActions.handleRunning();
    }

    private String getString(int getRegion) {
        return regionTeleportMap.get(getRegion);
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log(ePaintText + ": " + count);
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        String senderName = m.getChatEvent().getName();
        String gameMessage = m.getChatEvent().getMessage();

        if (m.getMessage() == null) {
            return;
        }

        if (elog.printChatContaining(m,"successfully pick the", false)) {
            count += 1;
        }

        eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        eTriviaInfo.handleBroadcastMessage(getType, gameMessage);
    }

    @Override
    public int loopDuration() {
        return 600;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePaintText + ": " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + eActions.status, 15, 225);

        }
    }
}

'''
'''--- src/eThieverBot/eMain.java ---
package eThieverBot;

import BotUtils.eActions;
import BotUtils.eBanking;
import BotUtils.eData;
import BotUtils.eImpCatcher;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;

import net.runelite.api.ItemID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Pathing;
import simple.hooks.wrappers.*;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;

import static eApiAccess.eAutoResponser.*;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.THIEVING,
        description = "<html>"
                + "<p>The most effective thieving bot on Zenyte!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>Supported areas: Ardougne, Lletya</li>"
                + "<li>To start & select target please <strong>Examine</strong> NPC</li>"
                + "<li>Supported targets: Guard, Warrior Woman, Knight of Ardougne, Paladin, Hero, Goreu</li>"
                + "<li>Bot will eat anything and bank everything.</li>"
                + "<li>You must start with food in inventory that you want to use!</li>"
                + "<li>Bot will <strong>withdraw only food that you started with!</strong></li>"
                + "<li>Chat GPT answering is integrated.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eThieverBot",
        servers = {"Zenyte"},
        version = "0.1"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final String eBotName = "eThieverBot";
    private static final String ePaintText = "Actions made";
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.THIEVING;
    private static final Logger logger = Logger.getLogger(eAnglerFisherBot.eMain.class.getName());
    private final WorldArea EDGE = new WorldArea(
            new WorldPoint(3110, 3474, 0),
            new WorldPoint(3074, 3516, 0)
    );
    private static final WorldArea ARDOUGNE = new WorldArea (
            new WorldPoint(2600, 3343, 0),
            new WorldPoint(2690, 3342, 0),
            new WorldPoint(2689, 3264, 0),
            new WorldPoint(2587, 3259, 0)
    );
    private static final WorldArea LLETYA = new WorldArea (
            new WorldPoint(2314, 3196, 0),
            new WorldPoint(2359, 3145, 0)
    );

    // Variables
    private int count;
    private static eAutoResponderGui guiGpt;
    public static boolean hidePaint = false;
    private long startTime = 0L;
    private long startingSkillExp;
    private long startingSkillLevel;
    private int npcToThiev = -1;
    private int foodToEat;

    // Gui GPT
    private void initializeGptGui() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        eBanking bankingUtils = new eBanking(ctx);
        eActions actionUtils = new eActions(ctx);
        eData dataUtils = new eData(ctx);
        eImpCatcher impCatcher = new eImpCatcher(ctx);
        eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx), new eImpCatcher(ctx)));
        initializeMethods(); // BotUtils
        initializeGptGui(); // GPT
        eAutoResponser.scriptPurpose = "you're thieving for fast xp. ";
        gptDeactivation();

        // Other vars
        ctx.log("--------------- " + eActions.getCurrentTimeFormatted() + " ---------------");
        ctx.log("-------------------------------------");
        ctx.log("            " + eBotName + "         ");
        ctx.log("-------------------------------------");

        // Vars
        eActions.updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        count = 0;
        getFood();
        ctx.viewport.angle(180);
        ctx.viewport.pitch(true);
        eActions.zoomOutViewport();
    }

    @Override
    public void onProcess() {
        super.onProcess();

        final Pathing pathing = ctx.pathing;
        final int playerHealth = ctx.combat.health();
        boolean inArdougne = pathing.inArea(ARDOUGNE);
        boolean inLletya = pathing.inArea(LLETYA);
        boolean inEdge = pathing.inArea(EDGE);

        if (!botStarted) {
            eActions.status = "Please start the bot!";
            return;
        }

        if (npcToThiev == -1) {
            eActions.status = "Please examine target!";
            return;
        }

        if (foodToEat == -1) {
            eActions.status = "No food found!";
            ctx.stopScript();
        }

        eActions.handleRunning();

        if (eActions.isWidgetOpen(704,1)) {
            ctx.keyboard.pressKey(KeyEvent.VK_ESCAPE);

            SimpleWidget xButton = ctx.widgets.getWidget(704, 1).getChild(13);
            if (xButton != null) {
                xButton.click(0);
                ctx.onCondition(() -> false, 200, 6);
            }
            return;
        }

        if (!inEdge && !inArdougne && !inLletya) {
            eActions.teleportHomeSpellbook();
            return;
        }

       if (inLletya) {
           if (playerHealth > 9) {
               if (ctx.players.getLocal().getGraphic() != -1) {
                   BotUtils.eActions.status = "Stunned";
                   return;
               }

               handlePouch(24);

               if (ctx.inventory.inventoryFull()) {
                   BotUtils.eActions.status = "Banking";
                   eBanking.bankTask(true, 8, -1, true, foodToEat,3, -1);
                   return;
               }

               // Handle pickpocket flow
               handlePickpocketTask(2314,3196,2359,3145);

           } else {
               if (!eatFood()) {
                   BotUtils.eActions.status = "Banking";
                   eBanking.bankTask(true, 8, -1, true, foodToEat,8, -1);
               }
           }
       }

        if (inArdougne) {
            if (playerHealth > 6) {
                if (ctx.players.getLocal().getGraphic() != -1) {
                    BotUtils.eActions.status = "Stunned";
                    return;
                }

                handlePouch(24);

                if (ctx.inventory.inventoryFull()) {
                    BotUtils.eActions.status = "Banking";
                    eBanking.bankTask(true, 8, -1, true, foodToEat,8, -1);
                    return;
                }

                // Handle pickpocket flow
                handlePickpocketTask(2587, 2690, 3259, 3343);

            } else {
                if (!eatFood()) {
                    eActions.teleportHomeSpellbook();
                }
            }
        }

        if (inEdge) {

            if (playerHealth < 10) {
                BotUtils.eActions.status = "Restoring hitpoints";
                SimpleObject healingBox = ctx.objects.populate().filter("Box of Restoration").nearest().next();
                if (healingBox != null && healingBox.validateInteractable()) {
                    BotUtils.eActions.interactWith(healingBox, "Restore");
                    ctx.onCondition(() -> false, 250, 5);
                }

            } else {
                if (!BotUtils.eActions.hasItemsInInventory(eActions.StackableType.NON_STACKABLE, foodToEat)) {
                    BotUtils.eActions.status = "Banking";
                    eBanking.bankTask(false, 8, -1, true, foodToEat,15, -1);
                    handlePouch(1);
                } else {
                    if (npcToThiev == 5297) {
                        eActions.handlePortalTeleport("Cities", "Lletya");
                    } else {
                        eActions.handlePortalTeleport("Cities", "Ardougne");
                    }
                }
            }
        }

        if (eActions.hasItemsInInventory(eActions.StackableType.NON_STACKABLE, ItemID.ROGUE_MASK, ItemID.ROGUE_TOP, ItemID.ROGUE_TROUSERS, ItemID.ROGUE_BOOTS, ItemID.ROGUE_GLOVES)) {
            BotUtils.eActions.updateStatus("Wearing Rogue piece");
            ctx.inventory.populate().filter(ItemID.ROGUE_MASK, ItemID.ROGUE_TOP, ItemID.ROGUE_TROUSERS, ItemID.ROGUE_BOOTS, ItemID.ROGUE_GLOVES).forEach((item) -> item.click("Wear"));
        }
    }

    private void handlePouch(int amount) {
        if (BotUtils.eActions.getNotedItemCount("Coin pouch") >= amount) {
            SimpleItem coinPouch = ctx.inventory.populate().filter("Coin pouch").next();
            if (coinPouch != null) {
                coinPouch.click(0);
                ctx.onCondition(() -> false, 200, 6);
            }
        }
    }

    private boolean eatFood() {
        SimpleItem eatItem = ctx.inventory.populate().filterHasAction("Eat").next();
        if (eatItem == null) return false;

        return eatItem.click("Eat");
    }

    private void openDoor(String name) {
        SimpleObject theDoor = ctx.objects.populate().filter(1535, 11720, 92).nearest().next();
        if (theDoor != null) {
            BotUtils.eActions.status = "Opening door to get to " + name;
            BotUtils.eActions.interactWith(theDoor, "Open");
            ctx.onCondition(() -> !ctx.pathing.inMotion(), 500, 10);
        } else {
            ctx.log("No doors found nearby.");
        }
    }

    private void handlePickpocketTask(int minX, int maxX, int minY, int maxY) {
        SimpleNpc nearestNpc = findNearestNpc();

        if (nearestNpc == null) {
            if (ctx.pathing.inArea(LLETYA)) {
                handleLletyaArea();
                return;
            }
            searchForNpcWithinArea(minX, maxX, minY, maxY);
        } else {
            interactWithNpc(nearestNpc);
        }
    }

    private SimpleNpc findNearestNpc() {
        return ctx.npcs.populate().filter(npcToThiev).filterHasAction("Pickpocket").nearest().next();
    }

    private void handleLletyaArea() {
        npcToThiev = (npcToThiev == 5297) ? 5300 : 5297;
        ctx.pathing.step(2337, 3160);
        ctx.onCondition(() -> false, 250, 10);
    }

    private void searchForNpcWithinArea(int minX, int maxX, int minY, int maxY) {
        WorldPoint randomLocation;
        SimpleNpc nearestNpc = null;
        eActions.status = "Searching for target";

        while (nearestNpc == null) {
            randomLocation = eActions.getRandomLocationWithinArea(minX, maxX, minY, maxY);
            ctx.pathing.step(randomLocation);
            ctx.onCondition(() -> false, 250, 15);
            nearestNpc = findNearestNpc();
        }
    }

    private void interactWithNpc(SimpleNpc nearestNpc) {
        if (ctx.players.getLocal().getLocation().distanceTo(nearestNpc.getLocation()) > 7) {
            ctx.pathing.step(nearestNpc.getLocation());
            ctx.onCondition(() -> false, 250, 10);
        }
        if (!ctx.pathing.reachable(nearestNpc.getLocation())) {
            openDoor(nearestNpc.getName());
        }
        BotUtils.eActions.status = "Thieving " + nearestNpc.getName();
        BotUtils.eActions.interactWith(nearestNpc, "Pickpocket");
    }

    private void getFood() {
        foodToEat = -1;
        SimpleItem foodInv = ctx.inventory.populate().filterHasAction("Eat").next();
        if (foodInv == null)  {
            ctx.log("No food found!");
            return;
        }
        foodToEat = foodInv.getId();
        ctx.log("Chosen food: " + foodInv.getName());
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log(ePaintText + ": " + count);
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

/*        String eventToStringTrimmed = getEvent.toString().replaceAll("<[^>]+>", "").trim();
        logger.info(eventToStringTrimmed); // to debug (returns chat type, text, sender)*/

        String gameMessageTrimmed = trimGameMessage(gameMessage).toLowerCase();
        if (getType == ChatMessageType.SPAM && gameMessageTrimmed.contains("successfully pick the")) {
            count += 1;
        }

        if (getType == ChatMessageType.NPC_EXAMINE) {

            if (gameMessageTrimmed.contains("holy warrior")) {
                npcToThiev = 3105;
                return;
            }

            if (gameMessageTrimmed.contains("keeps the peace")) {
                npcToThiev = 3245;
                return;
            }

            if (gameMessageTrimmed.contains("a member of ardougne")) {
                npcToThiev = 3108;
                return;
            }

            if (gameMessageTrimmed.contains("heroic")) {
                npcToThiev = 3106;
                return;
            }

            if (gameMessageTrimmed.contains("fashion conscious")) {
                npcToThiev = 3100;
                return;
            }

            if (gameMessageTrimmed.contains("an elf")) {
                npcToThiev = 5297;
                return;
            }

        }

        eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        eTriviaInfo.handleBroadcastMessage(getType, gameMessage);
    }

    @Override
    public int loopDuration() {
        return 600;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePaintText + ": " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + eActions.status, 15, 225);

        }
    }
}

'''
'''--- src/eVolcanicAshMinerBot/eMain.java ---
package eVolcanicAshMinerBot;

import BotUtils.eActions;
import BotUtils.eBanking;
import BotUtils.eData;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ItemID;
import net.runelite.api.ObjectID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.*;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.util.*;
import java.util.List;
import java.util.logging.Logger;

import static eApiAccess.eAutoResponser.*;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.FARMING,
        description = "<html>"
                + "<p>The most effective Volcanic Ash miner Bot!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>Start near 3 ash piles (in same area).</li>"
                + "<li><strong>Have any pickaxe equipped or in inventory.</strong>.</li>"
                + "<li>Dragon pickaxe special attack is supported.</li>"
                + "<li>Chat GPT answering is integrated.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eVolcanicAshMinerBot",
        servers = {"Zenyte"},
        version = "0.1"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final String eBotName = "eVolcanicAshMinerBot";
    private static final String ePaintText = "Ash mined";
    private static eAutoResponderGui guiGpt;
    private static final Logger logger = Logger.getLogger(eAnglerFisherBot.eMain.class.getName());
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.MINING;
    private final WorldPoint rockLocation1 = new WorldPoint(3800, 3767, 0);
    private final WorldPoint rockLocation2 = new WorldPoint(3794, 3773, 0);
    private final WorldPoint rockLocation3 = new WorldPoint(3789, 3769, 0);

    private static final WorldArea MINING_AREA = new WorldArea(3779, 3754, 40, 26, 0);

    // Variables
    private long startTime = 0L;
    private long startingSkillLevel;
    private long startingSkillExp;
    private int count;
    public static boolean hidePaint = false;
    private long lastAnimation = -1;
    private boolean countActive = false;
    private int cachedCount;

    // Gui GPT
    private void initializeGptGui() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        BotUtils.eBanking bankingUtils = new eBanking(ctx);
        BotUtils.eActions actionUtils = new eActions(ctx);
        BotUtils.eData dataUtils = new eData(ctx);
        Utility.Trivia.eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx)));
        initializeMethods(); // BotUtils
        initializeGptGui(); // GPT
        eAutoResponser.scriptPurpose = "you're collecting volcanic ash for farming. ";
        gptDeactivation();

        // Other vars
        ctx.log("--------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " ---------------");
        ctx.log("-------------------------------------");
        ctx.log("            " + eBotName + "         ");
        ctx.log("-------------------------------------");

        // Vars
        BotUtils.eActions.updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        count = 0;
        ctx.viewport.angle(0);
        ctx.viewport.pitch(true);
        lastAnimation = System.currentTimeMillis();
        BotUtils.eActions.specialAttackTool = true;
    }

    @Override
    public void onProcess() {
        super.onProcess();

        final SimplePlayer localPlayer = ctx.players.getLocal();

        if (!botStarted) {
            BotUtils.eActions.status = "Please start the bot!";
            return;
        }

        BotUtils.eActions.handleRunning();

        int currentCount = BotUtils.eActions.getNotedItemCount(ItemID.VOLCANIC_ASH);
        handleCount(currentCount);

        if (!BotUtils.eActions.inArea(MINING_AREA)) {
            BotUtils.eActions.status = "Searching for mining area...";
            ctx.pathing.step(new WorldPoint(3794, 3769, 0));
            return;
        }

        if (!localPlayer.isAnimating() && (System.currentTimeMillis() > (lastAnimation + BotUtils.eActions.getRandomInt(1000, 5000)))) {
            miningTask();
        } else if (localPlayer.isAnimating()) {
            lastAnimation = System.currentTimeMillis();
        }

        if (localPlayer.isAnimating()) {
            if (BotUtils.eActions.specialAttackTool) {
                BotUtils.eActions.specialAttack(ItemID.DRAGON_PICKAXE);
            }
        }
    }

    private void miningTask() {
        final SimplePlayer localPlayer = ctx.players.getLocal();
        SimpleObject volcanicAshMine = ctx.objects.populate()
                .omit(o -> !o.getLocation().equals(rockLocation1) &&
                        !o.getLocation().equals(rockLocation2) &&
                        !o.getLocation().equals(rockLocation3))
                .filter(ObjectID.ASH_PILE)
                .filterHasAction("Mine")
                .nearest()
                .next();

        if (volcanicAshMine == null) {
            BotUtils.eActions.status = "Waiting...";
            return;
        }
        BotUtils.eActions.status = "Mining...";
        BotUtils.eActions.interactWith(volcanicAshMine, "Mine");
        ctx.onCondition(localPlayer::isAnimating, 250, 10);
    }

    private boolean ashMineObjectAppeared(WorldPoint location) {
        return !ctx.objects.populate()
                .filter(o -> o.getLocation().equals(location))
                .filter(ObjectID.ASH_PILE)
                .filterHasAction("Mine").isEmpty();
    }

    private void handleCount(int currentCount) {
        if (!countActive) {
            if (count == 0) {
                cachedCount = currentCount;
                countActive = true;
            }
        } else {
            count += (currentCount - cachedCount);
            cachedCount = currentCount;
        }
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log(ePaintText + ": " + count);
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();
        BotUtils.eActions.specialAttackTool = false;
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        if (gptStarted && botStarted) eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        Utility.Trivia.eTriviaInfo.handleBroadcastMessage(getType, gameMessage);

        if (getType == ChatMessageType.SPAM) {
            String spamMessage = getEvent.getMessage().toLowerCase();

            if (spamMessage.contains("manage to mine some")) {
                count++;
            }
        }
    }

    @Override
    public int loopDuration() {
        return 150;
    }

    @Override
    public void paint(Graphics g) {

        // Check if ash pile is ready to be mined
        if (gptStarted) {
            if (BotUtils.eActions.inArea(MINING_AREA)) {
                WorldPoint[] ashLocations = new WorldPoint[]{rockLocation1, rockLocation2, rockLocation3};
                for (WorldPoint ashTile : ashLocations) {
                    if (ashTile != null) {
                        if (ashMineObjectAppeared(ashTile)) {
                            BotUtils.eActions.drawTileMatrix(ctx, (Graphics2D) g, ashTile, Color.GREEN);
                        } else {
                            BotUtils.eActions.drawTileMatrix(ctx, (Graphics2D) g, ashTile, Color.YELLOW);
                        }
                    }
                }
            }
        }

        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePaintText + ": " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + BotUtils.eActions.status, 15, 225);
        }
    }
}

'''
'''--- src/eWintertodtBot/eMain.java ---
package eWintertodtBot;

import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Game;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Stream;

@ScriptManifest(author = "Esmaabi", category = Category.FIREMAKING,
        description = "<br>Most effective Wintertodt Firemaking traing bot on Zenyte! <br><br><b>Features & recommendations:</b><br><br>" +
                "<ul>" +
                "<li>You must start with woodcutting axe </b>equipped</b> or in <b>inventory</b>;</li>" +
                "<li>You must start at Wintertodt bank;</li>" +
                "<li>Do not zoom out <b>to maximum</b>;</li>" +
                "<li>Dragon axe special attack supported;</li>" +
                "<li>Will eat shark, anglers or sara brew;</li>" +
                "<li>Due to limitation will only withdraw anglers;</li>" +
                "<li>Will eat and restock food if out of food!</li></ul>",
        discord = "Esmaabi#5752",
        name = "eWintertodtBotZenyte", servers = { "Zenyte" }, version = "0.1")

public class eMain extends TaskScript implements LoopingScript {

    //coordinates
    private final WorldArea bankArea = new WorldArea (new WorldPoint(1609,3965, 0), new WorldPoint(1650,3931, 0));
    private final WorldArea wintertodtArea = new WorldArea (new WorldPoint(1609,3966, 0), new WorldPoint(1652,4029, 0));
    private final WorldArea crateArea = new WorldArea (new WorldPoint(1625,3978, 0), new WorldPoint(1635,3986, 0));
    private final WorldPoint vialBoxLoc = new WorldPoint(1627, 3982, 0);
    private final WorldPoint herbRootLoc = new WorldPoint(1611, 4006, 0);
    private final WorldPoint brumaRootLoc = new WorldPoint(1622, 3988, 0);
    private final WorldPoint doorsLocation = new WorldPoint(1630, 3968, 0);

    //vars
    private long startTime = 0L;
    private long startingSkillLevel;
    private long startingSkillExp;
    private int count;
    static String status = null;
    private int currentExp;
    private long lastAnimation = -1;

    boolean specialDone = false;
    private final String[] foodItems = {"Shark", "Anglerfish", "Saradomin"};
    private final int[] inventoryItems = {6739, 2347, 590};
    private State playerState;

    public static int randomSleeping(int minimum, int maximum) {
        return (int)(Math.random() * (maximum - minimum)) + minimum;
    }

    public static String currentTime() {
        return LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    //Tasks
    List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    enum State {
        RUNNING,
        WAITING,
    }

    @Override
    public void onExecute() {

        tasks.addAll(Collections.emptyList());

        System.out.println("Started eWintertodtBot!");

        this.ctx.updateStatus("--------------- " + currentTime() + " ---------------");
        this.ctx.updateStatus("-------------------------------");
        this.ctx.updateStatus("       eWintertodtBot      ");
        this.ctx.updateStatus("-------------------------------");

        status = "Setting up bot";
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(SimpleSkills.Skills.FIREMAKING);
        this.startingSkillExp = this.ctx.skills.experience(SimpleSkills.Skills.FIREMAKING);
        currentExp = this.ctx.skills.experience(SimpleSkills.Skills.FIREMAKING);// for actions counter by xp drop
        count = 0;
        ctx.viewport.angle(270);
        ctx.viewport.pitch(true);
        specialDone = false;
        playerState = State.RUNNING;

    }

    @Override
    public void onProcess() {
        super.onProcess();

        if (ctx.pathing.energyLevel() > 30 && !ctx.pathing.running()) {
            ctx.pathing.running(true);
        }

        if (currentExp != this.ctx.skills.experience(SimpleSkills.Skills.FIREMAKING)) { //action counter
            count++;
            currentExp = this.ctx.skills.experience(SimpleSkills.Skills.FIREMAKING);
        }

        if (ctx.players.getLocal().getHealth() < 55) { // eating
            status = "Restoring health";
            eatFood();
            ctx.onCondition(() -> ctx.players.getLocal().getHealth() > 55, 250, 10);
        }

        if (ctx.combat.getSpecialAttackPercentage() == 100
                && ctx.equipment.populate().filter("Dragon axe").population() == 1
                && ctx.players.getLocal().getAnimation() == 2846) { // special attack for dragon axe
            int sleep = randomSleeping(2000, 6000);
            status = "Using special attack in " + sleep + "ms";
            ctx.sleep(sleep);
            ctx.combat.toggleSpecialAttack(true);
            ctx.game.tab(Game.Tab.INVENTORY);
        }

        if (ctx.pathing.inArea(wintertodtArea)) {

            if (getFoodPopulation() == 0) {
                restockTask();

            } else {

                if (rejuvPotionAmount() == 0) {
                    System.out.println("Making rejuv potion");
                    getRejuvPotion();
                }

                if (rejuvPotionAmount() != 0) {

                    if (ctx.players.getLocal().isAnimating()) {
                        return;
                    }

                    checkingForSprite(); //checking for spritesId

                    if (!logsInInventory()) { // Cutting logs
                        if (!ctx.players.getLocal().isAnimating() && (System.currentTimeMillis() > (lastAnimation + randomSleeping(2500, 3500)))) {
                            cuttingTask();
                        } else if (ctx.players.getLocal().isAnimating()) {
                            lastAnimation = System.currentTimeMillis();
                        }
                    }

                    if (pyroIsAlive() && logsInInventory() && !ctx.players.getLocal().isAnimating()) { // Burning logs
                        burningTask();
                    }

                } //rejuv potion check
            } // food check in inventory
        } //winterdoth area

        if (ctx.pathing.inArea(bankArea)) {

            if (ctx.players.getLocal().getHealth() < 90 && !ctx.bank.bankOpen() && getFoodPopulation() != 0) {
                status = "Restoring health at bank";
                eatFood();
                ctx.onCondition(() -> ctx.players.getLocal().getHealth() > 90, 250, 10);
            }

            if (getFoodPopulation() < 15) {
                openingBank();
            } else {
                runningToDoors();
            }

        } // bank area

    }

    public static SimpleItem getItem(String... itemName) {
        return ClientContext.instance().inventory.populate()
                .filter(p -> Stream.of(itemName).anyMatch(arr -> p.getName().toLowerCase().contains(arr.toLowerCase())))
                .next();
    }

    public void openingBank() {
        SimpleObject bankChest = ctx.objects.populate().filter("Bank chest").filterHasAction("Bank").nearest().next();
        if (bankChest == null && !ctx.bank.bankOpen()) {
            status = "Running to bank";
            ctx.pathing.step(1631, 3951);
            ctx.sleepCondition(() -> ctx.pathing.inMotion());
        }

        if (bankChest != null && !ctx.bank.bankOpen()) {
            if (bankChest.validateInteractable()) {
                status = "Opening bank";
                bankChest.click("Bank", "Bank chest");
                ctx.onCondition(() -> ctx.bank.bankOpen(), randomSleeping(2000, 5000));
            }
        }

        if (ctx.bank.bankOpen() && ctx.inventory.populate().filter(13441).population() < 15) {
            status = "Banking";
            ctx.bank.depositAllExcept(inventoryItems);
            ctx.sleep(300);
            ctx.bank.withdraw(13441, 18); //food Anglers
            ctx.sleep(300);
        }

        if (ctx.bank.bankOpen() && ctx.inventory.populate().filter(13441).population() > 15) {
            status = "Closing bank";
            ctx.bank.closeBank();
            ctx.onCondition(() -> !ctx.bank.bankOpen(), 5000);
        }
    }

    private void runningToDoors() {
        SimpleObject minigameDoors = ctx.objects.populate().filter("Doors of Dinh").nearest().next();
        if (minigameDoors == null) {
            status = "Running to doors";
            ctx.pathing.step(1631, 3951);
        }

        if (minigameDoors != null && minigameDoors.validateInteractable()) {
            status = "Enterning doors";
            minigameDoors.click("Enter");
            ctx.sleepCondition(() -> ctx.pathing.inArea(wintertodtArea), 5000);
        }
    }

    public void restockTask() {
        status = "Running to doors";
        if (ctx.players.getLocal().getLocation().distanceTo(doorsLocation) > 5) {
            ctx.pathing.step(doorsLocation);
            ctx.sleepCondition(() -> ctx.players.getLocal().getLocation().distanceTo(doorsLocation) < 5);
        }

        if (ctx.players.getLocal().getLocation().distanceTo(doorsLocation) <= 5) {
            SimpleObject minigameDoors = ctx.objects.populate().filter("Doors of Dinh").nearest().next();
            status = "Leaving";

            if (minigameDoors != null && minigameDoors.validateInteractable()) {
                minigameDoors.click("Enter");
                ctx.onCondition(() -> ctx.dialogue.dialogueOpen(), 250, 10);
            }

            if (!ctx.dialogue.dialogueOpen()) {
                return;
            }
            ctx.dialogue.clickDialogueOption(1);
            ctx.sleepCondition(() -> ctx.pathing.inArea(bankArea), 5000);
        }
    }

    private int rejuvPotionAmount() {
        String[] potionName = {"rejuvenation potion (4)", "rejuvenation potion (3)", "rejuvenation potion (2)", "rejuvenation potion (1)"};
        SimpleItem rejuvPotion = getItem(potionName);
        if (rejuvPotion != null) {
            return rejuvPotion.getQuantity();
        }
        return 0;
    }

    private void eatFood() {
        SimpleItem foodInInv = getItem(foodItems);
        if (foodInInv == null) {
            return;
        }
        foodInInv.click(0);
    }

    private void getRejuvPotion() {
        int unfPotion = 20697;
        int brumaHerb = 20698;
        if (ctx.inventory.populate().filter(unfPotion).isEmpty()) {
            status = "Running to crates";
            if (!ctx.pathing.inArea(crateArea)) {
                ctx.pathing.step(vialBoxLoc);
                ctx.sleepCondition(() -> ctx.players.getLocal().getLocation().distanceTo(vialBoxLoc) < 5);
            }

            if (ctx.pathing.inArea(crateArea)) {
                SimpleObject vialBoxObject = ctx.objects.populate().filter(29320).nearest().next();
                status = "Getting unfinished rejuv";
                if (vialBoxObject != null && vialBoxObject.validateInteractable()) {
                    vialBoxObject.click(0);
                    int cached = ctx.inventory.populate().filter(unfPotion).population();
                    ctx.onCondition(() -> ctx.inventory.populate().filter(unfPotion).population() > cached, 250, 10);
                }
            }
        }

        if (ctx.inventory.populate().filter(brumaHerb).isEmpty() && !ctx.inventory.populate().filter(unfPotion).isEmpty()) {
            if (ctx.players.getLocal().getLocation().distanceTo(herbRootLoc) > 5) {
                status = "Running to herb root";
                ctx.pathing.step(herbRootLoc);
                ctx.onCondition(() -> ctx.players.getLocal().getLocation().distanceTo(herbRootLoc) < 5);
            }

            if (ctx.players.getLocal().getLocation().distanceTo(herbRootLoc) <= 5) {
                SimpleObject herbRoot = ctx.objects.populate().filter(29315).nearest().next();
                status = "Getting herb";
                if (herbRoot != null &&herbRoot.validateInteractable()) {
                    herbRoot.click(0);
                    int cached = ctx.inventory.populate().filter(brumaHerb).population();
                    ctx.onCondition(() -> ctx.inventory.populate().filter(brumaHerb).population() > cached);
                }
            }
        }

        if (!ctx.inventory.populate().filter(unfPotion).isEmpty() && !ctx.inventory.populate().filter(brumaHerb).isEmpty()) {
            status = "Making rejuv potion";
            SimpleItem unfPotionInv = ctx.inventory.populate().filter(unfPotion).next();
            SimpleItem brumaHerbInv = ctx.inventory.populate().filter(brumaHerb).next();
            unfPotionInv.click("Use");
            ctx.sleep(200);
            brumaHerbInv.click(0);
            ctx.sleep(200);
            ctx.pathing.step(1620, 3993);
            ctx.sleep(1000);
        }

    }

    public void burningTask() {
        status = "Burning roots";
        SimpleObject burningBrazier = ctx.objects.populate().filter(29314).filterWithin(10).next();
        if (burningBrazier == null) {
            return;
        }
        burningBrazier.click("Feed");
        int cached = ctx.players.getLocal().getHealth();
        ctx.sleepCondition(() -> ctx.players.getLocal().getHealth() < cached || !logsInInventory(), 10000);
    }

    public void cuttingTask() {
        if (ctx.players.getLocal().getLocation().distanceTo(brumaRootLoc) > 5) {
            status = "Running to bruma root";
            ctx.pathing.step(brumaRootLoc);
            ctx.sleepCondition(() -> ctx.players.getLocal().getLocation().distanceTo(brumaRootLoc) < 5);
        }

        if (ctx.players.getLocal().getLocation().distanceTo(brumaRootLoc) <= 5) {
            SimpleObject brumaRoots = ctx.objects.populate().filter("Bruma roots").nearest().next();
            status = "Cutting bruma root";
            if (brumaRoots != null && brumaRoots.validateInteractable()) {
                brumaRoots.click("Chop");
                ctx.onCondition(() -> ctx.players.getLocal().isAnimating(), 250, 10);
            }
        }
    }

    private boolean logsInInventory() {
        if (ctx.inventory.populate().filter(20695).isEmpty()) {
            return false;
        }
        return true;
    }

    private void healingPyromancerTask() {
        status = "Helping Pyromancer";
        SimpleNpc dyingPyromancer = ctx.npcs.populate().filter(7372).filterWithin(10).filterHasAction("Help").nearest().next(); // "Incapacited pyromancer"
        if (dyingPyromancer != null) {
            status = "Helping Pyromancer";
            dyingPyromancer.click("Help");
            ctx.sleepCondition(() -> ctx.widgets.getWidget(396, 8).getSpriteId() == -1, 3000);
        } //for some reason sometimes it has null point exception with this...
    }

    private void fixingBrazier() {
        status = "Repairing brazier";
        SimpleObject brazierBroken = ctx.objects.populate().filter("Brazier").filterWithin(10).filterHasAction("Fix").nearest().next(); // Repair brazier
        if (brazierBroken != null) {
            status = "Repairing brazier";
            brazierBroken.click("Fix");
            ctx.sleepCondition(() -> ctx.widgets.getWidget(396, 12).getSpriteId() == 1398, 3000);
        } //for some reason sometimes it has null point exception with this...
    }

    private void lightingBrazier() {
        SimpleObject brazierNeedsLight = ctx.objects.populate().filter("Brazier").filterWithin(10).filterHasAction("Light").nearest().next(); // Light brazier
        if (brazierNeedsLight != null) {
            status = "Lighting brazier";
            brazierNeedsLight.click("Light");
            ctx.sleepCondition(() -> ctx.widgets.getWidget(396, 12).getSpriteId() == 1399, 3000);
        }
    }

    private void checkingForSprite() {
        if (ctx.widgets.getWidget(396, 8).getSpriteId() == 1400) {
            System.out.println("Status: Pyro is dead");
            healingPyromancerTask();
            return;
        }

        if (ctx.widgets.getWidget(396, 12).getSpriteId() == 1397) {
            System.out.println("Status: Brazier needs fixing");
            fixingBrazier();
            return;
        }

        if (ctx.widgets.getWidget(396, 12).getSpriteId() == 1398) {
            System.out.println("Status: Brazier not burning");
            lightingBrazier();
            return;
        }

        return;
    }

    private boolean brazierFireIsBurning() {
        if (ctx.widgets.getWidget(396, 12).getSpriteId() == 1399) {
            System.out.println("Status: Fire is burning");
            return true;
        }
        return false;
    }

    private boolean pyroIsAlive() {
        if (ctx.widgets.getWidget(396, 8).getSpriteId() == -1) {
            System.out.println("Status: Pyro is alive");
            return true;
        }
        return false;
    }

    private int getFoodPopulation() {
        return ctx.inventory.populate().filter(foodItems).population();
    }

    @Override
    public void onTerminate() {
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        count = 0;
        playerState = State.WAITING;

        this.ctx.updateStatus("-------------- " + currentTime() + " --------------");
        this.ctx.updateStatus("----------------------");
        this.ctx.updateStatus("Thank You & Good Luck!");
        this.ctx.updateStatus("----------------------");
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        if (m.getMessage() != null) {
            String message = m.getMessage().toLowerCase();
            if (message.contains(ctx.players.getLocal().getName().toLowerCase())) {
                ctx.updateStatus(currentTime() + " Someone asked for you");
                ctx.updateStatus(currentTime() + " Stopping script");
                ctx.stopScript();
            } else if (message.contains("get some amethyst")) {
                count++;
            }
        }
    }

    @Override
    public int loopDuration() {
        return 200;
    }

    @Override
    public void paint(Graphics g) {
        Color PhilippineRed = new Color(196, 18, 48);
        Color RaisinBlack = new Color(35, 31, 32, 127);
        g.setColor(RaisinBlack);
        g.fillRect(5, 120, 200, 110);
        g.setColor(PhilippineRed);
        g.drawRect(5, 120, 200, 110);
        g.setColor(PhilippineRed);
        g.drawString("eWintertodtBot by Esmaabi", 15, 135);
        g.setColor(Color.WHITE);
        long runTime = System.currentTimeMillis() - this.startTime;
        long currentSkillLevel = this.ctx.skills.realLevel(SimpleSkills.Skills.FIREMAKING);
        long currentSkillExp = this.ctx.skills.experience(SimpleSkills.Skills.FIREMAKING);
        long SkillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long SkillExpGained = currentSkillExp - this.startingSkillExp;
        long SkillExpPerHour = (int)((SkillExpGained * 3600000D) / runTime);
        long ActionsPerHour = (int) (count / ((System.currentTimeMillis() - this.startTime) / 3600000.0D));
        g.drawString("Runtime: " + formatTime(runTime), 15, 150);
        g.drawString("Starting Level: " + this.startingSkillLevel + " (+" + SkillLevelsGained + ")", 15, 165);
        g.drawString("Current Level: " + currentSkillLevel, 15, 180);
        g.drawString("Exp gained: " + SkillExpGained + " (" + (SkillExpPerHour / 1000L) + "k" + " xp/h)", 15, 195);
        g.drawString("Logs used: " + count + " (" + ActionsPerHour + " per/h)", 15, 210);
        g.drawString("Status: " + status, 15, 225);
    }

    private String formatTime(long ms) {
        long s = ms / 1000L;
        long m = s / 60L;
        long h = m / 60L;
        s %= 60L;
        m %= 60L;
        h %= 24L;
        return String.format("%02d:%02d:%02d", h, m, s);
    }

}
'''
'''--- src/eWoodcuttingBotZenyte/eDataTrees.java ---
package eWoodcuttingBotZenyte;

import java.util.Arrays;
import java.util.List;

class eDataTrees {
    String examineResult;
    String objectName;
    String action;

    public eDataTrees(String examineResult, String objectName, String action) {
        this.examineResult = examineResult;
        this.objectName = objectName;
        this.action = action;
    }

    public static List<eDataTrees> allTreesData = Arrays.asList(
            new eDataTrees("beautiful old mahogany tree", "Mahogany", "Chop down"),
            new eDataTrees("beautiful old teak tree", "Teak", "Chop down"),
            new eDataTrees("hardy evergreen tree", "Evergreen", "Chop down"),
            new eDataTrees("beautiful old oak", "Oak", "Chop down"),
            new eDataTrees("commonly found tree", "Tree", "Chop down"),
            new eDataTrees("most common trees", "Tree", "Chop down"),
            new eDataTrees("tree has long been dead", "Dead tree", "Chop down"),
            new eDataTrees("only useful for firewood now", "Dead tree", "Chop down"),
            new eDataTrees("splendid tree", "Yew", "Chop down"),
            new eDataTrees("makes good syrup", "Maple tree", "Chop down"),
            new eDataTrees("trees are found near water", "Willow", "Chop down"),
            new eDataTrees("droopy tree", "Willow", "Chop down"),
            new eDataTrees("splendid tree", "Yew", "Chop down"),
            new eDataTrees("tree shimmers with a magical force", "Magic tree", "Chop down"),
            new eDataTrees("enormous majestic tree", "Redwood", "Cut"),
            new eDataTrees("section of the tree has been carved out", "Redwood", "Cut")

    );

}

'''
'''--- src/eWoodcuttingBotZenyte/eMain.java ---
package eWoodcuttingBotZenyte;

import BotUtils.eActions;
import BotUtils.eBanking;
import BotUtils.eData;
import BotUtils.eImpCatcher;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ItemID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleInventory;
import simple.hooks.filters.SimpleObjects;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Pathing;
import simple.hooks.wrappers.*;

import java.awt.*;
import java.util.*;
import java.util.List;
import java.util.logging.Logger;

import static eApiAccess.eAutoResponser.*;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.WOODCUTTING,
        description = "<html>"
                + "<p>The most effective Woodcutting bot!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>Start anywhere near trees and bank.</li>"
                + "<li><strong>Examine the tree you want to cut to select it</strong>.</li>"
                + "<li>Bot will bank at any nearby location.</li>"
                + "<li>Bot will chop any tree <strong>you examine</strong>.</li>"
                + "<li>Axe in inventory is supported.</li>"
                + "<li>Dragon axe special attack is supported.</li>"
                + "<li>Picking up bird nests is supported.</li>"
                + "<li>Auto wearing Lumberjack outfit pieces is supported.</li>"
                + "<li>Chat GPT answering is integrated.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eWoodcuttingBot",
        servers = {"Zenyte"},
        version = "1"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final String eBotName = "eWoodcuttingBot";
    private static final String ePlainText = "Logs count: ";
    private static final String[] BIRD_NEST = {"Bird nest", "Clue nest (beginner)", "Clue nest (easy)", "Clue nest (medium)", "Clue nest (hard)", "Clue nest (elite)"};
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.WOODCUTTING;
    private static eAutoResponderGui guiGpt;
    private static final Logger logger = Logger.getLogger(eMain.class.getName());
    private static final String[] SPECIAL_ATTACK_TOOL = {
            "Dragon axe (or)",
            "Infernal axe",
            "Dragon axe"
    };

    // Variables
    private int count;
    public static boolean hidePaint = false;
    private long lastAnimation = -1;
    public static boolean redwoodMode;
    private long startTime = 0L;
    private long startingSkillExp;
    private long startingSkillLevel;
    private static String treeAction;
    private static String treeName;

    // Gui GPT
    private void initializeGptGUI() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        eBanking bankingUtils = new eBanking(ctx);
        eActions actionUtils = new eActions(ctx);
        eData dataUtils = new eData(ctx);
        eImpCatcher impCatcher = new eImpCatcher(ctx);
        eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx), new eImpCatcher(ctx)));

        initializeGptGUI();
        initializeMethods();
        eAutoResponser.scriptPurpose = "you're grinding woodcutting. ";
        gptDeactivation();

        // Other vars
        ctx.log("--------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " ---------------");
        ctx.log("-------------------------------------");
        ctx.log("            " + eBotName + "         ");
        ctx.log("-------------------------------------");

        // Vars
        BotUtils.eActions.updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        count = 0;
        ctx.viewport.angle(270);
        ctx.viewport.pitch(true);
        lastAnimation = System.currentTimeMillis();
        treeName = null;
        treeAction = null;
        redwoodMode = false;
        eActions.specialAttackTool = true;
    }

    @Override
    public void onProcess() {
        super.onProcess();

        final SimplePlayer localPlayer = ctx.players.getLocal();
        final Pathing pathing = ctx.pathing;
        final SimpleInventory myInventory = ctx.inventory;

        if (!botStarted || treeName == null) {
            BotUtils.eActions.status = "Press start & examine any tree";
            return;
        }

        if (redwoodMode) {
            if (!myInventory.inventoryFull() && !BotUtils.eBanking.bankIsOpen()) {

                if (localPlayer.getLocation().getPlane() != 1 && ctx.players.getLocal().getLocation().getRegionID() == 6198) {
                    handleRopeLadder(localPlayer, "Climb-up", 1);

                } else {

                    if (!localPlayer.isAnimating() && !pathing.inMotion() && (System.currentTimeMillis() > (lastAnimation + BotUtils.eActions.getRandomInt(1200, 3200)))) {
                        cuttingTrees(localPlayer, treeName);
                    } else if (localPlayer.isAnimating()) {
                        lastAnimation = System.currentTimeMillis();
                    }
                }

            } else {
                if (localPlayer.getLocation().getPlane() == 1 && ctx.players.getLocal().getLocation().getRegionID() == 6198) {
                    handleRopeLadder(localPlayer, "Climb-down", 0);
                } else {
                    BotUtils.eBanking.bankTask(true, 8, 1, false, (String) null, -1, eData.Woodcutting.WOODCUTTING_AXE);
                }
            }

        }

        if (!redwoodMode) {
            if (!myInventory.inventoryFull() && !BotUtils.eBanking.bankIsOpen()) {

                if (!localPlayer.isAnimating() && !pathing.inMotion() && (System.currentTimeMillis() > (lastAnimation + BotUtils.eActions.getRandomInt(1000, 5000)))) {
                    cuttingTrees(localPlayer, treeName);
                } else if (localPlayer.isAnimating()) {
                    lastAnimation = System.currentTimeMillis();
                }

            } else {
                BotUtils.eBanking.bankTask(true, 8, 1, false, (String) null, -1, eData.Woodcutting.WOODCUTTING_AXE);
            }
        }

        BotUtils.eActions.handleRunning();

        if (!myInventory.populate().filter(ItemID.LUMBERJACK_HAT, ItemID.LUMBERJACK_TOP, ItemID.LUMBERJACK_LEGS, ItemID.LUMBERJACK_BOOTS).isEmpty()) {
            BotUtils.eActions.updateStatus("Wearing Lumberjack piece");
            myInventory.populate().filter(ItemID.LUMBERJACK_HAT, ItemID.LUMBERJACK_TOP, ItemID.LUMBERJACK_LEGS, ItemID.LUMBERJACK_BOOTS).forEach((item) -> item.click("Wear"));
        }

        if (!ctx.inventory.inventoryFull()) {
            BotUtils.eActions.handleGroundItem("Take", BIRD_NEST);
        }

        if (localPlayer.isAnimating()) {
            if (BotUtils.eActions.specialAttackTool) {
                BotUtils.eActions.specialAttack(SPECIAL_ATTACK_TOOL);
            }
        }
    }

    // Woodcutting
    private void cuttingTrees(SimplePlayer localPlayer, String nameOfTree) {
        SimpleObjects treesNearby = (SimpleObjects) ctx.objects.populate().filter(nameOfTree);
        BotUtils.eActions.updateStatus("Looking for " + nameOfTree + " trees...");

        while (!treesNearby.isEmpty()) {
            SimpleObject nearestTree = treesNearby.filterHasAction(treeAction).nearest().next();
            WorldPoint theTreeLocation = nearestTree.getLocation();
            boolean isOtherPlayerChopping = !ctx.players.populate().filterWithin(theTreeLocation, 2).filter(otherPlayer -> !otherPlayer.getName().equals(ctx.players.getLocal().getName())).isEmpty();

            if (treesNearby.size() >= 2 && isOtherPlayerChopping) {
                BotUtils.eActions.updateStatus("Another player is chopping the nearest " + nameOfTree + ".");
                BotUtils.eActions.updateStatus("Looking for another tree...");
                treesNearby = (SimpleObjects) treesNearby.filter(otherTree -> !otherTree.equals(nearestTree));
                continue;
            } else {
                if (nearestTree.validateInteractable()) {
                    WorldPoint treeLocation = nearestTree.getLocation();
                    boolean reachable = isTreeReachable(treeLocation);

                    if (reachable) {
                        int distance = treeLocation.distanceTo(ctx.players.getLocal().getLocation()) - 1;
                        BotUtils.eActions.updateStatus(nameOfTree + " found " + (treeLocation.distanceTo(ctx.players.getLocal().getLocation()) - 1) + BotUtils.eActions.pluralize(distance, " tile", " tiles") + " away");
                        if (redwoodMode) {
                            ctx.viewport.pitch(true);
                        }
                        BotUtils.eActions.interactWith(nearestTree, treeAction);
                        BotUtils.eActions.status = "Chopping " + nameOfTree;
                        BotUtils.eActions.updateStatus(BotUtils.eActions.status);
                        ctx.onCondition(localPlayer::isAnimating, 250, 10);
                        return;
                    } else {
                        BotUtils.eActions.updateStatus("Next " + nameOfTree + " is not reachable.");
                        treesNearby = (SimpleObjects) treesNearby.filter(otherTree -> !otherTree.equals(nearestTree));
                    }
                } else {
                    BotUtils.eActions.updateStatus("No " + nameOfTree + " found in the vicinity.");
                    return;
                }
            }
        }
        BotUtils.eActions.updateStatus("No suitable " + nameOfTree + " trees found nearby.");
    }

    private boolean isTreeReachable(WorldPoint treeLocation) {
        int[] offsets = { 0, 1, -1, 2, -2}; // Adjust these offsets as needed
        for (int offsetX : offsets) {
            for (int offsetY : offsets) {
                WorldPoint offsetLocation = new WorldPoint(treeLocation.getX() + offsetX, treeLocation.getY() + offsetY, treeLocation.getPlane());
                if (ctx.pathing.reachable(offsetLocation)) {
                    return true;
                }
            }
        }
        return false;
    }

    private void handleGroundItem() {
        SimpleGroundItem itemToPickup = ctx.groundItems.populate().filter(eMain.BIRD_NEST).nearest().next();

        if (itemToPickup != null && itemToPickup.validateInteractable()) {
            BotUtils.eActions.updateStatus(BotUtils.eActions.getCurrentTimeFormatted() + " Found " + itemToPickup.getName());
            if (itemToPickup.click("Take")) {
                ctx.onCondition(() -> ctx.groundItems.populate().filter(eMain.BIRD_NEST).isEmpty(), 250, 12);
            }
        }
    }

    private void handleRopeLadder(SimplePlayer localPlayer, String action, int expectedPlane) {
        SimpleObject ropeLadder = ctx.objects.populate().filter("Rope ladder").filterHasAction(action).nearest().next();
        if (!ropeLadder.visibleOnScreen()) {
            ctx.viewport.turnTo(ropeLadder);
            ctx.pathing.step(ropeLadder.getLocation());
        }
        BotUtils.eActions.interactWith(ropeLadder, action);
        ctx.onCondition(() -> localPlayer.getLocation().getPlane() == expectedPlane, 250, 4);
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + BotUtils.eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log(ePlainText + count);
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();
        treeName = null;
        treeAction = null;
        redwoodMode = false;
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

        if (gptStarted && botStarted) eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        eTriviaInfo.handleBroadcastMessage(getType, gameMessage);

        if (getType == ChatMessageType.SPAM) {
            String spamMessage = trimGameMessage(gameMessage);

            if (spamMessage.contains("You get some")) {
                count++;
            }
        }

        if (getType == ChatMessageType.OBJECT_EXAMINE) {
            String examineMessage = getEvent.getMessage();
            if (examineMessage == null) {
                return;
            }

            for (eDataTrees treeData : eDataTrees.allTreesData) {
                if (examineMessage.contains(treeData.examineResult)) {
                    treeName = treeData.objectName;
                    treeAction = treeData.action;
                    redwoodMode = Objects.equals(treeName, "Redwood");
                    BotUtils.eActions.updateStatus("New tree selected: " + treeName);
                    break;
                }
            }
        }
    }

    @Override
    public int loopDuration() {
        return 600;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePlainText + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + BotUtils.eActions.status, 15, 225);

        }
    }
}

'''
'''--- src/eZMIRunecrafting/eMain.java ---
package eZMIRunecrafting;

import BotUtils.eActions;
import BotUtils.eBanking;
import BotUtils.eData;
import BotUtils.eLogGenius;
import Utility.Trivia.eTriviaInfo;
import eApiAccess.eAutoResponderGui;
import eApiAccess.eAutoResponser;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ItemID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimplePrayers;
import simple.hooks.filters.SimpleSkills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.task.Task;
import simple.hooks.scripts.task.TaskScript;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Game;
import simple.hooks.simplebot.Magic;
import simple.hooks.simplebot.Pathing;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.utils.WorldArea;

import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static BotUtils.eActions.random;
import static eApiAccess.eAutoResponser.*;

@ScriptManifest(
        author = "Esmaabi",
        category = Category.RUNECRAFTING,
        description = "<html>"
                + "<p>Enhance your runecrafting experience with the Ourania ZMI Bot, the most efficient runecrafting bot!</p>"
                + "<p><strong>Features & recommendations:</strong></p>"
                + "<ul>"
                + "<li>Make sure to <b>start the bot</b> while at the Ourania Cave \"bank\" or near the Chaos Altar.</li>"
                + "<li>Handles energy management by consuming stamina potions. You must include <b>stamina potion (1)</b> in your \"Last Preset\" for this feature.</li>"
                + "<li>For health management, include your choice of food in the \"Last Preset\". The bot automatically consumes food when health falls below 40%.</li>"
                + "<li>Bot will efficiently use \"Protect from Missiles\" and \"Rapid Healing\" for protection inside the cave (Prayer lvl 40 requirement).</li>"
                + "<li>Seamless banking experience with the use of \"Last Preset\". You must set up your \"Last Preset\" with a full inventory of essence and \"empty pouches\".</li>"
                + "<li>Supported to use <strong>all pouches</strong> & recommended order w/o Colossal: Giant, Small, Large, Medium. You can use only few if you want!</li>"
                + "<li>Provides real-time status updates, keeping you informed of each action and any issues encountered.</li>"
                + "<li>Automates the entire process of runecrafting, including pouch filling and emptying, rune crafting, and teleporting.</li>"
                + "<li>It is required to use \"Lunar spellbook\" to teleport to \"Ourania\", also recommended to wield any earth staff.</li>"
                + "<li>If there are not enough runes to teleport, bot will run back.</li>"
                + "<li>Integrated chat GPT answering for interactive responses.</li>"
                + "</ul>"
                + "</html>",
        discord = "Esmaabi#5752",
        name = "eEffortlessZMI",
        servers = {"Zenyte"},
        version = "0.2"
)

public class eMain extends TaskScript implements LoopingScript {

    // Constants
    private static final String eBotName = "eEffortlessZMI";
    private static final String ePaintText = "Runs made";
    private static final String eVersion = "v 0.2";
    private static final SimpleSkills.Skills CHOSEN_SKILL = SimpleSkills.Skills.RUNECRAFT;
    private static final Logger logger = Logger.getLogger(eAnglerFisherBot.eMain.class.getName());

    public static final WorldArea OURANIA_CAVE_AREA = new WorldArea(new WorldPoint(2999, 5635, 0), new WorldPoint(3074, 5565, 0));
    public static final WorldArea OURANIA_RC_ALTAR_AREA = new WorldArea(new WorldPoint(3072, 5591, 0), new WorldPoint(3051, 5571, 0));
    public static final WorldArea OURANIA_BANKING_AREA = new WorldArea(new WorldPoint(3005, 5632, 0), new WorldPoint(3028, 5620, 0));

    private final WorldPoint[] WALKING_TO_ALTAR = {
            new WorldPoint(3015, 5620, 0),
            new WorldPoint(3017, 5613, 0),
            new WorldPoint(3016, 5604, 0),
            new WorldPoint(3018, 5597, 0),
            new WorldPoint(3017, 5590, 0),
            new WorldPoint(3019, 5584, 0),
            new WorldPoint(3021, 5579, 0),
            new WorldPoint(3029, 5578, 0),
            new WorldPoint(3034, 5583, 0),
            new WorldPoint(3040, 5582, 0),
            new WorldPoint(3047, 5579, 0),
            new WorldPoint(3053, 5579, 0),
            new WorldPoint(3058, 5579, 0)
    };

    private final WorldPoint[] WALKING_TO_ALTAR2 = {
            new WorldPoint(3014, 5618, 0),
            new WorldPoint(3014, 5611, 0),
            new WorldPoint(3014, 5605, 0),
            new WorldPoint(3014, 5599, 0),
            new WorldPoint(3014, 5591, 0),
            new WorldPoint(3015, 5583, 0),
            new WorldPoint(3021, 5578, 0),
            new WorldPoint(3031, 5577, 0),
            new WorldPoint(3037, 5582, 0),
            new WorldPoint(3043, 5580, 0),
            new WorldPoint(3051, 5578, 0),
            new WorldPoint(3057, 5578, 0)
    };

    // Variables
    private int count;
    private static eAutoResponderGui guiGpt;
    public static boolean hidePaint = false;
    private long startTime = 0L;
    private long startingSkillExp;
    private long startingSkillLevel;
    private boolean bankingCompleted = false;
    private boolean runecraftingCompleted = false;
    private boolean prayingAtAltar = false;
    private boolean noRunesToTele = false;
    private boolean fillingPouches = false;
    private boolean emptyingPouches = false;
    private boolean prayerIsOn;

    eLogGenius elog = new eLogGenius(ctx);

    // Gui GPT
    private void initializeGptGui() {
        guiGpt = new eAutoResponderGui();
        guiGpt.setVisible(true);
        guiGpt.setLocale(ctx.getClient().getCanvas().getLocale());
    }

    private void initializeMethods() {
        eBanking bankingUtils = new eBanking(ctx);
        eActions actionUtils = new eActions(ctx);
        eData dataUtils = new eData(ctx);
        eTriviaInfo triviaInfo = new eTriviaInfo(ctx);
    }

    // Tasks
    private final List<Task> tasks = new ArrayList<>();

    @Override
    public boolean prioritizeTasks() {
        return true;
    }

    @Override
    public List<Task> tasks() {
        return tasks;
    }

    @Override
    public void onExecute() {

        tasks.addAll(Arrays.asList(new eAutoResponser(ctx)));
        initializeMethods(); // BotUtils
        initializeGptGui(); // GPT
        eAutoResponser.scriptPurpose = "you're just doing Runecrafting for faster xp. ";
        gptDeactivation();

        // Other vars
        ctx.log("--------------- " + eActions.getCurrentTimeFormatted() + " ---------------");
        ctx.log("-------------------------------------");
        ctx.log("            " + eBotName + "         ");
        ctx.log("-------------------------------------");

        // Vars
        eActions.updateStatus("Setting up bot");
        this.startTime = System.currentTimeMillis();
        this.startingSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        this.startingSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        count = 0;
        ctx.viewport.angle(180);
        ctx.viewport.pitch(true);
        eActions.zoomOutViewport();
        setBooleans(false);
        prayerIsOn = true;
    }

    @Override
    public void onProcess() {
        super.onProcess();

        if (!botStarted) {
            eActions.status = "Please start the bot!";
            return;
        }

        if (ctx.magic.spellBook() != Magic.SpellBook.LUNAR) {
            switchTabs(Game.Tab.MAGIC, Game.Tab.INVENTORY, 4);
            eActions.status = "Lunar spellbook required!";
            ctx.log("Stopping script");
            ctx.log("Please change spellbook to Lunar");
            ctx.sleep(5000);
            ctx.stopScript();
            return;
        }

        handleEnergy();

        if (isOutsideOuraniaCave()) {
            handleOutsideCave();
        } else {
            handleInsideCave();
        }
    }

    private boolean isOutsideOuraniaCave() {
        return !ctx.pathing.inArea(OURANIA_CAVE_AREA);
    }

    private void handleOutsideCave() {
        if (!prayingAtAltar && ctx.skills.level(SimpleSkills.Skills.PRAYER) != ctx.skills.realLevel(SimpleSkills.Skills.PRAYER)) {
            prayAtChaosAltar();
        } else {
            climbDownToCave();
        }
    }

    private void prayAtChaosAltar() {
                SimpleObject chaosAltar = ctx.objects.populate().filter(411).next();
        if (elog.isValid(chaosAltar)) {
            eActions.status = "Praying at " + chaosAltar.getName().toLowerCase();
            eActions.interactWith(chaosAltar, "Pray-at");
        } else {
            eActions.status = "Chaos Altar not found";
            teleportToOurania();
        }
    }

    private void climbDownToCave() {
        SimpleObject ladderDown = ctx.objects.populate().filter(29635).next();
        if (elog.isValid(ladderDown)) {
            eActions.status = "Climbing down the ladder";
            eActions.interactWith(ladderDown, "Climb");
            setBooleans(false);
            eActions.openTab(Game.Tab.INVENTORY);
            prayingAtAltar = true;
        } else {
            eActions.status = "Ladder not found";
        }
    }

    private void handleInsideCave() {
        if (noRunesToTele && !ctx.pathing.inArea(OURANIA_BANKING_AREA)) {
            outOfTeleportRunes();
        } else {
            if (!bankingCompleted) {
                performBankingTasks();
            } else {
                runecraftAtAltar();
            }
        }

        if (ctx.combat.healthPercent() < 40) {
            if (!eatFood()) {
                ctx.log("Out of food, teleporting home");
                teleportToHome();
                ctx.sendLogout();
                ctx.stopScript();
            }
        }
    }

    private void performBankingTasks() {
        SimpleNpc banker = ctx.npcs.populate().filter("Eniola").next();
        boolean essenceInInv = !ctx.inventory.populate().filterContains("essence").isEmpty();

        if (!elog.isValid(banker)) {
            eActions.status = "Banker not found";
            return;
        }

        if (!essenceInInv || !ctx.inventory.inventoryFull()) {
            eActions.status = "Loading preset from bank";
            BotUtils.eActions.interactWith(banker, "Last Preset");
            return;
        }

        if (!fillingPouches) {
            fillPouches(banker);
            return;
        }

/*        if (eActions.hasItemsInInventory(eActions.StackableType.NON_STACKABLE, ItemID.PURE_ESSENCE, ItemID.RUNE_ESSENCE) && fillingPouches) {
            eActions.status = "Banking completed";
            setBooleans(false);
            bankingCompleted = true;
        }*/

        eActions.status = "Banking completed";
        setBooleans(false);
        bankingCompleted = true;
    }

    private void fillPouches(SimpleNpc banker) {
        if (!eBanking.bankIsOpen()) {
            eActions.interactWith(banker, "Last Preset");

            if (eActions.hasItemsInInventory(eActions.StackableType.NON_STACKABLE, "pure essence", "rune essence")) {
                eActions.interactWith(banker, "Bank");
            }
        }

        if (eBanking.bankIsOpen()) {
            eActions.status = "Starting to fill pouches";
            List<SimpleItem> pouches = ctx.inventory.populate().filterContains("pouch").toStream()
                    .filter(elog::isValid)
                    .collect(Collectors.toList());

            for (SimpleItem pouch : pouches) {
                String pouchName = pouch.getName().toLowerCase();
                eActions.status = "Filling " + pouchName;

                if (pouchName.contains("colossal")) {
                    while (!fillingPouches) {
                        eActions.status = "Filling " + pouchName;
                        pouch.click("Fill");
                        ctx.sleep(50);
                        if (fillingPouches) {
                            ctx.bank.closeBank();
                            break;
                        }
                    }
                } else {
                    eActions.status = "Filling " + pouchName;
                    pouch.click("Fill");
                    ctx.sleep(50);
                }
            }
            ctx.bank.closeBank();
            fillingPouches = true;
        }
    }

    private void runecraftAtAltar() {
        if (!ctx.pathing.inArea(OURANIA_RC_ALTAR_AREA)) {
            setPrayers(prayerIsOn);
            eActions.status = "Walking to altar";

            // Randomly choose between the two paths for next step
            if (random.nextDouble() < 0.75) {
                BotUtils.eActions.walkPath(OURANIA_RC_ALTAR_AREA, WALKING_TO_ALTAR2, false);
            } else {
                BotUtils.eActions.walkPath(OURANIA_RC_ALTAR_AREA, WALKING_TO_ALTAR, false);
            }

            useItemOnItemFletch();

        } else {
            craftingRunes();
        }
    }

/*    private void useItemOnItemFletch() {
        SimpleItem itemInv = ctx.inventory.populate().filter(n -> n.getName().toLowerCase().contains("dart tip")).next();
        SimpleItem featherInv = ctx.inventory.populate().filter(ItemID.FEATHER).next();
        if (eBanking.bankIsOpen()) ctx.bank.closeBank();

        if (itemInv == null || featherInv == null) {
            return;
        }

        BotUtils.eActions.status = "Fletching";
        featherInv.click(0);
        itemInv.click(0);
    }*/

    private void useItemOnItemFletch() {
        Iterable<SimpleItem> inventoryItems = ctx.inventory.populate();

        SimpleItem itemInv = null;
        SimpleItem featherInv = null;

        for (SimpleItem item : inventoryItems) {
            String itemName = item.getName().toLowerCase();
            if (itemInv == null && itemName.contains("dart tip")) {
                itemInv = item;
            } else if (featherInv == null && item.getId() == ItemID.FEATHER) {
                featherInv = item;
            }

            if (itemInv != null && featherInv != null) {
                break;
            }
        }

        if (itemInv == null || featherInv == null) {
            return;
        }

        if (!eBanking.bankIsOpen()) {
            BotUtils.eActions.status = "Fletching " + itemInv.getName().toLowerCase();
            featherInv.click(0);
            itemInv.click(0);
            ctx.sleep(50);
        }
    }

    private void craftingRunes() {
        SimpleObject RC_ALTAR = ctx.objects.populate().filter(29631).next();
        boolean essenceInInv = !ctx.inventory.populate().filterContains("essence").isEmpty();

        if (!elog.isValid(RC_ALTAR)) {
            eActions.status = "Altar not found";
            return;
        }

        if (!runecraftingCompleted) {
            if (essenceInInv) {
                eActions.status = "Crafting runes";
                eActions.interactWith(RC_ALTAR, "Craft-rune");
            } else if (!emptyingPouches) {
                emptyPouches(RC_ALTAR);
                return;
            }
        }

        if (emptyingPouches && !essenceInInv && !noRunesToTele) {
            eActions.status = "Teleporting back";
            teleportToOurania();
            runecraftingCompleted = true;
        }
    }

    private void teleportToOurania() {
        if (ctx.magic.castSpellOnce("Ourania Teleport")) {
            ctx.onCondition(() -> ctx.players.getLocal().getLocation().getRegionID() == 9778, 250, 10);
        }
    }

    private void emptyPouches(SimpleObject RC_ALTAR) {
        eActions.status = "Starting to empty pouches";
        List<SimpleItem> pouches = ctx.inventory.populate().filterContains("pouch").toStream()
                .filter(elog::isValid)
                .collect(Collectors.toList());

        for (SimpleItem pouch : pouches) {
            String pouchName = pouch.getName().toLowerCase();

            if (pouchName.contains("colossal")) {
                while (!emptyingPouches) {
                    eActions.status = "Emptying " + pouchName;
                    pouch.click("Empty");
                    ctx.sleep(50);
                    eActions.status = "Clicking " + RC_ALTAR.getName().toLowerCase();
                    eActions.interactWith(RC_ALTAR, "Craft-rune");
                    ctx.sleep(50);
                    if (emptyingPouches) {
                        break;
                    }
                }
            } else {
                eActions.status = "Emptying " + pouchName;
                pouch.click("Empty");
                ctx.sleep(50);
                eActions.status = "Clicking " + RC_ALTAR.getName().toLowerCase();
                eActions.interactWith(RC_ALTAR, "Craft-rune");
                ctx.sleep(50);
            }
        }
        emptyingPouches = true;
    }

    private void outOfTeleportRunes() {
        setBooleans(false);
        noRunesToTele = true;
        if (!ctx.pathing.inArea(OURANIA_BANKING_AREA)) {
            eActions.status = "Running back to bank";
            setPrayers(prayerIsOn);
            BotUtils.eActions.walkPath(OURANIA_BANKING_AREA, WALKING_TO_ALTAR, true);
        } else {
            setBooleans(false);
        }
    }

    private void setBooleans(boolean set) {
        bankingCompleted = set;
        runecraftingCompleted = set;
        emptyingPouches = set;
        fillingPouches = set;
        prayingAtAltar = set;
        noRunesToTele = set;
    }

    private void setPrayers(boolean set) {
        if (ctx.prayers.points() > 0) {
            ctx.prayers.prayer(SimplePrayers.Prayers.PROTECT_FROM_MISSILES, set);
            ctx.prayers.prayer(SimplePrayers.Prayers.RAPID_HEAL,set);
        }
        ctx.combat.toggleAutoRetaliate(false);
    }

    public boolean eatFood() {
        SimpleItem food = ctx.inventory.populate().filterHasAction("Eat").next();

        if (food == null) return false;
        eActions.status = "Eating " + food.getName().toLowerCase();
        food.click(0);
        return true;
    }

    public void teleportToHome() {
        if (ctx.pathing.inArea(eActions.EDGE_HOME_AREA)) {
            return;
        }

        eActions.status = "Teleporting to Edgeville";
        SimpleItem tab = ctx.inventory.populate().filter("Zenyte home teleport").next();

        if (tab == null) {
            return;
        }

        tab.click(0);
        ctx.onCondition(() -> ctx.pathing.inArea(eActions.EDGE_HOME_AREA), 250, 2);
    }

    private void handleEnergy() {
        Pathing pathing = ctx.pathing;

        if (pathing.energyLevel() < 20) {
            final SimpleItem potion = ctx.inventory.populate()
                    .filter(Pattern.compile("Stamina potion\\(\\d+\\)"), Pattern.compile("Super energy potion\\(\\d+\\)"))
                    .filterHasAction("Drink").next();
            final int cached = pathing.energyLevel();
            if (potion == null) {
                return;
            }
            BotUtils.eActions.status = ("Drinking " + potion.getName().toLowerCase());
            if (potion.click("Drink")) {
                ctx.onCondition(() -> pathing.energyLevel() > cached, 50, 20);
            }
        }

        if (pathing.energyLevel() >= 30 && !pathing.running()) {
            pathing.running(true);
        }
    }

    private void switchTabs(Game.Tab tabOne, Game.Tab tabTwo, int times) {
        for (int i = 0; i < times; i++) {
            ctx.game.tab(tabOne);
            ctx.game.tab(tabTwo);
        }
    }

    @Override
    public void onTerminate() {

        // Termination message
        ctx.log("-------------- " + eActions.getCurrentTimeFormatted() + " --------------");
        ctx.log(ePaintText + ": " + count);
        ctx.log("-----------------------------------");
        ctx.log("----- Thank You & Good Luck! ------");
        ctx.log("-----------------------------------");

        // Other variables
        this.startingSkillLevel = 0L;
        this.startingSkillExp = 0L;
        this.count = 0;
        guiGpt.setVisible(false);
        gptDeactivation();
        setBooleans(false);
        emptyingPouches = true;
        fillingPouches = true;
    }

    @Override
    public void onChatMessage(ChatMessage m) {
        String formattedMessage = m.getFormattedMessage();
        ChatMessageType getType = m.getType();
        net.runelite.api.events.ChatMessage getEvent = m.getChatEvent();
        String senderName = getEvent.getName();
        String gameMessage = getEvent.getMessage();

        if (m.getMessage() == null) {
            return;
        }

/*        if (elog.printChatContaining(m, "You pray to the gods...", false)) {
            prayingAtAltar = true;
            count++;
        }*/

        if (elog.printChatContaining(m, "has been loaded", false)) {
            count++;
        }

        if (elog.printChatContaining(m, "You already have full prayer", false)) {
            prayingAtAltar = true;
        }

        if (elog.printChatContaining(m, "You do not have enough", false)) {
            noRunesToTele = true;
        }

        if (elog.printChatContaining(m, "Your pouch is empty", false)) {
            emptyingPouches = true;
        }

        if (elog.printChatContaining(m, "Your pouch is already full", false)) {
            fillingPouches = true;
        }

        if (elog.printChatType(m, ChatMessageType.GAMEMESSAGE, false) &&
                (elog.printChatContaining(m, "track unlocks", false) || elog.printChatContaining(m, "track was unlocked", false))) {
            prayerIsOn = !prayerIsOn;
            ctx.log("Prayer has been toggled: " + (prayerIsOn ? "ON" : "OFF"));
        }

        elog.printChatContaining(m, "Inventory was loaded successfully", false);

        eAutoResponser.handleGptMessages(getType, senderName, formattedMessage);
        eTriviaInfo.handleBroadcastMessage(getType, gameMessage);
    }

    @Override
    public int loopDuration() {
        return 200;
    }

    @Override
    public void paint(Graphics g) {
        // Check if mouse is hovering over the paint
        Point mousePos = ctx.mouse.getPoint();
        if (mousePos != null) {
            Rectangle paintRect = new Rectangle(5, 120, 200, 110);
            hidePaint = paintRect.contains(mousePos.getLocation());
        }

        // Get runtime and skill information
        String runTime = ctx.paint.formatTime(System.currentTimeMillis() - startTime);
        long currentSkillLevel = this.ctx.skills.realLevel(CHOSEN_SKILL);
        long currentSkillExp = this.ctx.skills.experience(CHOSEN_SKILL);
        long skillLevelsGained = currentSkillLevel - this.startingSkillLevel;
        long skillExpGained = currentSkillExp - this.startingSkillExp;

        // Calculate experience and actions per hour
        long skillExpPerHour = ctx.paint.valuePerHour((int) skillExpGained, startTime);
        long actionsPerHour = ctx.paint.valuePerHour(count, startTime);

        // Set up colors
        Color philippineRed = new Color(196, 18, 48);
        Color raisinBlack = new Color(35, 31, 32, 127);

        // Draw paint if not hidden
        if (!hidePaint) {
            g.setColor(raisinBlack);
            g.fillRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawRoundRect(5, 120, 200, 110, 20, 20);

            g.setColor(philippineRed);
            g.drawString(eBotName + " by Esmaabi", 15, 135);
            g.drawString(eVersion, 175, 135);
            g.setColor(Color.WHITE);
            g.drawString("Runtime: " + runTime, 15, 150);
            g.drawString("Skill Level: " + currentSkillLevel + " (+" + skillLevelsGained + "), started at " + this.startingSkillLevel, 15, 165);
            g.drawString("Current Exp: " + currentSkillExp, 15, 180);
            g.drawString("Exp gained: " + skillExpGained + " (" + (skillExpPerHour / 1000L) + "k xp/h)", 15, 195);
            g.drawString(ePaintText + ": " + count + " (" + actionsPerHour + " per/h)", 15, 210);
            g.drawString("Status: " + eActions.status, 15, 225);

        }
    }
}

'''