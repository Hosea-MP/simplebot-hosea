*GitHub Repository "Wowzer69/SimpleBotScripts"*

'''--- aiohunter/AIOHunter.java ---
package aiohunter;

import java.awt.Button;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.JFrame;

import aiohunter.data.Constants;
import aiohunter.data.enums.Butterfly;
import aiohunter.data.enums.Salamanders;
import aiohunter.data.enums.Trapping;
import aiohunter.methods.Methods;
import aiohunter.methods.Net;
import aiohunter.methods.Sala;
import aiohunter.methods.Traps;
import lombok.Getter;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.KeyCode;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.OverlayUtil;
import simple.api.Utils;
import simple.api.Variables;
import simple.api.listeners.ConfigChangeEvent;
import simple.api.listeners.ConfigChangeListener;
import simple.api.panel.Config;
import simple.api.panel.Panel;
import simple.api.panel.Tabs;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.robot.script.Script;

@ScriptManifest(author = "KremeSickle", category = Category.HUNTER, description = "<br>This script will train your Hunter with various of methods<br><br>Script supports Salamander, Butterflies, Bird Traps & Box Traps<br><br>Start the script in the hunting area with the required hunting items in your inventory<br><br>Choose your preferred Hunting method and then choose which type<br><br>Custom Tiles:<br> Pause the Script VIA the GUI, enable Show Tiles and then hold SHIFT + Left click custom tiles<br><br>Script is currently in beta-testing phase<br><br>Please message me on discord with any questions/concerns", discord = "Datev#0660", name = "KS | AIO Hunter", servers = {
		"Zaros" }, version = "2.1", vip = true)

public class AIOHunter extends Script implements LoopingScript, MouseListener, ConfigChangeListener {

	private JFrame frame;
	private Panel panel;

	public enum TYPES {
		TRAPPING,
		BUTTERFLIES,
		SALAMANDERS
	}

	@Getter
	private Methods methods;
	@Getter
	private Traps traps;
	@Getter
	private Net net;
	@Getter
	private Sala sala;

	@Override
	public void onExecute() {
		try {
			Variables.reset();
			addConfig();
			String title = Utils.getValue(getClass(), "name") + " v" + Utils.getValue(getClass(), "version");
			panel = new Panel();
			frame = panel.init(title, panel);
			setupScript();
			Variables.DISPATCHER.addListener(this);
		} catch (Exception e) {
			ctx.log(e.getMessage());
			e.printStackTrace();
		}
	}

	public void addConfig() {
		Config.clear();

		Config.TABS.add(new Tabs(0, "Script Config", "Choose your configuration"));
		Config.CONFIGURATION
				.add(new Config(0, TYPES.class, "TRAPPING", "Hunting", "Train your skill via this method", "huntType"));
		Config.CONFIGURATION
				.add(new Config(0, Butterfly.class, "RUBY_HARVEST", "Butterfly", "Hunt this type of butterfly", "butterflyType"));
		Config.CONFIGURATION.add(
				new Config(0, Salamanders.class, "SWAMP_LIZARD", "Salamander", "Hunt this type of salamander", "salamanderType"));
		Config.CONFIGURATION.add(new Config(0, Trapping.class, "BIRD_SNARE", "Trapping", "Use this type of hunting", "trapType"));
		Config.CONFIGURATION.add(new Config(0, Button.class, true, "Reset tiles", "Reset current selected tiles", "resetTiles"));
		Config.CONFIGURATION
				.add(new Config(0, boolean.class, true, "Show tiles", "Display tiles that are current / possible", "showTiles"));
		Config.CONFIGURATION.add(new Config(0, Button.class, "", "Update Tiles", "Update auto tiles", "updateTiles"));
		Config.setConfigChanged(true);
	}

	public void setupScript() {
		methods = new Methods(ctx, this);
		traps = new Traps(ctx, this);
		net = new Net(ctx, this);
		sala = new Sala(ctx, this);

		Constants.CURRENT_TILES.clear();
		Constants.POSSIBLE_TILES.clear();
		getMethods().fillTempTiles();
	}

	@Override
	public void onProcess() {
		if (!Variables.STARTED || Variables.PAUSED) return;
		if (getType().equals(TYPES.SALAMANDERS)) sala.handle();
		else if (getType().equals(TYPES.BUTTERFLIES)) net.handle();
		else if (getType().equals(TYPES.TRAPPING)) traps.handle();
	}

	@Override
	public void onTerminate() {
		if (frame != null) frame.dispose();
		ctx.log("Shutting down.. Thank you for using the script");
		Variables.reset();
		Config.clear();
	}

	@Override
	public void paint(Graphics arg0) {
		Graphics2D g = (Graphics2D) arg0;
		if (sala == null || Config.CONFIGURATION.size() == 0) return;

		if (panel != null) panel.update(Variables.STATUS);

		if (Config.getB("showTiles")) {
			if (getType().equals(TYPES.SALAMANDERS)) sala.paint(g);
			else if (getType().equals(TYPES.TRAPPING)) traps.paint(g);
			else if (getType().equals(TYPES.BUTTERFLIES)) net.paint(g);
		}
	}

	@Override
	public int loopDuration() {
		return 150;
	}

	@Override
	public void onChatMessage(ChatMessage e) {
		if (e.getType() == ChatMessageType.GAMEMESSAGE) {
			Variables.LAST_MESSAGE = e.getMessage();
			if (e.getMessage().contains("you can't lay a trap here") || e.getMessage().contains("have high enough hunter level"))
				Constants.CURRENT_TILES.remove(ctx.players.getLocal().getLocation());
		}
	}

	public TYPES getType() {
		return Config.getValue("huntType");
	}

	public Butterfly getButterfly() {
		return Config.getValue("butterflyType");
	}

	public Salamanders getSalamander() {
		return Config.getValue("salamanderType");
	}

	public Trapping getTrap() {
		return Config.getValue("trapType");
	}

	@Override
	public void mouseClicked(MouseEvent e) {
	}

	@Override
	public void mousePressed(MouseEvent e) {
		final boolean hotKeyPressed = ctx.getClient().isKeyPressed(KeyCode.KC_SHIFT);
		if (hotKeyPressed && Variables.PAUSED) {
			final Tile selectedSceneTile = ctx.getClient().getSelectedSceneTile();

			if (selectedSceneTile == null) return;

			final WorldPoint worldPoint = WorldPoint.fromLocalInstance(ctx.getClient(), selectedSceneTile.getLocalLocation());
			getMethods().addTile(worldPoint);
			e.consume();
		}
	}

	@Override
	public void mouseReleased(MouseEvent e) {
	}

	@Override
	public void mouseEntered(MouseEvent e) {
	}

	@Override
	public void mouseExited(MouseEvent e) {
	}

	@Override
	public void onChange(ConfigChangeEvent event) {
		String keyName = event.getNewConfig().getKeyName();

		if (keyName == "huntType" || keyName == "updateTiles" || keyName == "salamanderType") {
			if (getType() != TYPES.BUTTERFLIES) {
				Constants.CURRENT_TILES.clear();
				Constants.POSSIBLE_TILES.clear();
				getMethods().fillTempTiles();
			}
		}

		if (keyName == "resetTiles") {
			Constants.CURRENT_TILES.clear();
			Constants.POSSIBLE_TILES.clear();
		}
	}

	public void draw(Graphics2D graphics, Actor actor, String text, Color color) {
		Polygon poly = actor.getCanvasTilePoly();
		if (poly != null) {
			OverlayUtil.renderPolygon(graphics, poly, color);
		}

		Point textLocation = actor.getCanvasTextLocation(graphics, text, actor.getLogicalHeight());
		if (textLocation != null) {
			OverlayUtil.renderTextLocation(graphics, textLocation, text, color);
		}
	}

}

'''
'''--- aiohunter/data/Constants.java ---
package aiohunter.data;

import java.util.concurrent.CopyOnWriteArrayList;

import net.runelite.api.coords.WorldPoint;

public class Constants {

	public static CopyOnWriteArrayList<WorldPoint> CURRENT_TILES = new CopyOnWriteArrayList<WorldPoint>();
	public static CopyOnWriteArrayList<WorldPoint> POSSIBLE_TILES = new CopyOnWriteArrayList<WorldPoint>();

	public static WorldPoint LAST_LOCATION = null;

}

'''
'''--- aiohunter/data/enums/Butterfly.java ---
package aiohunter.data.enums;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;
import net.runelite.api.NpcID;

@AllArgsConstructor
@Getter
public enum Butterfly {

	RUBY_HARVEST(NpcID.RUBY_HARVEST, ItemID.RUBY_HARVEST),
	SAPPHIRE_GLACIALIS(NpcID.SAPPHIRE_GLACIALIS, ItemID.SAPPHIRE_GLACIALIS),
	SNOWY_KNIGHT(NpcID.SNOWY_KNIGHT, ItemID.SNOWY_KNIGHT),
	BLACK_WARLOCK(NpcID.BLACK_WARLOCK, ItemID.BLACK_WARLOCK);

	private int npcId, inventoryId;

}
'''
'''--- aiohunter/data/enums/Salamanders.java ---
package aiohunter.data.enums;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;
import net.runelite.api.ObjectID;

@AllArgsConstructor
@Getter
public enum Salamanders {

	SWAMP_LIZARD(ItemID.SWAMP_LIZARD, ObjectID.YOUNG_TREE_9341, ObjectID.YOUNG_TREE_9257, ObjectID.NET_TRAP_9004),
	ORANGE_SALAMANDER(ItemID.ORANGE_SALAMANDER, ObjectID.YOUNG_TREE_8732, ObjectID.YOUNG_TREE, ObjectID.NET_TRAP_8734),
	RED_SALAMANDER(ItemID.RED_SALAMANDER, ObjectID.YOUNG_TREE_8990, ObjectID.YOUNG_TREE_8989, ObjectID.NET_TRAP_8986),
	BLACK_SALAMANDER(ItemID.BLACK_SALAMANDER, ObjectID.YOUNG_TREE_9000, ObjectID.YOUNG_TREE_8999, ObjectID.NET_TRAP_8996);

	private int inventoryId, unused, active, caught;

}
'''
'''--- aiohunter/data/enums/Trapping.java ---
package aiohunter.data.enums;

import java.util.Arrays;
import java.util.stream.Stream;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;
import net.runelite.api.ObjectID;

@AllArgsConstructor
@Getter
public enum Trapping {
	BIRD_SNARE("Lay", "Check", ItemID.BIRD_SNARE, ObjectID.BIRD_SNARE_9345, ObjectID.BOX_TRAP_9385,
			new int[] { ObjectID.BIRD_SNARE_9373, ObjectID.BIRD_SNARE_9375, ObjectID.BIRD_SNARE_9377, ObjectID.BIRD_SNARE_9379,
					ObjectID.BIRD_SNARE_9348 },
			new int[] { ItemID.BONES, ItemID.RAW_BIRD_MEAT }),
	BOX_TRAP("Lay", "Reset", ItemID.BOX_TRAP, ObjectID.BOX_TRAP_9380, ObjectID.SHAKING_BOX,
			new int[] { ObjectID.BOX_TRAP_9385, ObjectID.SHAKING_BOX_9382, ObjectID.SHAKING_BOX_9383 }, new int[] {});

	private String setAction, caughtAction;

	private int inventoryId, activeTrap, failedTrap;

	private int[] caughtTrap, junkId;

	public static int[] getActiveTraps() {
		return Stream.of(Trapping.values()).mapToInt(Trapping::getActiveTrap).toArray();
	}

	public static int[] getFailedTraps() {
		return Stream.of(Trapping.values()).mapToInt(Trapping::getFailedTrap).toArray();
	}

	public static int[] getCaughtTraps() {
		return Stream.of(Trapping.values()).flatMapToInt(i -> Arrays.stream(i.getCaughtTrap())).toArray();
	}
}

'''
'''--- aiohunter/methods/Methods.java ---
package aiohunter.methods;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.BooleanSupplier;
import java.util.stream.Collectors;

import aiohunter.AIOHunter;
import aiohunter.AIOHunter.TYPES;
import aiohunter.data.Constants;
import aiohunter.data.enums.Trapping;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ObjectID;
import net.runelite.api.coords.WorldPoint;
import simple.api.Variables;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.queries.SimpleEntityQuery;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;
import simple.robot.utils.Random;
import simple.robot.utils.WorldArea;

@RequiredArgsConstructor
public class Methods {

	@NonNull
	private ClientContext ctx;
	@NonNull
	private AIOHunter core;

	public WorldPoint getNextTile() {
		return Constants.CURRENT_TILES.stream().unordered().filter(this::validTile).findAny().orElse(null);
	}

	public boolean validTile(WorldPoint tile) {
		SimpleEntityQuery<SimpleObject> q = ctx.objects.populate().filter(tile);
		if (!q.filter(core.getTrap().getActiveTrap()).isEmpty()) return false;

		boolean v = q.filter(merge(Trapping.getFailedTraps(), Trapping.getCaughtTraps())).isEmpty();
		if (!v) return true;
		return true;
	}

	public void delay(BooleanSupplier arg0) {
		delay(arg0, 500);
	}

	public void delay(BooleanSupplier arg0, int delay) {
		if (Variables.LAST_MESSAGE.contains("you can't lay a trap here")) return;
		ctx.onCondition(() -> ctx.players.getLocal().getAnimation() != -1);
		ctx.onCondition(() -> ctx.players.getLocal().getAnimation() == -1);
		ctx.onCondition(arg0, delay);
	}

	public int[] merge(int[]... val) {
		return Arrays.stream(val).flatMapToInt(i -> Arrays.stream(i)).toArray();
	}

	public void addTrap() {
		if (Constants.POSSIBLE_TILES.size() == 0) return;
		if (Constants.CURRENT_TILES.size() < getTrapAmount()) {
			System.out.println("Tiles left: " + Constants.POSSIBLE_TILES.size());
			ctx.log("Adding another trap");
			int random = Random.between(0, Constants.POSSIBLE_TILES.size() - 1);
			Constants.CURRENT_TILES.add(Constants.POSSIBLE_TILES.get(random));
			Constants.POSSIBLE_TILES.remove(random);
		}
	}

	public int getTrapAmount() {
		int level = ctx.skills.level(Skills.HUNTER);
		return level >= 80 ? 5 : level >= 60 ? 4 : level >= 40 ? 3 : level >= 20 ? 2 : 1;
	}

	public CopyOnWriteArrayList<WorldPoint> getAutoTiles(int range) {
		CopyOnWriteArrayList<WorldPoint> tempArr = new CopyOnWriteArrayList<WorldPoint>();
		if (core.getType().equals(TYPES.SALAMANDERS)) {
			ctx.objects.populate().filter(core.getSalamander().getUnused()).filterWithin(10)
					.forEach(tree -> tempArr.add(tree.getLocation()));
		} else {
			int[] INVALID_TILES = merge(Trapping.getActiveTraps(), Trapping.getCaughtTraps(), Trapping.getFailedTraps(),
					new int[] { ObjectID.FERN_19839, ObjectID.FERN_19840 });

			final WorldArea area = new WorldArea(
					new WorldPoint(Constants.LAST_LOCATION.getX() - range, Constants.LAST_LOCATION.getY() + range,
							Constants.LAST_LOCATION.getPlane()),
					new WorldPoint(Constants.LAST_LOCATION.getX() + range, Constants.LAST_LOCATION.getY() - range,
							Constants.LAST_LOCATION.getPlane()));

			tempArr.addAll(Arrays.asList(area.getWorldPoints()));

			tempArr.removeIf(
					tile -> !ctx.pathing.reachable(tile) || !ctx.objects.populate().filter(tile).filter(INVALID_TILES).isEmpty());
		}
		System.out.println("Found " + tempArr.size() + " valid tiles");

		return tempArr;
	}

	public void addTile(WorldPoint tile) {
		if (Constants.CURRENT_TILES.contains(tile)) Constants.CURRENT_TILES.remove(tile);
		if (Constants.POSSIBLE_TILES.contains(tile)) Constants.POSSIBLE_TILES.remove(tile);
		else Constants.POSSIBLE_TILES.add(tile);
	}

	public void fillTempTiles() {
		if (Constants.LAST_LOCATION == null || !Constants.LAST_LOCATION.equals(ctx.players.getLocal().getLocation())) {
			Constants.LAST_LOCATION = ctx.players.getLocal().getLocation();
		}
		if (!Constants.POSSIBLE_TILES.isEmpty()) return;
		Constants.POSSIBLE_TILES = getAutoTiles(3);
	}

	public boolean hasItems(String... itemName) {
		List<String> inv = ctx.inventory.populate().toStream().map(item -> item.getName()).map(String::toLowerCase)
				.collect(Collectors.toList());
		return itemName.length == Arrays.stream(itemName).map(String::toLowerCase)
				.filter(val -> inv.stream().anyMatch(arr -> arr.contains(val))).count();
	}

}

'''
'''--- aiohunter/methods/Net.java ---
package aiohunter.methods;

import java.awt.Color;
import java.awt.Graphics2D;

import aiohunter.AIOHunter;
import aiohunter.data.enums.Butterfly;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;
import simple.api.Variables;
import simple.hooks.queries.SimpleEntityQuery;
import simple.hooks.queries.SimpleItemQuery;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.robot.api.ClientContext;

@RequiredArgsConstructor
public class Net {

	@NonNull
	private ClientContext ctx;
	@NonNull
	private AIOHunter core;

	public void handle() {
		Butterfly bf = core.getButterfly();

		int empty = ctx.inventory.populate().filter(ItemID.BUTTERFLY_JAR).population();

		if (empty == 0) {
			Variables.STATUS = "Releasing butterflies";
			SimpleItemQuery<SimpleItem> query = ctx.inventory.populate().filter(bf.getInventoryId());

			if (query.isEmpty()) {
				Variables.STATUS = "No butterfly jars left";
				ctx.log("No butterfly jars left");
				ctx.stopScript();
				return;
			}

			query.forEach(item -> item.click("Release"));
		}

		SimpleNpc butterfly = ctx.npcs.populate().filter(bf.getNpcId()).nearest().next();
		Variables.STATUS = "Catching butterflies";
		if (butterfly != null && butterfly.validateInteractable() && butterfly.click("Catch"))
			core.getMethods().delay(() -> true);
	}

	public void paint(Graphics2D g) {
		SimpleEntityQuery<SimpleNpc> npcs = ctx.npcs.populate().filter(core.getButterfly().getNpcId()).filterWithin(20);
		npcs.forEach(npc -> core.draw(g, npc.getActor(), "", Color.GREEN));
	}
}

'''
'''--- aiohunter/methods/Sala.java ---
package aiohunter.methods;

import java.awt.Color;
import java.awt.Graphics2D;
import java.util.stream.Stream;

import aiohunter.AIOHunter;
import aiohunter.data.Constants;
import aiohunter.data.enums.Salamanders;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;
import net.runelite.api.coords.WorldPoint;
import simple.api.Utils;
import simple.api.Variables;
import simple.hooks.wrappers.SimpleGroundItem;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;
import simple.robot.utils.WorldArea;

@RequiredArgsConstructor
public class Sala {

	@NonNull
	private ClientContext ctx;
	@NonNull
	private AIOHunter core;

	public void handle() {
		Salamanders salamander = core.getSalamander();

		core.getMethods().addTrap();

		if (Constants.CURRENT_TILES.size() == 0) {
			Variables.STATUS = "No valid trees found";
			return;
		}

		if (ctx.inventory.inventoryFull()) ctx.inventory.dropItems(ctx.inventory.populate().filter(salamander.getInventoryId()));

		SimpleGroundItem items = ctx.groundItems.populate().filter(ItemID.ROPE, ItemID.SMALL_FISHING_NET)
				.filter(loc -> ourTrap(loc.getLocation())).nearest().next();

		SimpleObject UNUSED_TREE = ctx.objects.populate().filter(salamander.getUnused())
				.filter(obj -> Constants.CURRENT_TILES.contains(obj.getLocation())).nearest().next();

		if (UNUSED_TREE != null && core.getMethods().hasItems("Rope", "Small Fishing Net")) {
			Variables.STATUS = "Setting up trap";
			if (UNUSED_TREE != null && UNUSED_TREE.validateInteractable() && UNUSED_TREE.click("Set-Trap"))
				core.getMethods().delay(
						() -> !ctx.objects.populate().filter(UNUSED_TREE.getLocation()).filter(salamander.getActive()).isEmpty());
			return;
		}

		if (items != null) {
			Variables.STATUS = "Taking ground items";
			if (items.validateInteractable() && items.click("Take"))
				ctx.onCondition(() -> ctx.pathing.onTile(items.getLocation()), 2200);
			return;
		}

		SimpleObject CAUGHT_TREE = ctx.objects.populate().filter(salamander.getCaught()).filter(obj -> ourTrap(obj.getLocation()))
				.nearest().next();
		if (CAUGHT_TREE != null) {
			Variables.STATUS = "Checking trap";
			if (CAUGHT_TREE.validateInteractable() && CAUGHT_TREE.click("Check")) core.getMethods().delay(
					() -> ctx.objects.populate().filter(CAUGHT_TREE.getLocation()).filter(salamander.getCaught()).isEmpty());
		} else {
			Variables.STATUS = "Idling";
		}

	}

	private boolean ourTrap(WorldPoint loc) {
		WorldArea area = Utils.makeArea(loc.getX() + 2, loc.getY() + 2, loc.getX() - 2, loc.getY() - 2, 0);
		return Stream.of(area.getWorldPoints()).anyMatch(tile -> Constants.CURRENT_TILES.contains(tile));
	}

	public void paint(Graphics2D g) {
		if (Variables.PAUSED || !Variables.STARTED)
			Constants.POSSIBLE_TILES.forEach(tile -> ctx.paint.drawTileMatrix(g, tile, Color.RED));
		Constants.CURRENT_TILES.forEach(tile -> ctx.paint.drawTileMatrix(g, tile, Color.GREEN));
	}
}

'''
'''--- aiohunter/methods/Traps.java ---
package aiohunter.methods;

import java.awt.Color;
import java.awt.Graphics2D;

import aiohunter.AIOHunter;
import aiohunter.data.Constants;
import aiohunter.data.enums.Trapping;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.util.Text;
import simple.api.Variables;
import simple.hooks.wrappers.SimpleGroundItem;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;
import simple.robot.utils.Random;

@RequiredArgsConstructor
public class Traps {

	@NonNull
	private ClientContext ctx;
	@NonNull
	private AIOHunter core;

	public void handle() {
		Trapping trap = core.getTrap();

		core.getMethods().addTrap();

		if (Constants.CURRENT_TILES.size() == 0) {
			Variables.STATUS = "No more valid tiles";
			return;
		}

		if (ctx.inventory.getFreeSlots() < 3) ctx.inventory.dropItems(ctx.inventory.populate().filter(trap.getJunkId()));

		WorldPoint spot = core.getMethods().getNextTile();

		if (spot != null) {

			int[] objects = core.getMethods().merge(Trapping.getFailedTraps(), Trapping.getCaughtTraps());

			SimpleObject obj = ctx.objects.populate().filter(spot).filter(objects).next();

			SimpleGroundItem groundItem = ctx.groundItems.populate().filter(spot).filter(trap.getInventoryId()).nearest().next();

			if (groundItem != null && groundItem.validateInteractable()) {
				Variables.STATUS = "Laying " + Text.titleCase(trap);
				if (groundItem.click("Lay")) core.getMethods()
						.delay(() -> !ctx.objects.populate().filter(spot).filter(trap.getActiveTrap()).isEmpty(), 2000);
			} else if (obj == null && !ctx.inventory.populate().filter(trap.getInventoryId()).isEmpty()) {
				if (!ctx.pathing.onTile(spot)) {
					Variables.STATUS = "Walking to next tile";
					ctx.pathing.step(spot);
					ctx.onCondition(() -> ctx.pathing.onTile(spot), 1500);
					return;
				}

				if (!ctx.pathing.onTile(spot)) return;
				SimpleItem item = ctx.inventory.filter(trap.getInventoryId()).next();

				Variables.STATUS = "Setting " + Text.titleCase(trap);
				if (item != null && item.click(0)) core.getMethods()
						.delay(() -> !ctx.objects.populate().filter(spot).filter(trap.getActiveTrap()).isEmpty(), 1500);
			} else if (obj != null && Random.containsId(obj.getId(), trap.getCaughtTrap())) {
				Variables.STATUS = "Checking " + Text.titleCase(trap);
				if (obj.validateInteractable() && obj.click(trap.getCaughtAction())) core.getMethods()
						.delay(() -> !ctx.objects.populate().filter(spot).filter(trap.getActiveTrap()).isEmpty(), 1500);
			} else if (obj != null && Random.containsId(obj.getId(), trap.getFailedTrap())) {
				Variables.STATUS = "Resetting " + Text.titleCase(trap);
				if (obj.validateInteractable() && obj.click(trap.getSetAction())) core.getMethods()
						.delay(() -> !ctx.objects.populate().filter(spot).filter(trap.getActiveTrap()).isEmpty(), 2500);
			}
		} else {
			Variables.STATUS = "Idling";
		}
	}

	public void paint(Graphics2D g) {
		if (Variables.PAUSED || !Variables.STARTED)
			Constants.POSSIBLE_TILES.forEach(tile -> ctx.paint.drawTileMatrix(g, tile, Color.RED));
		Constants.CURRENT_TILES.forEach(tile -> ctx.paint.drawTileMatrix(g, tile, Color.GREEN));
	}
}

'''
'''--- aioslayer/AIOSlayer.java ---
package aioslayer;

import java.awt.Graphics;
import java.io.IOException;
import java.util.Map.Entry;
import java.util.function.BooleanSupplier;
import java.util.stream.Stream;

import javax.swing.JFrame;

import aioslayer.data.Builder;
import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import aioslayer.data.master.Nieve;
import api.Locations;
import api.Tasks;
import api.Variables;
import api.panel.Config;
import api.panel.Panel;
import api.panel.Tabs;
import api.threads.PrayerObserver;
import api.utils.Utils;
import net.runelite.api.ChatMessageType;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.robot.script.Script;

@ScriptManifest(author = "Trester/Lead-Assistant-scripter-KremeSickle", category = Category.SLAYER, description = "AIO Slayer", discord = "", name = "AIO Slayer", servers = {
		"Zaros" }, version = "1")
public class AIOSlayer extends Script implements LoopingScript {

	private PrayerObserver prayerObserver = null;

	private JFrame frame;
	private Panel panel;

	@Override
	public void onExecute() {
		try {
			Tasks.init(ctx);
			reset();
			Constants.MASTER = new Nieve();
			addConfig();
			String title = Utils.getValue(getClass(), "name") + " v" + Utils.getValue(getClass(), "version");
			panel = new Panel();
			frame = panel.init(title, panel);
			Utils.setZoom(1);

			prayerObserver = new PrayerObserver(ctx, new BooleanSupplier() {
				@Override
				public boolean getAsBoolean() {
					return Variables.USE_PRAYER;
				}
			});
			prayerObserver.start();

		} catch (Exception e) {
			ctx.log(e.getMessage());
			e.printStackTrace();
		}
	}

	public void addConfig() throws IOException {
		Config.TABS.add(new Tabs(0, "Script Config", "Choose your configuration"));
		Config.CONFIGURATION.add(new Config(0, boolean.class, true, "Alch", "Alch items", "doAlch"));

		Config.TABS.add(new Tabs(1, "Monster Config", "Choose your locations"));
		for (Entry<String, MonsterTask> entry : Builder.monsterDict.entrySet()) {
			if (entry.getValue().areas().length > 1) Config.CONFIGURATION.add(new Config(1, entry.getValue().areas(), "",
					entry.getValue().getName(), "Where to kill them at", entry.getKey()));
		}
		Config.load(getStorageDirectory() + ctx.players.getLocal().getName());
		Config.setConfigChanged(true);
	}

	@Override
	public void onProcess() {
		if (!Variables.STARTED) return;

		if (Variables.STOP) {
			Tasks.getSkill().disablePrayers();
			if (!ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
				ctx.magic.castSpellOnce("Home Teleport");
			}
			return;
		}

		if ((!ctx.pathing.inArea(Locations.EDGEVILLE_AREA) && Tasks.getAntiban().staffNearby())
				|| (Tasks.getAntiban().staffUnder() && !ctx.pathing.inArea(Locations.EDGEVILLE_BANK))) {
			ctx.log("Staff found at " + ctx.players.getLocal().getLocation());
			Variables.STOP = true;
			return;
		}

		if (!ctx.combat.autoRetaliate()) ctx.combat.toggleAutoRetaliate(true);

		if (Tasks.getSlayer().shouldBank() && !ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
			Tasks.getSkill().disablePrayers();
			ctx.magic.castSpellOnce("Home Teleport");
		} else if (ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
			Tasks.getSkill().disablePrayers();
			if (Tasks.getCombat().getMonsterTimer().isRunning()) Tasks.getCombat().getMonsterTimer().end();
			if (!Tasks.getBanking().heal()) return;
			if (!Tasks.getBanking().usePreset(true)) return;
			Variables.FORCE_BANK = false;
		}
		if (Constants.TASK == null) {
			Tasks.getCombat().getMonsterTimer().reset();
			Tasks.getSlayer().handleTask();
		} else if (!Constants.TASK.atLocation()) {
			Constants.TASK.equipGear();
			Constants.TASK.travel();
		} else {
			Tasks.getSkill().enablePrayers();
			Constants.TASK.attack();
		}
	}

	@Override
	public int loopDuration() {
		return 400;
	}

	@Override
	public void onTerminate() {
		if (frame != null) frame.dispose();
		try {
			Config.save(getStorageDirectory() + ctx.players.getLocal().getName());
		} catch (Exception e) {
			e.printStackTrace();
		}

		ctx.log("Shutting down.. Thank you for using the script");
		Tasks.getSkill().disablePrayers();
		if (prayerObserver != null) prayerObserver.interrupt();
		if (!ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
			ctx.magic.castSpellOnce("Home Teleport");
		}
		reset();
	}

	@Override
	public void paint(Graphics Graphs) {
		if (panel != null) panel.update(Variables.STATUS);
	}

	final String[] STOP_MESSAGES = { "you are dead", "no ammo" };

	@Override
	public void onChatMessage(ChatMessage msg) {
		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			String message = msg.getMessage();
			Variables.LAST_MESSAGE = message;
			if (message.contains("you're assigned to kill")) {
				String name = msg.getMessage().replaceAll("(.*) kill (.*); (.*)", "$2");

				Constants.SHOULD_SKIP = false;
				MonsterTask result = Builder.getMonsterByString(name);

				if (Tasks.getSlayer().shouldSkip(name)) {
					System.out.println("SKIP");
					Constants.SHOULD_CHECK_TASK = false;
					Constants.SHOULD_SKIP = true;
					Constants.TASK = null;
					return;
				} else if (result == null) {
					ctx.log(name);
					ctx.log("NPC: " + name + " could not be found, stopping script.");
					ctx.stopScript();
					return;
				}

				Constants.TASK = result;
				Constants.SHOULD_CHECK_TASK = true;
				Constants.SHOULD_SKIP = false;
			}

			if (message.contains("wants you to stick to your slayer assignments") || message.contains("something new to")
					|| message.contains(" giving you a total of ")) {
				ctx.log(message);
				ctx.log("Resetting task");
				Constants.TASK = null;
				Variables.FORCE_BANK = true;
				Constants.SHOULD_CHECK_TASK = false;
			}
			if (!Variables.STOP) {
				Variables.STOP = Stream.of(STOP_MESSAGES).anyMatch(msg1 -> message.contains(msg1));
			}
		}
	}

	public void reset() {
		Variables.reset();
		Config.clear();
		Constants.SHOULD_CHECK_TASK = true;
		Constants.TASK = null;
		Constants.SHOULD_SKIP = false;
		Tasks.getCombat().getMonsterTimer().end();
		Variables.FORCE_BANK = ctx.pathing.inArea(Locations.EDGEVILLE_AREA);
	}
}

'''
'''--- aioslayer/data/Builder.java ---
package aioslayer.data;

import java.util.Hashtable;

import aioslayer.data.tasks.AberrantSpectres;
import aioslayer.data.tasks.AbyssalDemon;
import aioslayer.data.tasks.Ankou;
import aioslayer.data.tasks.BlackDemons;
import aioslayer.data.tasks.BlackDragons;
import aioslayer.data.tasks.Bloodvelds;
import aioslayer.data.tasks.BlueDragons;
import aioslayer.data.tasks.CaveHorrors;
import aioslayer.data.tasks.Dagannoth;
import aioslayer.data.tasks.DarkBeasts;
import aioslayer.data.tasks.DustDevils;
import aioslayer.data.tasks.Elves;
import aioslayer.data.tasks.FireGiants;
import aioslayer.data.tasks.Gargoyle;
import aioslayer.data.tasks.GreaterDemon;
import aioslayer.data.tasks.Hellhounds;
import aioslayer.data.tasks.IronDragons;
import aioslayer.data.tasks.Kalphite;
import aioslayer.data.tasks.Kurask;
import aioslayer.data.tasks.Nechryael;
import aioslayer.data.tasks.SmokeDevil;
import aioslayer.data.tasks.SteelDragons;
import aioslayer.data.tasks.Suqah;
import aioslayer.data.tasks.Trolls;
import aioslayer.data.tasks.Turoth;

public class Builder {
	public static Hashtable<String, MonsterTask> monsterDict = new Hashtable<String, MonsterTask>();

	static {
		monsterDict.put("cave horrors", new CaveHorrors());
		monsterDict.put("ankou", new Ankou());
		monsterDict.put("gargoyles", new Gargoyle());
		monsterDict.put("dagannoth", new Dagannoth());
		monsterDict.put("hellhounds", new Hellhounds());
		monsterDict.put("fire giants", new FireGiants());
		monsterDict.put("greater demons", new GreaterDemon());
		monsterDict.put("nechryael", new Nechryael());
		monsterDict.put("abyssal demons", new AbyssalDemon());
		monsterDict.put("black demons", new BlackDemons());
		monsterDict.put("bloodveld", new Bloodvelds());
		monsterDict.put("dark beasts", new DarkBeasts());
		monsterDict.put("dust devils", new DustDevils());
		monsterDict.put("elves", new Elves());
		monsterDict.put("kurask", new Kurask());
		monsterDict.put("smoke devils", new SmokeDevil());
		monsterDict.put("suqah", new Suqah());
		monsterDict.put("trolls", new Trolls());
		monsterDict.put("turoth", new Turoth());
		monsterDict.put("kalphite", new Kalphite());
		monsterDict.put("aberrant spectres", new AberrantSpectres());
		monsterDict.put("black dragons", new BlackDragons());
		monsterDict.put("steel dragons", new SteelDragons());
		monsterDict.put("iron dragons", new IronDragons());
		monsterDict.put("blue dragons", new BlueDragons());
	}

	public static MonsterTask getMonsterByString(String s) {
		s = s.toLowerCase();
		return monsterDict.get(s);
	}

}

'''
'''--- aioslayer/data/Constants.java ---
package aioslayer.data;

public class Constants {

	public static MonsterTask TASK = null;
	public static Masters MASTER = null;

	public static boolean SHOULD_CHECK_TASK = true;
	public static boolean SHOULD_SKIP = false;

}

'''
'''--- aioslayer/data/Masters.java ---
package aioslayer.data;

import simple.robot.api.ClientContext;

public interface Masters {

	ClientContext ctx = ClientContext.instance();

	String getName();

	int getId();

	boolean atLocation();

	void travel();
}

'''
'''--- aioslayer/data/MonsterTask.java ---
package aioslayer.data;

import simple.hooks.filters.SimplePrayers.Prayers;
import simple.robot.api.ClientContext;

public interface MonsterTask {

	ClientContext ctx = ClientContext.instance();

	String getName();

	String[] lootList();

	int[] getId();

	void equipGear();

	boolean atLocation();

	void travel();

	void attack();

	String[] areas();

	Prayers getProtection();
}

'''
'''--- aioslayer/data/master/Example.java ---
package aioslayer.data.master;

import aioslayer.data.Masters;

public class Example implements Masters {

	@Override
	public String getName() {
		return "Example";
	}

	@Override
	public int getId() {
		return -1;
	}

	@Override
	public void travel() {

	}

	@Override
	public boolean atLocation() {
		return false;

	}
}

'''
'''--- aioslayer/data/master/Nieve.java ---
package aioslayer.data.master;

import aioslayer.data.Masters;
import api.Locations;
import api.MenuActions;
import api.Tasks;
import net.runelite.api.MenuAction;
import simple.robot.api.ClientContext;

public class Nieve implements Masters {

	@Override
	public String getName() {
		return "Nieve";
	}

	@Override
	public int getId() {
		return 6797;
	}

	@Override
	public boolean atLocation() {
		return ctx.pathing.inArea(Locations.EDGEVILLE_AREA) && Tasks.getCombat().getNPC(getId()) != null;
	}

	@Override
	public void travel() {
		MenuActions.invoke("", "", 1, MenuAction.CC_OP.getId(), 1, 14286853);
		ClientContext.instance().sleep(450);
		ClientContext.instance().onCondition(() -> ClientContext.instance().players.getLocal().getAnimation() != -1);
		ClientContext.instance().onCondition(() -> ClientContext.instance().players.getLocal().getAnimation() == -1);
		ClientContext.instance().sleep(1500);
	}
}
'''
'''--- aioslayer/data/tasks/AberrantSpectres.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class AberrantSpectres implements MonsterTask {

	@Override
	public String getName() {
		return "Aberrant spectres";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Torstol seed", "Ancient shard", "Dark totem base", "Dark totem middle",
				"Dark totem top", "Torstol seed", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.ABERRANT_SPECTRE, NpcID.DEVIANT_SPECTRE };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("catacomb");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	@Override
	public String[] areas() {
		return new String[] { "Slayer Tower", "Nieve's Cave", "Catacombs of Kourend" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MAGIC;
	}

}

'''
'''--- aioslayer/data/tasks/AbyssalDemon.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class AbyssalDemon implements MonsterTask {

	@Override
	public String getName() {
		return "Abyssal demons";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Abyssal head", "Abyssal whip", "Abyssal dagger", "Ancient shard",
				"Dark totem base", "Dark totem middle", "Dark totem top", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.ABYSSAL_DEMON, NpcID.ABYSSAL_DEMON_415, NpcID.ABYSSAL_DEMON_416, NpcID.ABYSSAL_DEMON_7241 };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("basement");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Slayer Tower (basement)", "Slayer Tower", "Catacombs of Kourend", "Abyssal Area" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}
}

'''
'''--- aioslayer/data/tasks/Ankou.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class Ankou implements MonsterTask {

	@Override
	public String getName() {
		return "Ankou";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Torstol seed", "Ancient shard", "Dark totem base", "Dark totem middle",
				"Dark totem top", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.ANKOU, NpcID.ANKOU_2516, NpcID.ANKOU_7257 };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("nieve");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Stronghold of Security", "Catacombs of Kourend" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

}

'''
'''--- aioslayer/data/tasks/BlackDemons.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class BlackDemons implements MonsterTask {

	@Override
	public String getName() {
		return "Black demons";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Ancient shard", "Dark totem base", "Dark totem middle", "Dark totem top",
				"Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.BLACK_DEMON, NpcID.BLACK_DEMON_7242, NpcID.BLACK_DEMON_7243 };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("taverley");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getName());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Brimhaven Dungeon", "Catacombs of Kourend", "Taverley Dungeon" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

}
'''
'''--- aioslayer/data/tasks/BlackDragons.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import api.tasks.Supplies.PotionType;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.filters.SimplePrayers.Prayers;

public class BlackDragons implements MonsterTask {

	@Override
	public String getName() {
		return "Black dragons";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Coins", "Draconic visage" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.BLACK_DRAGON, NpcID.BLACK_DRAGON_253, NpcID.BLACK_DRAGON_254, NpcID.BLACK_DRAGON_255,
				NpcID.BLACK_DRAGON_256, NpcID.BLACK_DRAGON_257, NpcID.BLACK_DRAGON_258, NpcID.BLACK_DRAGON_259 };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("taverley");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) {
			if (!Tasks.getSupplies().antiFire.isRunning()) Tasks.getSupplies().drink(PotionType.ANTIFIRE);
			Tasks.getSlayer().fightNpc();
		}

	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	private final String[] shield = { "dragon shield", "dragonfire" };

	@Override
	public void equipGear() {
		boolean equipped = Tasks.getInventory().isWearing(EquipmentSlot.SHIELD, shield);
		if (!equipped && Tasks.getInventory().contains(shield)) Tasks.getInventory().equip(shield);
	}

	@Override
	public String[] areas() {
		return new String[] { "Taverly Dungeon (expansion)", "Taverly Dungeon", "Catacombs of Kourend" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}
}

'''
'''--- aioslayer/data/tasks/Bloodvelds.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class Bloodvelds implements MonsterTask {

	@Override
	public String getName() {
		return "Bloodveld";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Ancient shard", "Dark totem base", "Dark totem middle", "Dark totem top",
				"Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.BLOODVELD, NpcID.MUTATED_BLOODVELD };
	}

	/*
	 * Nieve's Cave Slayer Tower (basement) Slayer tower Catacombs of Kourend
	 */
	@Override
	public void travel() {
		Tasks.getSlayer().useRing("Catacombs of Kourend");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Slayer Tower", "Slayer Tower (basement)", "Catacombs of Kourend", "Stronghold Slayer Cave" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

}
'''
'''--- aioslayer/data/tasks/BlueDragons.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import api.tasks.Supplies.PotionType;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.filters.SimplePrayers.Prayers;

public class BlueDragons implements MonsterTask {

	@Override
	public String getName() {
		return "Blue dragons";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Coins", "Draconic visage" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.BLUE_DRAGON };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("taverley");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) {
			if (!Tasks.getSupplies().antiFire.isRunning()) Tasks.getSupplies().drink(PotionType.ANTIFIRE);
			Tasks.getSlayer().fightNpc();
		}
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		boolean equipped = Tasks.getInventory().isWearing(EquipmentSlot.SHIELD, "dragon shield", "dragonfire");
		if (!equipped && Tasks.getInventory().contains("dragon shield", "dragonfire"))
			Tasks.getInventory().equip("dragon shield", "dragonfire");
	}

	@Override
	public String[] areas() {
		return new String[] { "Taverly Dungeon", "Taverly Dungeon (expansion)", "Catacombs of Kourend" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}
}
'''
'''--- aioslayer/data/tasks/CaveHorrors.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class CaveHorrors implements MonsterTask {

	@Override
	public String getName() {
		return "Cave horror";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Black mask", "Torstol seed", "Curved bone", "Long bone", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.CAVE_HORROR, NpcID.CAVE_HORROR_1048, NpcID.CAVE_HORROR_1049, NpcID.CAVE_HORROR_1050,
				NpcID.CAVE_HORROR_1051 };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("Mos'le Harmless");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Mos'le Harmless" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}
}
'''
'''--- aioslayer/data/tasks/Dagannoth.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class Dagannoth implements MonsterTask {

	@Override
	public String getName() {
		return "Dagannoth";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Ancient shard", "Dark totem base", "Dark totem middle", "Dark totem top",
				"Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.DAGANNOTH_7259, NpcID.DAGANNOTH_7260 };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("Catacombs of Kourend");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Waterbirth", "Catacombs of Kourend", "Lighthouse Dungeon" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}
}

'''
'''--- aioslayer/data/tasks/DarkBeasts.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class DarkBeasts implements MonsterTask {

	@Override
	public String getName() {
		return "Dark beasts";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Dark bow", "Torstol seed", "Runite ore", "Black d'hide body", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.DARK_BEAST };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("Ardougne");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Ardougne" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

}

'''
'''--- aioslayer/data/tasks/DustDevils.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class DustDevils implements MonsterTask {

	@Override
	public String getName() {
		return "Dust Devils";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Dragon chainbody", "Dust battlestaff", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.DUST_DEVIL, 7249 };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("Catacombs of Kourend");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Smoke Dungeon", "Pollnivneach", "Catacombs of Kourend" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

}

'''
'''--- aioslayer/data/tasks/Elves.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class Elves implements MonsterTask {

	@Override
	public String getName() {
		return "Elves";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Torstol seed", "crystal", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.ELF_ARCHER, NpcID.ELF_WARRIOR, NpcID.IORWERTH_ARCHER, NpcID.IORWERTH_WARRIOR };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing();
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

}

'''
'''--- aioslayer/data/tasks/FireGiants.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class FireGiants implements MonsterTask {

	@Override
	public String getName() {
		return "Fire Giants";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.FIRE_GIANT, NpcID.FIRE_GIANT_7251, NpcID.FIRE_GIANT_7252 };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing();
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Nieve's Cave", "Brimhaven Dungeon", "Catacombs of Kourend", "Karuulm Slayer Dungeon" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}
}

'''
'''--- aioslayer/data/tasks/Gargoyle.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import api.Variables;
import net.runelite.api.MenuAction;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.robot.api.ClientContext;

public class Gargoyle implements MonsterTask {

	@Override
	public String getName() {
		return "Gargoyles";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Granite maul", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.GARGOYLE, NpcID.GARGOYLE_1543, NpcID.GARGOYLE_413 };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("tower");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) {
			SimpleNpc npc = Tasks.getCombat().getAggressiveNPC(Constants.TASK.getId());
			if (npc != null && npc.getHealthRatio() > -1 && npc.getHealthRatio() <= 3) {
				Variables.STATUS = "Smashing...";
				SimpleItem hammer = Tasks.getInventory().getItem("Rock hammer");
				if (!Tasks.getMenuAction().get(hammer, "Use").invoke()) return;

				if (Tasks.getMenuAction().get(npc, "Attack").setMenuAction(MenuAction.ITEM_USE_ON_NPC).invoke())
					ClientContext.instance().sleep(350);

			} else {
				Tasks.getSlayer().fightNpc();
			}
		}
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Slayer Tower", "Slayer Tower (basement)" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}
}

'''
'''--- aioslayer/data/tasks/GreaterDemon.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class GreaterDemon implements MonsterTask {

	@Override
	public String getName() {
		return "Greater demons";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.GREATER_DEMON, NpcID.GREATER_DEMON_7244, NpcID.GREATER_DEMON_7245 };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("kourend");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Chasm of Fire", "Catacombs of Kourend", "Karuulm Slayer Dungeon" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}
}

'''
'''--- aioslayer/data/tasks/Hellhounds.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class Hellhounds implements MonsterTask {

	@Override
	public String getName() {
		return "Hellhounds";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.HELLHOUND, NpcID.HELLHOUND_7256 };
	}

	/*
	 * Nieve's Cave Taverly Dungeon Catacombs of Kourdend Revenant Cave (19)
	 * Karuulm Slayer Dungeon
	 */

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("Kourend");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub
	}

	public String[] areas() {
		return new String[] { "Nieve's Cave", "Taverly Dungeon", "Karuulm Slayer Dungeon", "Catacombs of Kourend" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

}

'''
'''--- aioslayer/data/tasks/IronDragons.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import api.tasks.Supplies.PotionType;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.filters.SimplePrayers.Prayers;

public class IronDragons implements MonsterTask {

	@Override
	public String getName() {
		return "Iron dragons";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Coins", "Draconic visage" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.IRON_DRAGON, NpcID.IRON_DRAGON_273 };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("haven");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) {
			if (!Tasks.getSupplies().antiFire.isRunning()) Tasks.getSupplies().drink(PotionType.ANTIFIRE);
			Tasks.getSlayer().fightNpc();
		}
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		boolean equipped = Tasks.getInventory().isWearing(EquipmentSlot.SHIELD, "dragon shield", "dragonfire");
		if (!equipped && Tasks.getInventory().contains("dragon shield", "dragonfire"))
			Tasks.getInventory().equip("dragon shield", "dragonfire");
	}

	@Override
	public String[] areas() {
		return new String[] { "Brimhaven" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

}
'''
'''--- aioslayer/data/tasks/Kalphite.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Locations;
import api.Tasks;
import net.runelite.api.NpcID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimplePrayers.Prayers;

public class Kalphite implements MonsterTask {

	@Override
	public String getName() {
		return "Kalphite";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.KALPHITE_GUARDIAN, NpcID.KALPHITE_GUARDIAN_960, NpcID.KALPHITE_GUARDIAN_962,
				NpcID.KALPHITE_WORKER };
	}

	@Override
	public void travel() {
		if (Locations.EDGEVILLE_AREA.containsPoint(ctx.players.getLocal().getLocation())) {
			Tasks.getSlayer().useRing("cave");
		} else {
			ctx.pathing.walkPath(path);
		}

	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId())
				&& ctx.pathing.distanceTo(path[path.length - 1]) < 5;
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Kalphite Lair", "Kalphite Cave" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

	WorldPoint[] path = { new WorldPoint(3296, 9500, 0), new WorldPoint(3292, 9500, 0), new WorldPoint(3288, 9500, 0),
			new WorldPoint(3285, 9499, 0), new WorldPoint(3282, 9499, 0), new WorldPoint(3280, 9496, 0),
			new WorldPoint(3279, 9492, 0), new WorldPoint(3279, 9489, 0) };

}

'''
'''--- aioslayer/data/tasks/Kurask.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.filters.SimplePrayers.Prayers;

public class Kurask implements MonsterTask {

	@Override
	public String getName() {
		// TODO Auto-generated method stub
		return "Kurask";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Leaf-bladed sword", "Leaf-bladed battleaxe", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.KURASK, NpcID.KURASK_410, NpcID.KURASK_411 };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("fremm");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		boolean equipped = Tasks.getInventory().isWearing(EquipmentSlot.WEAPON, "Leaf-bladed");
		;
		if (!equipped && Tasks.getInventory().contains("Leaf-bladed")) Tasks.getInventory().equip("Leaf-bladed");
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

	@Override
	public String[] areas() {
		return new String[] { "Fremennik Slayer Cave" };
	}
}

'''
'''--- aioslayer/data/tasks/Nechryael.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class Nechryael implements MonsterTask {

	@Override
	public String getName() {
		return "Nechryael";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.NECHRYAEL, NpcID.GREATER_NECHRYAEL };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("tower");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Slayer Tower (basement)", "Slayer Tower", "Catacombs of Kourend" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

}

'''
'''--- aioslayer/data/tasks/SmokeDevil.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;

public class SmokeDevil implements MonsterTask {

	@Override
	public String getName() {
		return "Smoke devils";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Occult necklace", "Dragon chainbody", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.SMOKE_DEVIL, NpcID.SMOKE_DEVIL_6639, NpcID.SMOKE_DEVIL_8482, NpcID.SMOKE_DEVIL_8483 };
	}

	@Override
	public void travel() {
		SimpleObject cave = ClientContext.instance().objects.populate().filter("Smoky cave").next();
		if (cave != null) {
			if (cave.validateInteractable()) cave.click("Enter");
		} else {
			Tasks.getSlayer().useRing("wars");
		}
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Smoke Devil Dungeon" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MISSILES;
	}

}

'''
'''--- aioslayer/data/tasks/SteelDragons.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import api.tasks.Supplies.PotionType;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.filters.SimplePrayers.Prayers;

public class SteelDragons implements MonsterTask {

	@Override
	public String getName() {
		return "Steel dragons";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Coins", "Draconic visage" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.STEEL_DRAGON_7255 };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("taverley");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) {
			if (!Tasks.getSupplies().antiFire.isRunning()) Tasks.getSupplies().drink(PotionType.ANTIFIRE);
			Tasks.getSlayer().fightNpc();
		}

	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		boolean equipped = Tasks.getInventory().isWearing(EquipmentSlot.SHIELD, "dragon shield", "dragonfire");
		if (!equipped && Tasks.getInventory().contains("dragon shield", "dragonfire"))
			Tasks.getInventory().equip("dragon shield", "dragonfire");
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

	@Override
	public String[] areas() {
		return new String[] { "Taverly" };
	}
}
'''
'''--- aioslayer/data/tasks/Suqah.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class Suqah implements MonsterTask {

	@Override
	public String getName() {
		return "Suqah";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.SUQAH };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing();
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Lunar Isle" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

}

'''
'''--- aioslayer/data/tasks/Trolls.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimplePrayers.Prayers;

public class Trolls implements MonsterTask {

	@Override
	public String getName() {
		return "Trolls";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.TROLL };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing();
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		// TODO Auto-generated method stub

	}

	public String[] areas() {
		return new String[] { "Troll" };
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

}

'''
'''--- aioslayer/data/tasks/Turoth.java ---
package aioslayer.data.tasks;

import aioslayer.data.Constants;
import aioslayer.data.MonsterTask;
import api.Tasks;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.filters.SimplePrayers.Prayers;

public class Turoth implements MonsterTask {

	@Override
	public String getName() {
		// TODO Auto-generated method stub
		return "Turoth";
	}

	@Override
	public String[] lootList() {
		return new String[] { "Slayer casket", "Leaf-bladed sword", "Coins" };
	}

	@Override
	public int[] getId() {
		return new int[] { NpcID.TUROTH_427, NpcID.TUROTH_428, NpcID.TUROTH_429, NpcID.TUROTH_430 };
	}

	@Override
	public void travel() {
		Tasks.getSlayer().useRing("fremm");
	}

	@Override
	public void attack() {
		if (!Tasks.getLoot().loot(lootList())) Tasks.getSlayer().fightNpc();
	}

	@Override
	public boolean atLocation() {
		return Constants.TASK != null && !Tasks.getCombat().isMonsterGoneForAWhile(getId());
	}

	@Override
	public void equipGear() {
		boolean equipped = Tasks.getInventory().isWearing(EquipmentSlot.WEAPON, "Leaf-bladed");
		;
		if (!equipped && Tasks.getInventory().contains("Leaf-bladed")) Tasks.getInventory().equip("Leaf-bladed");
	}

	@Override
	public Prayers getProtection() {
		return Prayers.PROTECT_FROM_MELEE;
	}

	@Override
	public String[] areas() {
		return new String[] { "Fremennik Slayer Cave" };
	}

}

'''
'''--- api/EventDispatcher.java ---
package api;

import java.util.ArrayList;
import java.util.EventListener;
import java.util.EventObject;
import java.util.List;

import api.listeners.ConfigChangeEvent;
import api.listeners.ConfigChangeListener;

public class EventDispatcher {
	private final List<EventListener> listeners;
	private final Object syncLock = new Object();
	private volatile boolean running;

	public EventDispatcher() {
		this.listeners = new ArrayList<EventListener>();
		this.running = true;
	}

	public void addListener(EventListener listener) {
		synchronized (syncLock) {
			listeners.add(listener);
		}
	}

	public void removeListener(EventListener listener) {
		synchronized (syncLock) {
			listeners.remove(listener);
		}
	}

	public EventDispatcher clearListeners() {
		synchronized (syncLock) {
			listeners.clear();
		}
		return this;
	}

	public void fireEvent(EventObject event) {
		synchronized (syncLock) {
			for (EventListener listener : listeners) {
				if (listener instanceof ConfigChangeListener) {
					((ConfigChangeListener) listener).onChange((ConfigChangeEvent) event);
				}
			}
		}
	}

	public boolean isRunning() {
		return running;
	}

	public EventDispatcher setRunning(boolean running) {
		this.running = running;
		return this;
	}

}
'''
'''--- api/Locations.java ---
package api;

import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

public class Locations {

	public final static WorldArea EDGEVILLE_AREA = new WorldArea(new WorldPoint(3074, 3515, 0), new WorldPoint(3105, 3480, 0));
	public final static WorldArea EDGEVILLE_BANK = new WorldArea(new WorldPoint(3098, 3487, 0), new WorldPoint(3090, 3499, 0));

	public final static WorldArea BARROWS_HILLS = new WorldArea(
			new WorldPoint[] { new WorldPoint(3565, 3314, 0), new WorldPoint(3543, 3299, 0), new WorldPoint(3547, 3270, 0),
					new WorldPoint(3566, 3266, 0), new WorldPoint(3584, 3275, 0), new WorldPoint(3583, 3306, 0) });

	public final static WorldArea BURTHORPE_AREA = new WorldArea(new WorldPoint(2892, 3557, 0), new WorldPoint(2934, 3529, 0));;

	public final static WorldArea BARROWS_FINAL_SARCO = new WorldArea(new WorldPoint(3547, 9700, 0),
			new WorldPoint(3558, 9690, 0));
	public static final WorldArea BANDOS_AREA = new WorldArea(new WorldPoint(2860, 5374, 2), new WorldPoint(2878, 5349, 2));;

	public final static WorldArea VORKATH_START_AREA = new WorldArea(new WorldPoint(2270, 4054, 0),
			new WorldPoint(2276, 4035, 0));

}

'''
'''--- api/MenuActions.java ---
package api;

import java.lang.reflect.Method;
import java.util.stream.IntStream;

import net.runelite.api.MenuAction;
import net.runelite.api.VarClientStr;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.MenuOptionClicked;
import simple.hooks.wrappers.SimpleGroundItem;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;

public class MenuActions {

	private static Class<?> _class;
	private static Method action;
	private ClientContext ctx;

	private MenuOptionClicked builder;

	public MenuActions(ClientContext ctx) {
		this.ctx = ctx;
	}

	public boolean invoke() {
		if (builder == null) return false;
		return invoke(builder);
	}

	public MenuActions setAction(int arg0) {
		this.builder.setActionParam(arg0);
		return this;
	}

	public MenuActions setMenuAction(MenuAction arg0) {
		this.builder.setMenuAction(arg0);
		return this;
	}

	public MenuActions setMenuAction(int arg0) {
		this.builder.setMenuAction(MenuAction.of(arg0));
		return this;
	}

	public MenuActions setId(int arg0) {
		this.builder.setId(arg0);
		return this;
	}

	public MenuActions setWidget(int arg0) {
		this.builder.setWidgetId(arg0);
		return this;
	}

	public static boolean invoke(String option, String target, int action, int menuAction, int id, int widgetId) {
		MenuOptionClicked menu = new MenuOptionClicked();
		menu.setActionParam(action);
		menu.setMenuOption(option);
		menu.setMenuTarget(target);
		menu.setMenuAction(MenuAction.of(menuAction));
		menu.setId(id);
		menu.setWidgetId(widgetId);
		return invoke(menu);
	}

	public static boolean invoke(MenuOptionClicked option) {
		try {
			if (_class == null) _class = Class.forName("client");
			if (action == null) {
				action = _class.getDeclaredMethod("a", int.class, int.class, int.class, int.class, java.lang.String.class,
						java.lang.String.class, int.class, int.class, int.class);
			}

			if (option == null) return false;
			action.invoke(_class.newInstance(), option.getActionParam(), option.getWidgetId(), option.getMenuAction().getId(),
					option.getId(), option.getMenuOption(), option.getMenuTarget(), -1, -1, (byte) 89);
			return true;
		} catch (Exception e1) {
			System.out.println(option);
			e1.printStackTrace();
		}
		return false;
	}

	public boolean clickDialogue(int action) {
		return invoke("", "", action, MenuAction.WIDGET_TYPE_6.getId(), 0, 14352385);
	}

	public boolean clickInterface(int action) {
		return invoke("", "", action, MenuAction.WIDGET_TYPE_6.getId(), 0, 12255235);
	}

	public boolean withdraw(SimpleItem item, String action) {
		if (item == null) return false;
		ClientContext ctx = ClientContext.instance();
		int length = ctx.bank.populate().population();
		SimpleItem[] items = ctx.bank.toStream().toArray(SimpleItem[]::new);
		int actionIndex = IntStream.range(0, length).filter(val -> {
			return items[val] != null && items[val].getName().equalsIgnoreCase(item.getName());
		}).findFirst().orElse(-1);

		if (actionIndex == -1) return false;
		int option = 1;
		switch (action) {
			case "1":
				option = 2;
				break;
			case "5":
				option = 3;
				break;
			case "10":
				option = 4;
				break;
			case "all":
				option = 7;
				break;
			default:
				option = 5;
				int amt = Integer.parseInt(action);
				if (ctx.bank.withdrawXAmount() != amt) {
					MenuActions.invoke("", "", -1, MenuAction.CC_OP.getId(), 2, 786465);
					ctx.onCondition(() -> ctx.dialogue.pendingInput());
					ctx.getClient().setVar(VarClientStr.INPUT_TEXT, amt + "");
					ctx.keyboard.sendKeys("", true);
					ctx.onCondition(() -> ctx.bank.withdrawXAmount() == amt);
				}
				break;
		}
		return invoke("", "", actionIndex, MenuAction.CC_OP.getId(), option, 786444);
	}

	public MenuActions get(SimpleItem item, String action) {
		if (item == null) return null;
		MenuAction option = MenuAction.ITEM_FIRST_OPTION;
		switch (action.toLowerCase()) {
			case "wield":
			case "wear":
				option = MenuAction.ITEM_SECOND_OPTION;
				break;
			case "rub":
				option = MenuAction.ITEM_THIRD_OPTION;
				break;
			case "check":
			case "empty":
				option = MenuAction.ITEM_FOURTH_OPTION;
				break;
			case "drop":
				option = MenuAction.ITEM_DROP;
				break;
			case "examine":
				option = MenuAction.EXAMINE_ITEM;
				break;
			case "cancel":
				option = MenuAction.CANCEL;
				break;
			case "use":
				option = MenuAction.ITEM_USE;
				break;
			case "use with":
				option = MenuAction.ITEM_USE_ON_WIDGET;
				break;
		}

		int index = item.getInventoryIndex();
		builder = new MenuOptionClicked();
		builder.setActionParam(index);
		builder.setMenuOption("");
		builder.setMenuTarget("");
		builder.setMenuAction(option);
		builder.setId(item.getId());
		builder.setWidgetId(9764864);
		return this;
	}

	public MenuActions get(SimpleNpc npc, String str) {
		if (npc == null) return null;

		MenuAction option = MenuAction.NPC_FIRST_OPTION;
		String[] actions = npc.getActions();

		int actionIndex = IntStream.range(0, actions.length).filter(val -> {
			String action = actions[val];
			return action != null && action.toLowerCase().contains(str.toLowerCase());
		}).findFirst().orElse(-1);

		if (actionIndex == -1) {
			System.out.println("Action index: " + actionIndex);
			return null;
		}

		switch (actionIndex) {
			case 1:
				option = MenuAction.NPC_SECOND_OPTION;
				break;
			case 2:
				option = MenuAction.NPC_THIRD_OPTION;
				break;
			case 3:
				option = MenuAction.NPC_FOURTH_OPTION;
				break;
			case 4:
				option = MenuAction.NPC_FIFTH_OPTION;
				break;
			case 5:
				option = MenuAction.EXAMINE_NPC;
				break;
		}

		int index = npc.getNpc().getIndex();

		builder = new MenuOptionClicked();
		builder.setActionParam(0);
		builder.setMenuOption("");
		builder.setMenuTarget("");
		builder.setMenuAction(option);
		builder.setId(index);
		builder.setWidgetId(0);
		return this;
	}

	public MenuActions get(SimpleObject object, String str) {
		if (object == null) return null;
		LocalPoint loc = object.getTileObject().getLocalLocation();
		MenuAction option = MenuAction.GAME_OBJECT_FIRST_OPTION;
		String[] actions = object.getActions();

		int actionIndex = IntStream.range(0, actions.length).filter(val -> {
			String action = actions[val];
			return action != null && action.toLowerCase().contains(str.toLowerCase());
		}).findFirst().orElse(-1);

		if (actionIndex == -1) return null;

		switch (actionIndex) {
			case 0:
				option = MenuAction.GAME_OBJECT_FIRST_OPTION;
				break;
			case 1:
				option = MenuAction.GAME_OBJECT_SECOND_OPTION;
				break;
			case 2:
				option = MenuAction.GAME_OBJECT_THIRD_OPTION;
				break;
			case 3:
				option = MenuAction.GAME_OBJECT_FOURTH_OPTION;
				break;
			case 4:
				option = MenuAction.GAME_OBJECT_FIFTH_OPTION;
				break;
		}

		builder = new MenuOptionClicked();
		builder.setActionParam(loc.getSceneX());
		builder.setMenuOption("");
		builder.setMenuTarget("");
		builder.setMenuAction(option);
		builder.setId(object.getId());
		builder.setWidgetId(loc.getSceneY());

		return this;
	}

	public MenuActions itemOnNPC(SimpleItem item, SimpleNpc npc) {
		if (item == null || npc == null) return null;
		if (ClientContext.instance().inventory.itemSelectionState() == 0) get(item, "Use").invoke();

		builder = new MenuOptionClicked();
		builder.setActionParam(0);
		builder.setMenuOption("");
		builder.setMenuTarget("");
		builder.setMenuAction(MenuAction.ITEM_USE_ON_NPC);
		builder.setId(npc.getNpc().getIndex());
		builder.setWidgetId(0);
		return this;
	}

	public MenuActions itemOnObject(SimpleItem item, SimpleObject object) {
		if (item == null || object == null) return null;
		if (ClientContext.instance().inventory.itemSelectionState() == 0) get(item, "Use").invoke();
		LocalPoint loc = object.getTileObject().getLocalLocation();

		builder = new MenuOptionClicked();
		builder.setActionParam(loc.getSceneX());
		builder.setMenuOption("");
		builder.setMenuTarget("");
		builder.setMenuAction(MenuAction.ITEM_USE_ON_GAME_OBJECT);
		builder.setId(object.getId());
		builder.setWidgetId(loc.getSceneY());
		return this;
	}

	public MenuActions get(SimpleGroundItem item, String action) {
		if (item == null) return null;
		MenuAction option = MenuAction.GROUND_ITEM_THIRD_OPTION;
		LocalPoint loc = item.getTile().getLocalLocation();

		switch (action.toLowerCase()) {
			case "examine":
				option = MenuAction.EXAMINE_ITEM_GROUND;
				break;
		}

		builder = new MenuOptionClicked();
		builder.setActionParam(loc.getSceneX());
		builder.setMenuOption("");
		builder.setMenuTarget("");
		builder.setMenuAction(option);
		builder.setId(item.getId());
		builder.setWidgetId(loc.getSceneY());
		return this;
	}

}

'''
'''--- api/Tasks.java ---
package api;

import api.tasks.AntiBan;
import api.tasks.Banking;
import api.tasks.Combat;
import api.tasks.Inventory;
import api.tasks.Looting;
import api.tasks.POHBanking;
import api.tasks.Skill;
import api.tasks.Slayer;
import api.tasks.Supplies;
import api.tasks.Token;
import lombok.Getter;
import simple.hooks.simplebot.teleporter.Teleporter;
import simple.robot.api.ClientContext;

public class Tasks {
	@Getter
	private static POHBanking pohbanking;
	@Getter
	private static Banking banking;
	@Getter
	private static Skill skill;
	@Getter
	private static Inventory inventory;
	@Getter
	private static Supplies supplies;
	@Getter
	private static Combat combat;
	@Getter
	private static Looting loot;
	@Getter
	private static Token token;
	@Getter
	private static Slayer slayer;
	@Getter
	private static AntiBan antiban;
	@Getter
	private static Teleporter teleporter;
	@Getter
	private static MenuActions menuAction;

	public static void init(ClientContext ctx) {
		Variables.reset();
		pohbanking = new POHBanking(ctx);
		banking = new Banking(ctx);
		skill = new Skill(ctx);
		inventory = new Inventory(ctx);
		supplies = new Supplies(ctx);
		combat = new Combat(ctx);
		loot = new Looting(ctx);
		token = new Token(ctx);
		antiban = new AntiBan(ctx);
		slayer = new Slayer(ctx);
		teleporter = new Teleporter(ctx);
		menuAction = new MenuActions(ctx);
	}

}

'''
'''--- api/Variables.java ---
package api;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

import api.utils.Timer;
import simple.hooks.filters.SimplePrayers.Prayers;

public class Variables {
	public static Timer START_TIME;
	public static boolean STARTED, STOP, PAUSED;
	public static String STATUS, LAST_MESSAGE;

	public static long COUNT;

	public static boolean FORCE_BANK, USE_PRAYER;
	public static CopyOnWriteArrayList<Prayers> ACTIVE_PRAYERS;
	public static List<String> LOOTABLES;

	public static boolean USE_PACKETS = true;
	public static EventDispatcher DISPATCHER;

	public static void reset() {
		ACTIVE_PRAYERS = new CopyOnWriteArrayList<Prayers>();
		LOOTABLES = new ArrayList<String>();
		STARTED = STOP = PAUSED = false;
		FORCE_BANK = USE_PRAYER = false;
		COUNT = 0;
		START_TIME = new Timer();
		STATUS = "Booting up";
		LAST_MESSAGE = "";
		DISPATCHER = new EventDispatcher();
	}
}

'''
'''--- api/listeners/ConfigChangeEvent.java ---
package api.listeners;

import java.util.EventObject;

import api.panel.Config;
import lombok.Getter;

@SuppressWarnings("serial")
public class ConfigChangeEvent extends EventObject {

	public ConfigChangeEvent(Config newConfig, Config oldConfig) {
		super(newConfig);
		this.newConfig = newConfig;
		this.oldConfig = oldConfig;
	}

	@Getter
	public Config newConfig;
	@Getter
	public Config oldConfig;
}

'''
'''--- api/listeners/ConfigChangeListener.java ---
package api.listeners;

import java.util.EventListener;

public interface ConfigChangeListener extends EventListener {
	void onChange(ConfigChangeEvent event);
}

'''
'''--- api/panel/Config.java ---
package api.panel;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import api.panel.options.Range;
import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.util.ColorUtil;

@Getter
@RequiredArgsConstructor
public class Config {

	public static List<Tabs> TABS = new ArrayList<>();

	public static List<Config> CONFIGURATION = new ArrayList<>();

	@NonNull
	private int section;
	@NonNull
	private Object type;
	@NonNull
	@Setter
	private Object value;
	@NonNull
	private String text, tooltip, keyName;

	private Range range;
	private boolean changeable = true;
	private int cached = -1;

	public Config(int section, Object type, Object defaultValue, String text, String tooltip, String keyName, Range range) {
		this.section = section;
		this.type = type;
		this.keyName = keyName;
		this.text = text;
		this.value = defaultValue;
		this.tooltip = tooltip;
		this.range = range;
	}

	public Config(int section, Object type, Object defaultValue, String text, String tooltip, String keyName,
			boolean changeable) {
		this.section = section;
		this.type = type;
		this.keyName = keyName;
		this.text = text;
		this.value = defaultValue;
		this.tooltip = tooltip;
		this.changeable = changeable;
	}

	public Config(int section, Object type, Object defaultValue, String text, String tooltip, String keyName, int cached) {
		this.section = section;
		this.type = type;
		this.keyName = keyName;
		this.text = text;
		this.value = defaultValue;
		this.tooltip = tooltip;
		this.cached = cached;
	}

	public static void clear() {
		CONFIGURATION.clear();
		TABS.clear();
	}

	public static Config getItem(String keyName) {
		return Config.CONFIGURATION.stream().filter(val -> val.getKeyName().equals(keyName)).findFirst().orElse(null);
	}

	public static <T> T getValue(String keyName) {
		Config value = getItem(keyName);
		try {
			return (T) stringToObject(value.getValue().toString(), (Class<?>) value.getType());
		} catch (Exception e) {
			System.out.println(e);
		}
		return null;
	}

	public static Object stringToObject(String str, Class<?> type) {
		if (type == boolean.class || type == Boolean.class) { return Boolean.parseBoolean(str); }
		if (type == int.class) { return Integer.parseInt(str); }
		if (type == Color.class) { return ColorUtil.fromString(str); }
		if (type.isEnum()) { return Enum.valueOf((Class<? extends Enum>) type, str); }
		if (type == Instant.class) { return Instant.parse(str); }
		if (type == WorldPoint.class) {
			String[] splitStr = str.split(":");
			int x = Integer.parseInt(splitStr[0]);
			int y = Integer.parseInt(splitStr[1]);
			int plane = Integer.parseInt(splitStr[2]);
			return new WorldPoint(x, y, plane);
		}
		return str;
	}

	public static String objectToString(Object object) {
		if (object instanceof Color) { return String.valueOf(((Color) object).getRGB()); }
		if (object instanceof Enum) { return ((Enum) object).name(); }
		if (object instanceof Dimension) {
			Dimension d = (Dimension) object;
			return d.width + "x" + d.height;
		}
		if (object instanceof Point) {
			Point p = (Point) object;
			return p.x + ":" + p.y;
		}
		if (object instanceof Rectangle) {
			Rectangle r = (Rectangle) object;
			return r.x + ":" + r.y + ":" + r.width + ":" + r.height;
		}
		if (object instanceof Instant) { return ((Instant) object).toString(); }
		if (object instanceof WorldPoint) {
			WorldPoint wp = (WorldPoint) object;
			return wp.getX() + ":" + wp.getY() + ":" + wp.getPlane();
		}
		if (object instanceof Duration) { return Long.toString(((Duration) object).toMillis()); }
		if (object instanceof byte[]) { return Base64.getUrlEncoder().encodeToString((byte[]) object); }
		return object == null ? null : object.toString();
	}

	public static boolean getB(String val) {
		return Config.getValue(val);
	}

	public static int getI(String val) {
		return Config.getValue(val);
	}

	public static String getS(String val) {
		return Config.getValue(val);
	}

	@Getter
	@Setter
	public static boolean configChanged;

	public static void save(String string) throws IOException {
		File file = new File(string +".json");
		if (!file.exists()) file.createNewFile();

		Map<String, Object> map = new HashMap<String, Object>();
		CONFIGURATION.forEach(val -> {
			map.put(val.getKeyName(), val.getValue());
		});

		try (Writer writer = new FileWriter(file)) {
		    Gson gson = new GsonBuilder().create();
		    gson.toJson(map, writer);
		    writer.close();
		}

	}

	public static void load(String string) throws IOException {
		File file = new File(string +".json");
		if (!file.exists()) {
			save(string);
			return;
		}
		BufferedReader reader = new BufferedReader(new FileReader(file));
		Map<String, Object> map = new Gson().fromJson(reader, HashMap.class);
		for (Entry<String, Object> config : map.entrySet()) {
			Config conf = Config.getItem(config.getKey());
			if (conf != null) conf.setValue(config.getValue());
		}
	}
}

'''
'''--- api/panel/Panel.java ---
package api.panel;

import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.ItemEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Arrays;
import java.util.stream.Stream;

import javax.imageio.ImageIO;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JFormattedTextField;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSpinner;
import javax.swing.JTextArea;
import javax.swing.SpinnerModel;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingUtilities;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import javax.swing.text.JTextComponent;

import com.google.common.base.Strings;
import com.google.common.primitives.Ints;

import api.Variables;
import api.listeners.ConfigChangeEvent;
import api.panel.options.Range;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.ComboBoxListRenderer;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;
import net.runelite.client.util.Text;
import simple.robot.api.ClientContext;
import simple.robot.utils.ScriptUtils;

public class Panel extends PluginPanel {

	private static ImageIcon SECTION_EXPAND_ICON;
	private static ImageIcon SECTION_EXPAND_ICON_HOVER;
	private static ImageIcon SECTION_RETRACT_ICON;
	private static ImageIcon SECTION_RETRACT_ICON_HOVER;

	private static final int SPINNER_FIELD_WIDTH = 6;

	static {
		try {
			BufferedImage sectionRetractIcon = ImageIO
					.read(Panel.class.getClassLoader().getResource("resources/arrow_right.png"));
			sectionRetractIcon = ImageUtil.luminanceOffset(sectionRetractIcon, -121);
			SECTION_EXPAND_ICON = new ImageIcon(sectionRetractIcon);
			SECTION_EXPAND_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(sectionRetractIcon, -100));
			final BufferedImage sectionExpandIcon = ImageUtil.rotateImage(sectionRetractIcon, Math.PI / 2);
			SECTION_RETRACT_ICON = new ImageIcon(sectionExpandIcon);
			SECTION_RETRACT_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(sectionExpandIcon, -100));
		} catch (Exception e) {
			ClientContext.instance().log(e.getMessage());
		}
	}

	public Panel() {
		add(getHeader());

		Config.TABS.forEach(tab -> {
			JPanel t = buildTab(tab.getTitle(), tab.getDescription());
			buildConfig(tab.getIndex(), t);
			add(t);
			add(Box.createRigidArea(new Dimension(0, 10)));
		});
		add(getButton());
	}

	private JFrame frame;

	public JFrame init(String title, Panel panel) throws IOException {
		frame = new JFrame();
		BufferedImage icon = ImageIO.read(getClass().getClassLoader().getResource("resources/KS.png"));
		JScrollPane scroller = new JScrollPane(panel);
		scroller.setViewportView(panel);
		scriptName.setText(title);
		frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		frame.setTitle("KS GUI");
		frame.setIconImage(icon);
		frame.setResizable(false);
		frame.setMinimumSize(new Dimension(275, 0));
		frame.add(scroller);
		frame.pack();
		frame.repaint();
		frame.setVisible(true);

		frame.addWindowListener(new WindowAdapter() {
			@Override
			public void windowClosing(WindowEvent windowEvent) {
				if (JOptionPane.showConfirmDialog(frame, "Are you sure you want to close this window?", "Close Window?",
						JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION) {
					ClientContext.instance().stopScript();
				}
			}
		});
		return frame;
	}

	private JLabel scriptName, status, runTime, count;

	private JPanel getHeader() {
		JPanel pan = new JPanel();
		pan.setLayout(new GridLayout(0, 1));
		pan.setMinimumSize(new Dimension(PANEL_WIDTH, 25));

		scriptName = new JLabel("", 0);
		scriptName.setForeground(new Color(199, 201, 201));
		pan.add(scriptName);

		status = new JLabel("Booting up...", 0);
		status.setForeground(new Color(199, 201, 201));
		pan.add(status);

		runTime = new JLabel("00:00:00", 0);
		runTime.setForeground(new Color(199, 201, 201));
		pan.add(runTime);

		count = new JLabel("", 0);
		count.setForeground(new Color(199, 201, 201));
		pan.add(count);
		pan.setBorder(
				new CompoundBorder(new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR), new EmptyBorder(0, 0, 3, 1)));
		return pan;
	}

	public void update(String text) {
		status.setText("<html>" + text + "</html>");
		runTime.setText(Variables.START_TIME.toElapsedString());
		if (Variables.COUNT > 0) count.setText(String.format("Count: %s (%s p/hr)", Variables.COUNT, ScriptUtils
				.getValuePerHour(Variables.START_TIME.getStart(), Variables.START_TIME.getElapsed(), (int) Variables.COUNT)));
	}

	private void toggleSection(JButton button, JPanel contents) {
		boolean newState = !contents.isVisible();
		contents.setVisible(newState);
		button.setIcon(newState ? SECTION_RETRACT_ICON : SECTION_EXPAND_ICON);
		button.setRolloverIcon(newState ? SECTION_RETRACT_ICON_HOVER : SECTION_EXPAND_ICON_HOVER);
		button.setToolTipText(newState ? "Retract" : "Expand");
		SwingUtilities.invokeLater(contents::revalidate);
	}

	private JPanel buildTab(String name, String desc) {
		final boolean isOpen = name.equals("Script Config");
		final JPanel section = new JPanel();
		section.setLayout(new BoxLayout(section, BoxLayout.Y_AXIS));
		section.setMinimumSize(new Dimension(PANEL_WIDTH, 0));

		final JPanel sectionHeader = new JPanel();
		sectionHeader.setBorder(
				new CompoundBorder(new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR), new EmptyBorder(0, 0, 3, 1)));
		section.add(sectionHeader, BorderLayout.NORTH);

		final JButton sectionToggle = new JButton(isOpen ? SECTION_RETRACT_ICON : SECTION_EXPAND_ICON);
		sectionToggle.setRolloverIcon(isOpen ? SECTION_RETRACT_ICON_HOVER : SECTION_EXPAND_ICON_HOVER);
		sectionToggle.setBorder(new EmptyBorder(0, 0, 0, 5));
		sectionToggle.setToolTipText("Expand");
		SwingUtil.removeButtonDecorations(sectionToggle);
		sectionHeader.add(sectionToggle, BorderLayout.WEST);

		final JLabel sectionName = new JLabel(name);
		sectionName.setForeground(ColorScheme.BRAND_ORANGE);
		sectionName.setFont(FontManager.getRunescapeBoldFont());
		sectionName.setAlignmentX(JLabel.WEST);
		sectionName.setToolTipText("<html>" + name + ":<br>" + desc + "</html>");
		sectionHeader.add(sectionName, BorderLayout.CENTER);

		final JPanel sectionContents = new JPanel();
		sectionContents.setLayout(new DynamicGridLayout(0, 1, 0, 5));
		sectionContents.setMinimumSize(new Dimension(PANEL_WIDTH, 0));
		sectionContents.setVisible(isOpen);
		section.add(sectionContents, BorderLayout.SOUTH);

		final MouseAdapter adapter = new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				toggleSection(sectionToggle, sectionContents);
				repaint();
				frame.pack();
			}
		};
		sectionToggle.addMouseListener(adapter);
		sectionName.addMouseListener(adapter);
		sectionHeader.addMouseListener(adapter);

		return section;
	}

	private JPanel buildConfig(int i, JPanel section) {
		Config.CONFIGURATION.forEach(config -> {
			if (i != config.getSection()) return;
			JPanel item = new JPanel();
			item.setLayout(new BorderLayout());
			item.setMinimumSize(new Dimension(PANEL_WIDTH, 0));

			String name = config.getText();
			if (config.getType() != Button.class) {
				JLabel configEntryName = new JLabel(name);
				configEntryName.setForeground(Color.WHITE);
				configEntryName.setToolTipText("<html>" + name + ":<br>" + config.getTooltip() + "</html>");
				item.add(configEntryName, BorderLayout.CENTER);
			}

			if (config.getType() == boolean.class) {
				JCheckBox checkbox = new JCheckBox();
				checkbox.setBackground(ColorScheme.LIGHT_GRAY_COLOR);
				checkbox.setSelected((boolean) config.getValue());
				checkbox.addActionListener(ae -> changeConfiguration(checkbox, config));
				item.add(checkbox, BorderLayout.EAST);
			}

			if (config.getType() == String.class) {
				JTextComponent textField;
				final JTextArea textArea = new JTextArea();
				textArea.setLineWrap(true);
				textArea.setWrapStyleWord(true);
				textField = textArea;
				textField.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
				textField.setText("");

				textField.addFocusListener(new FocusAdapter() {
					@Override
					public void focusLost(FocusEvent e) {
						changeConfiguration(textField, config);
					}
				});
				item.add(textField, BorderLayout.SOUTH);
			}

			if (config.getType() == Button.class) {
				final JButton button = new JButton(name);
				item.add(button, BorderLayout.SOUTH);
				button.addActionListener(ct -> onButtonClick(button, config));
			}

			if (config.getType() == int.class) {
				int value = (int) config.getValue();
				Range range = config.getRange();
				int min = 0, max = Integer.MAX_VALUE;
				if (range != null) {
					min = range.getMin();
					max = range.getMax();
				}
				value = Ints.constrainToRange(value, min, max);

				SpinnerModel model = new SpinnerNumberModel(value, min, max, 1);
				JSpinner spinner = new JSpinner(model);
				Component editor = spinner.getEditor();
				JFormattedTextField spinnerTextField = ((JSpinner.DefaultEditor) editor).getTextField();
				spinnerTextField.setColumns(SPINNER_FIELD_WIDTH);
				spinner.addChangeListener(ce -> changeConfiguration(spinner, config));
				item.add(spinner, BorderLayout.EAST);
			}

			if (config.getType() instanceof Object[]) {
				String[] words = Arrays.stream((String[])config.getType()).map(String::toString).toArray(String[]::new);

				Config val = Config.getItem("greater demons");
				String selected = Strings.isNullOrEmpty((String) val.getValue()) ? words[0] : (String) val.getValue();

				JComboBox box = new JComboBox(words);
				box.setPreferredSize(new Dimension(box.getPreferredSize().width, 25));
				box.setRenderer(new ComboBoxListRenderer());
				box.setForeground(Color.WHITE);
				box.setFocusable(false);
				box.setPrototypeDisplayValue("XXXXXXXXXXXXXXXXS");
				try {
					box.setSelectedItem(selected);
				} catch (IllegalArgumentException ex) {
					ClientContext.instance().log("invalid selected item", ex);
				}
				box.addItemListener(e -> {
					if (e.getStateChange() == ItemEvent.SELECTED) {
						changeConfiguration(box, config);
						box.setToolTipText(String.valueOf(box.getSelectedItem()));
					}
				});
				item.add(box, BorderLayout.EAST);

			} else if (((Class<? extends Enum>) config.getType()).isEnum()) {
				Class<? extends Enum> type = (Class<? extends Enum>) config.getType();
				JComboBox box = new JComboBox(type.getEnumConstants());
				box.setPreferredSize(new Dimension(box.getPreferredSize().width, 25));
				box.setRenderer(new ComboBoxListRenderer());
				box.setForeground(Color.WHITE);
				box.setFocusable(false);
				box.setPrototypeDisplayValue("XXXXXXXX");
				try {
					Config val = Config.getItem(config.getKeyName());
					Enum selectedItem = Enum.valueOf(type, (String) val.getValue());
					box.setSelectedItem(selectedItem);
					box.setToolTipText(Text.titleCase(selectedItem));
				} catch (IllegalArgumentException ex) {
					ClientContext.instance().log("invalid selected item", ex);
				}
				box.addItemListener(e -> {
					if (e.getStateChange() == ItemEvent.SELECTED) {
						changeConfiguration(box, config);
						box.setToolTipText(Text.titleCase((Enum) box.getSelectedItem()));
					}
				});
				item.add(box, BorderLayout.EAST);
			}

			JPanel p = (JPanel) section.getComponent(1);
			p.add(item);
		});
		return this;
	}

	private void onButtonClick(Object component, Config config) {
		if (config == null) return;

		final Config oldConfig = config;

		if (component instanceof JButton) {
			JButton button = (JButton) component;

			// int cached = config.getCached();
			// if (cached > -1) Variables.CACHED_BOOLEANS[cached] = true;

			if (config.getKeyName().equals("testHook")) {
				String url = Config.getValue("discordURL");
				if (Strings.isNullOrEmpty(url)) return;
			}
		}

		ClientContext.instance().log("Clicked " + config.getText() + " button");
		Variables.DISPATCHER.fireEvent(new ConfigChangeEvent(config, oldConfig));
	}

	private Object changeConfiguration(Object component, Config config) {
		if (config == null) return null;

		final Config oldConfig = config;

		if (component instanceof JCheckBox) {
			JCheckBox checkbox = (JCheckBox) component;
			if (Config.isConfigChanged() && !config.isChangeable()) {
				JOptionPane.showMessageDialog(frame, "This setting cannot be changed after run time");
				checkbox.setSelected(!checkbox.isSelected());
				return null;
			}

			config.setValue(checkbox.isSelected());
		} else if (component instanceof JSpinner) {
			JSpinner spinner = (JSpinner) component;
			config.setValue(spinner.getValue());
		} else if (component instanceof JTextComponent) {
			JTextComponent textField = (JTextComponent) component;
			config.setValue(textField.getText());
		} else if (component instanceof JComboBox) {
			JComboBox jComboBox = (JComboBox) component;
			if (jComboBox.getSelectedItem() instanceof String)
				config.setValue(jComboBox.getSelectedItem());
			else
			config.setValue(((Enum) jComboBox.getSelectedItem()).name());
		}
		ClientContext.instance().log("Changed " + config.getText() + " option");
		Variables.DISPATCHER.fireEvent(new ConfigChangeEvent(config, oldConfig));
		Config.setConfigChanged(true);
		return null;
	}

	public JPanel getButton() {
		JPanel panel = new JPanel();
		panel.setLayout(new BorderLayout());
		panel.setBorder(
				new CompoundBorder(new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR), new EmptyBorder(0, 0, 3, 1)));
		final JButton start = new JButton("Start");
		start.addActionListener((e) -> {
			if (!Variables.STARTED) {
				Variables.STARTED = true;
				Variables.PAUSED = false;
				start.setText("Pause");
			} else {
				Variables.PAUSED = !Variables.PAUSED;
				start.setText(Variables.PAUSED ? "Resume" : "Pause");
			}

		});
		panel.add(start, BorderLayout.SOUTH);
		return panel;
	}
}

'''
'''--- api/panel/Tabs.java ---
package api.panel;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class Tabs {

	private final int index;
	private final String title, description;

}

'''
'''--- api/panel/options/Range.java ---
package api.panel.options;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class Range {

	private int min, max;

}

'''
'''--- api/panel/options/WebhookMessage.java ---
package api.panel.options;

public class WebhookMessage {
	public String content;

	public String username;

	public String avatar_url;

	public boolean tts;

	public Object file;

	public Object[] embeds;

	public WebhookMessage(String username, String content) {
		this.content = content;
		this.username = username;
	}
}

'''
'''--- api/simple/KSGroundItem.java ---
package api.simple;

import api.Tasks;
import api.Variables;
import lombok.AllArgsConstructor;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.wrappers.SimpleGroundItem;
import simple.hooks.wrappers.SimpleLocalPlayer;

@AllArgsConstructor
public class KSGroundItem {

	public SimpleGroundItem object;

	public synchronized boolean click(String args0) {
		if (Variables.USE_PACKETS) return Tasks.getMenuAction().get(object, args0).invoke();
		return object.click(args0);
	}

	public boolean isNull() {
		return object == null;
	}

	public synchronized boolean validateInteractable() {
		if (Variables.USE_PACKETS) return true;
		return object.validateInteractable();
	}

	public int distanceTo(SimpleLocalPlayer local) {
		return object.distanceTo(local);
	}

	public WorldPoint getLocation() {
		return object.getLocation();
	}

	public String[] getActions() {
		return object.getActions();
	}

	public String getName() {
		return object.getName();
	}
}

'''
'''--- api/simple/KSItem.java ---
package api.simple;

import api.Tasks;
import api.Variables;
import lombok.AllArgsConstructor;
import simple.hooks.wrappers.SimpleItem;

@AllArgsConstructor
public class KSItem {

	public SimpleItem item;

	public synchronized boolean click(String args0) {
		if (Variables.USE_PACKETS) return Tasks.getMenuAction().get(item, args0).invoke();
		return item.click(args0);
	}

	public boolean isNull() {
		return item == null;
	}

	public String getName() {
		return item.getName();
	}

}

'''
'''--- api/simple/KSNPC.java ---
package api.simple;

import api.Tasks;
import api.Variables;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.queries.SimpleEntityQuery;
import simple.hooks.wrappers.SimpleLocalPlayer;
import simple.hooks.wrappers.SimpleNpc;
import simple.robot.api.ClientContext;

public class KSNPC {

	private ClientContext ctx;

	public SimpleNpc npc;

	public KSNPC(SimpleNpc npc) {
		this.npc = npc;
	}

	private boolean inCombat, isDead, inDistance, isAggressive;

	private int distance;

	private Object val;

	public KSNPC(Object val) {
		this.val = val;
		this.ctx = ClientContext.instance();

		inCombat = isAggressive = isDead = false;
		inDistance = true;

		distance = 15;
	}

	public KSNPC isAggressive(boolean val) {
		this.isAggressive = val;
		return this;
	}

	public KSNPC inCombat(boolean val) {
		this.inCombat = val;
		return this;
	}

	public KSNPC isDead(boolean val) {
		this.isDead = val;
		return this;
	}

	public KSNPC inDistance(int val) {
		this.distance = val;
		return this;
	}

	public SimpleNpc get() {
		return query().next();
	}

	public SimpleEntityQuery<SimpleNpc> query() {
		SimpleEntityQuery<SimpleNpc> query = ctx.npcs.populate();
		if (query.size() == 0) return query;

		if (val instanceof String) query = query.filter((String) val);
		else if (val instanceof Number) query = query.filter((int) val);
		else if (val instanceof String[]) query = query.filter((String) val);
		else if (val instanceof int[]) query = query.filter((int[]) val);

		if (inDistance) query = query.filterWithin(distance);

		if (isAggressive) query = query.filter(npc -> {
			if (npc.getInteracting() != null && npc.getInteracting().equals(ctx.players.getLocal().getPlayer())) return true;
			if (npc.getInteracting() != null && !npc.inCombat()) return true;
			return false;

		});
		query = query.filter(npc -> npc.inCombat() == inCombat && npc.isDead() == isDead);
		return query;
	}

	public synchronized boolean click(String arg0) {
		if (Variables.USE_PACKETS) return Tasks.getMenuAction().get(npc, arg0).invoke();
		return npc.click(arg0);
	}

	public synchronized boolean validateInteractable() {
		if (Variables.USE_PACKETS) return true;
		return npc.validateInteractable();
	}

	public boolean isNull() {
		return npc == null;
	}

	public int distanceTo(SimpleLocalPlayer local) {
		return npc.distanceTo(local);
	}

	public WorldPoint getLocation() {
		return npc.getLocation();
	}

}

'''
'''--- api/simple/KSObject.java ---
package api.simple;

import api.Tasks;
import api.Variables;
import lombok.AllArgsConstructor;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.wrappers.SimpleLocalPlayer;
import simple.hooks.wrappers.SimpleObject;

@AllArgsConstructor
public class KSObject {

	public SimpleObject object;

	public synchronized boolean click(String args0) {
		System.out.println(Variables.USE_PACKETS);
		if (Variables.USE_PACKETS) return Tasks.getMenuAction().get(object, args0).invoke();
		return args0 == null ? object.click(0) : object.click(args0);
	}

	public boolean isNull() {
		return object == null;
	}

	public synchronized boolean validateInteractable() {
		if (Variables.USE_PACKETS) return true;
		return object.validateInteractable();
	}

	public int distanceTo(SimpleLocalPlayer local) {
		return object.distanceTo(local);
	}

	public WorldPoint getLocation() {
		return object.getLocation();
	}

	public String[] getActions() {
		return object.getActions();
	}

	public String getName() {
		return object.getName();
	}
}

'''
'''--- api/tasks/AntiBan.java ---
package api.tasks;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import api.Locations;
import api.Tasks;
import api.Variables;
import net.runelite.api.Friend;
import net.runelite.api.GameState;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.wrappers.SimplePlayer;
import simple.robot.api.ClientContext;
import simple.robot.utils.ScriptUtils;

public class AntiBan {

	public List<String> STAFF_NAMES = Arrays.asList("david", "hope", "polar", "spooky", "chaflie", "corey", "klem",
			"professor oak", "adreas", "pegasus", "perfection", "raids", "setup", "trilobita", "kenzz", "spirit", "leaned",
			"paine", "h a r r y", "scape", "mamba", "supreme", "isleview", "kenzz", "andy", "fe chaflie", "zaros", "v12",
			"zachery", "vcx", "hc wizard", "immortal fox", "calabria", "listen", "niedermayer", "jake", "julia", "harsh", "hans");

	private ClientContext ctx;

	public AntiBan(ClientContext ctx) {
		this.ctx = ctx;
	}

	public boolean check() {
		if (!ctx.pathing.inArea(Locations.EDGEVILLE_AREA) && Tasks.getAntiban().staffNearby()) return true;
		if (!ctx.pathing.inArea(Locations.EDGEVILLE_BANK) && Tasks.getAntiban().staffUnder()) return true;
		return false;
	}

	public boolean staffNearby() {
		List<SimplePlayer> players = ctx.players.populate().toStream().filter(val -> {
			return STAFF_NAMES.contains(ScriptUtils.stripHtml(val.getName()).toLowerCase());
		}).collect(Collectors.toList());
		players.forEach(player -> ctx.log("[STAFF NEARBY]" + player.getName() + " : " + player.getLocation()));
		return players.size() > 0;
	}

	public boolean staffInChat() {
		List<Friend> players = Arrays.stream(ctx.getClient().getFriendContainer().getMembers())
				.filter(val -> STAFF_NAMES.contains(ScriptUtils.stripHtml(val.getName()).toLowerCase()))
				.collect(Collectors.toList());
		players.forEach(player -> ctx.log("[STAFF IN CHAT]" + player.getName()));
		return players.size() > 0;
	}

	public boolean staffUnder() {
		WorldPoint loc = ctx.players.getLocal().getLocation();
		List<SimplePlayer> players = ctx.players.populate().toStream().filter(val -> {
			return STAFF_NAMES.contains(ScriptUtils.stripHtml(val.getName()).toLowerCase()) && val.getLocation().equals(loc);
		}).collect(Collectors.toList());
		players.forEach(player -> ctx.log("[STAFF UNDER]" + player.getName() + " : " + player.getLocation()));
		return players.size() > 0;
	}

	public void panic() {
		if (!ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
			ctx.magic.castSpellOnce("Home Teleport");
		} else if (!ctx.players.getLocal().inCombat()) {
			while (ctx.getClient().getGameState() == GameState.LOGGED_IN) {
				ctx.sendLogout();
			}
		}
	}
}

'''
'''--- api/tasks/Banking.java ---
package api.tasks;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import api.Tasks;
import api.Variables;
import api.simple.KSObject;
import api.utils.Timer;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;

public class Banking {

	private ClientContext ctx;

	public Banking(ClientContext ctx) {
		this.ctx = ctx;
	}

	public SimpleObject getBank() {
		return ctx.objects.populate().filter(10355, 26707).nearest().next();
	}

	public boolean open() {
		if (ctx.bank.bankOpen()) return true;

		KSObject bank = new KSObject(getBank());
		if (bank.isNull()) return false;
		if (bank.distanceTo(ctx.players.getLocal()) > 5) {
			Variables.STATUS = "Walking to bank";
			ctx.pathing.step(bank.getLocation());
			ctx.onCondition(() -> ctx.pathing.inMotion(), 250);
			return false;
		}

		Variables.STATUS = "Opening bank";
		String action = bank.getName().contains("chest") ? "Use" : "Bank";

		if (bank.click(action)) ctx.sleepCondition(() -> ctx.bank.bankOpen());
		return false;
	}

	public boolean usePreset() {
		return usePreset(false);
	}

	public boolean usePreset(boolean slayer) {
		KSObject bank = new KSObject(getBank());
		if (bank.isNull()) return true;

		boolean slay = slayer && !Tasks.getInventory().contains("Slayer casket");
		boolean other = !slayer && (Tasks.getSupplies().hasFood() && Tasks.getSupplies().hasPrayer());

		if ((slay || other) && !Variables.FORCE_BANK) return true;
		if (ctx.pathing.distanceTo(bank.getLocation()) > 5) {
			Variables.STATUS = "Walking to bank";
			ctx.pathing.step(bank.getLocation());
			ctx.onCondition(() -> ctx.pathing.distanceTo(bank.getLocation()) < 4, 150);
			return false;
		}
		Variables.STATUS = "Getting last preset";
		if (ctx.inventory.itemSelectionState() == 1) ctx.inventory.populate().next().click(0);
		if (bank.click("Last-preset")) {
			ctx.onCondition(() -> Variables.LAST_MESSAGE.contains("preset"), 6000);
			Variables.FORCE_BANK = false;
		}
		return true;
	}

	public boolean isFull() {
		return ctx.skills.level(Skills.HITPOINTS) == ctx.skills.realLevel(Skills.HITPOINTS)
				&& ctx.skills.level(Skills.PRAYER) == ctx.skills.realLevel(Skills.PRAYER);
	}

	public boolean heal() {
		if (isFull()) return true;

		KSObject box = new KSObject(ctx.objects.populate().filter(60003).nearest().next());
		if (box.isNull()) return false;
		if (box.distanceTo(ctx.players.getLocal()) > 5) {
			Variables.STATUS = "Walking to heal chest";
			ctx.pathing.step(box.getLocation());
			ctx.sleep(450, 650);
			return false;
		}
		Variables.STATUS = "Refilling hitpoints";
		if (box.click("Heal")) ctx.onCondition(() -> !ctx.pathing.inMotion());
		return false;
	}

	public boolean withdrawItem(String name) {
		return withdrawItem(name, 1);
	}

	public boolean withdrawItem(String name, int amount) {
		if (open()) {
			SimpleItem item = Tasks.getBanking().getItem(name);
			if (item == null) {
				ctx.log("Unable to find: " + name);
				Variables.STOP = true;
				ctx.bank.closeBank();
				return false;
			}
			if (!Variables.USE_PACKETS) return ctx.bank.withdraw(name, amount);
			return Tasks.getMenuAction().withdraw(item, amount + "");
		}
		return false;
	}

	public boolean containsAll(int... itemId) {
		List<Integer> inv = ctx.bank.populate().toStream().map(item -> item.getId()).collect(Collectors.toList());
		return itemId.length == Arrays.stream(itemId).filter(inv::contains).count();
	}

	public boolean containsAll(String... itemName) {
		List<String> inv = ctx.bank.populate().toStream().map(item -> item.getName()).map(String::toLowerCase)
				.collect(Collectors.toList());
		return itemName.length == Arrays.stream(itemName).map(String::toLowerCase)
				.filter(val -> inv.stream().anyMatch(arr -> arr.contains(val))).count();
	}

	public boolean contains(String... itemName) {
		return !ctx.bank.populate().filter(p -> Tasks.getInventory().predicate(p, itemName)).isEmpty();
	}

	public SimpleItem getItem(String... itemName) {
		return ctx.bank.populate().filter(p -> Tasks.getInventory().predicate(p, itemName)).next();
	}

	private Timer altarTimer = new Timer(1);

	public void prayAtAltar(String name) {
		if (Tasks.getSkill().getPercentage(Skills.PRAYER) > 60 || altarTimer.isRunning()) return;
		KSObject altar = new KSObject(ctx.objects.populate().filter(name).next());
		if (altar.isNull()) return;
		if (altar.click("Pray")) {
			ctx.onCondition(() -> Tasks.getSkill().getPercentage(Skills.PRAYER) >= 95, 5000);
			altarTimer.setEndIn(600000);
		}
	}

}

'''
'''--- api/tasks/Combat.java ---
package api.tasks;

import java.util.Comparator;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Stream;

import api.MenuActions;
import api.Tasks;
import api.Variables;
import api.simple.KSNPC;
import api.tasks.Supplies.PotionType;
import api.utils.Timer;
import api.utils.Weapons;
import api.utils.Weapons.SPECIAL_WEAPONS;
import lombok.Getter;
import net.runelite.api.NpcID;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.queries.SimpleEntityQuery;
import simple.hooks.wrappers.SimpleGroundItem;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.api.ClientContext;

public class Combat {

	private ClientContext ctx;

	Predicate<SimpleNpc> GET_AGGRESSOR = npc -> !npc.isDead() && ctx.pathing.reachable(npc)
			&& ctx.pathing.distanceTo(npc.getLocation()) < 10
			&& (npc.getInteracting() == null || npc.getInteracting().equals(ctx.players.getLocal().getPlayer())
					|| (npc.getInteracting() != null && !npc.inCombat()));

	public Combat(ClientContext ctx) {
		this.ctx = ctx;
	}

	public SimpleNpc getNPC(String... npcName) {
		return ctx.npcs.populate().filter(npcName).filter(npc -> npc != null && !npc.isDead()).nearest().next();
	}

	public SimpleNpc getNPC(int... npcId) {
		return ctx.npcs.populate().filter(npcId).filter(npc -> npc != null && !npc.isDead()).nearest().next();
	}

	public SimpleNpc getNPC(boolean filter, String... npcName) {
		return ctx.npcs.populate().filter(npcName).filter(GET_AGGRESSOR).nearest().next();
	}

	public SimpleNpc getNPC(boolean filter, int... npcId) {
		SimpleEntityQuery<SimpleNpc> query = ctx.npcs.populate();
		if (filter) query = query.filter(GET_AGGRESSOR);

		return query.nearest().next();
	}

	public SimpleNpc getMultiNpc(int[] ids) {
		SimpleEntityQuery<SimpleNpc> npcs = ctx.npcs.populate().filter(ids).filter(n -> !n.isDead());

		if (ctx.combat.inMultiCombat()) {
			npcs = ctx.npcs.populate().filter(ids).filter(GET_AGGRESSOR);
			if (npcs.size() < 1) npcs = ctx.npcs.populate().filter(ids).filter(n -> n.getHealthRatio() == -1 && !n.isDead());
			if (npcs.size() < 1) npcs = ctx.npcs.populate().filter(ids).filter(n -> !n.isDead());
		}

		if (npcs.population() > 0) return npcs.nearest().next();

		return null;
	}

	public SimpleNpc getMultiNpc(String[] ids) {
		SimpleEntityQuery<SimpleNpc> npcs = ctx.npcs.populate().filter(ids).filter(n -> !n.isDead());

		if (ctx.combat.inMultiCombat()) {
			npcs = ctx.npcs.populate().filter(ids).filter(GET_AGGRESSOR);
			if (npcs.size() < 1) npcs = ctx.npcs.populate().filter(ids).filter(n -> n.getHealthRatio() == -1 && !n.isDead());
			if (npcs.size() < 1) npcs = ctx.npcs.populate().filter(ids).filter(n -> !n.isDead());
		}

		if (npcs.population() > 0) return npcs.nearest().next();

		return null;
	}

	public SimpleNpc getNPC(List<Integer> npcIds) {
		final int[] ids = npcIds.stream().mapToInt(Integer::intValue).toArray();
		return ctx.npcs.populate().filter(ids).filter(npc -> npc != null && !npc.isDead())
				.sort(Comparator.comparingInt(npc -> npcIds.indexOf(npc.getId()))).next();
	}

	public SimpleNpc getNPC(String name) {
		return ctx.npcs.populate().filter(name).filter(GET_AGGRESSOR).nearest().next();
	}

	public void attack(SimpleNpc npc) {
		if (npc == null) {
			Variables.STATUS = "NPC is null";
			return;
		}
		Variables.STATUS = "Attacking NPC";
		try {
			if (new KSNPC(npc).click("Attack")) ctx.onCondition(() -> ctx.players.getLocal().getInteracting() != null, 1000);

		} catch (Exception e) {
			Variables.STATUS = "Failing to attack";
		}
	}

	public void attack(String name) {
		SimpleNpc npc = getAggressiveNPC(name);
		if (npc == null) npc = getNPC(name);
		if (npc == null) return;
		attack(npc);
	}

	public boolean isNpcAggressive(int id) {
		return isNpcAggressive(getNPC(id));
	}

	public SimpleNpc getAggressiveNPC(int... id) {
		return ctx.npcs.populate().filter(id).filter(this::isNpcAggressive).nearest().next();
	}

	public SimpleNpc getAggressiveNPC(String... name) {
		return ctx.npcs.populate().filter(name).filter(this::isNpcAggressive).nearest().next();
	}

	public boolean isNpcAggressive(SimpleNpc npc) {
		return npc != null && npc.getInteracting() != null && npc.getInteracting().getName() != null
				&& npc.getInteracting().getName().contains(ctx.players.getLocal().getName());

	}

	public boolean isRare(SimpleGroundItem loot) {
		return loot.getName().contains("andos") || loot.getName().contains("aradomin") || loot.getName().contains("rmadyl");
	}

	public void checkPots() {
		if (Tasks.getSkill().getPercentage(Skills.HITPOINTS) < 50) Tasks.getSupplies().eat();
		if (Tasks.getSkill().getPercentage(Skills.PRAYER) < 40) Tasks.getSupplies().drink(PotionType.PRAYER);
		if (Tasks.getSkill().isPoisonedOrVenomed()) Tasks.getSupplies().drink(PotionType.ANTIPOISON);
		if (Tasks.getSkill().shouldBoost(Skills.RANGED)) Tasks.getSupplies().drink(PotionType.RANGED);
		if (Tasks.getSkill().shouldBoost(Skills.ATTACK)) Tasks.getSupplies().drink(PotionType.ATTACK);
		if (Tasks.getSkill().shouldBoost(Skills.STRENGTH)) Tasks.getSupplies().drink(PotionType.STRENGTH);
		if (Tasks.getSkill().shouldBoost(Skills.DEFENCE)) Tasks.getSupplies().drink(PotionType.DEFENCE);
		// else if (!Tasks.getSupplies().antiFire.isRunning())
		// Tasks.getSupplies().drink(PotionType.ANTIFIRE);

	}

	public void switchSpec() {
		SimpleItem weapon = Weapons.SPECIAL_WEAPON.item();
		if (weapon != null) {
			Variables.STATUS = "Equipping special attack weapon";
			if (Tasks.getMenuAction().get(weapon, "Wear").invoke()) ctx.onCondition(() -> Weapons.SPECIAL_WEAPON.itemEquiped());
		}
	}

	public void useSpecialAttack(SimpleNpc target) {
		if (Weapons.SPECIAL_WEAPON.equals(SPECIAL_WEAPONS.B_GODSWORD)
				&& (target.getId() != NpcID.COMMANDER_ZILYANA || target.getId() != NpcID.GENERAL_GRAARDOR))
			return;
		if (!ctx.combat.specialAttack()) {
			String[] USUAL_ITEMS = ctx.equipment.populate().toStream().map(item -> item.getName()).toArray(String[]::new);
			Variables.STATUS = "Switching weapon";
			switchSpec();
			Variables.STATUS = "Attacking with spec";
			MenuActions.invoke("Use <col=00ff00>Special Attack</col>", "", -1, 57, 1, 38862884);
			Tasks.getCombat().attack(target);
			ctx.onCondition(() -> !ctx.combat.specialAttack(), 250, 4);
			Tasks.getInventory().equipAll(USUAL_ITEMS);
		}
	}

	public boolean specWeaponIsReadyInCombatTab() {
		SimpleWidget w = ctx.widgets.getWidget(593, 1);
		if (w != null && w.getText() != null)
			return Stream.of(Weapons.SPECIAL_WEAPONS.values()).anyMatch(weapon -> w.getText().contains(weapon.getItemName()));
		return false;
	}

	@Getter
	private Timer monsterTimer = new Timer(1);

	public boolean isMonsterGoneForAWhile(int... ids) {
		return !isMonsterPresent(ids) && !monsterTimer.isRunning();
	}

	public boolean isMonsterGoneForAWhile(String... names) {
		return !isMonsterPresent(names) && !monsterTimer.isRunning();
	}

	public boolean isMonsterPresent(String... names) {
		SimpleNpc npc = getNPC(names);
		if (npc != null) {
			monsterTimer.setEndIn(120000);
			return true;
		}
		return false;
	}

	public boolean isMonsterPresent(int... ids) {
		SimpleNpc npc = getNPC(ids);
		if (npc != null) {
			monsterTimer.setEndIn(120000);
			return true;
		}
		return false;
	}

}

'''
'''--- api/tasks/Inventory.java ---
package api.tasks;

import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import api.Tasks;
import api.simple.KSItem;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.queries.SimpleItemQuery;
import simple.hooks.wrappers.SimpleGroundItem;
import simple.hooks.wrappers.SimpleItem;
import simple.robot.api.ClientContext;

public class Inventory {
	private ClientContext ctx;

	public Inventory(ClientContext ctx) {
		this.ctx = ctx;
	}

	public boolean predicate(SimpleItem item, String... itemName) {
		Stream<String> array = Stream.of(itemName);
		Predicate<String> filter = arr -> item.getName().toLowerCase().contains(arr.toLowerCase());
		return array.anyMatch(filter);
	}

	public boolean predicate(SimpleGroundItem item, String... itemName) {
		Stream<String> array = Stream.of(itemName);
		Predicate<String> filter = arr -> item.getName().toLowerCase().contains(arr.toLowerCase());
		return array.anyMatch(filter);
	}

	public SimpleItemQuery<SimpleItem> filter(String... itemName) {
		return ctx.inventory.populate().filter(p -> predicate(p, itemName));
	}

	public boolean contains(String... itemName) {
		return filter(itemName).population() > 0;
	}

	public boolean containsAll(int... itemId) {
		List<Integer> inv = ctx.inventory.populate().toStream().map(item -> item.getId()).collect(Collectors.toList());
		return itemId.length == Arrays.stream(itemId).filter(inv::contains).count();
	}

	public boolean containsAll(String... itemName) {
		List<String> inv = ctx.inventory.populate().toStream().map(item -> item.getName()).map(String::toLowerCase)
				.collect(Collectors.toList());
		return itemName.length == Arrays.stream(itemName).map(String::toLowerCase)
				.filter(val -> inv.stream().anyMatch(arr -> arr.contains(val))).count();
	}

	public SimpleItemQuery<SimpleItem> getItems(String... itemName) {
		return filter(itemName);
	}

	public SimpleItem getItem(String... itemName) {
		return getItems(itemName).next();
	}

	public boolean isWearing(EquipmentSlot slot, String... name) {
		String equipped = ctx.equipment.getEquippedItem(slot).getName().toLowerCase();

		return ctx.equipment.getEquippedItem(slot) != null
				&& Arrays.stream(name).anyMatch(item -> equipped.contains(item.toLowerCase()));
	}

	public void equip(String... name) {
		equip(false, name);
	}

	public void equip(boolean validate, String... name) {
		KSItem item = new KSItem(getItem(name));
		if (item.isNull()) return;

		if (item.click("Wear")) {
			if (validate) ctx.onCondition(() -> !ctx.equipment.populate().filter(item.getName()).isEmpty());
		}
	}

	public void equipAll(SimpleItemQuery<SimpleItem> items) {
		items.forEach(item -> {
			KSItem i = new KSItem(item);

			if (!i.isNull()) i.click("Wear");
		});
	}

	public void equipAll(String... name) {
		equipAll(getItems(name));
	}

	public void equipGuthans() {
		if (Tasks.getInventory().contains("guthan")) {
			if (Tasks.getInventory().contains("warspear") && ctx.inventory.inventoryFull()) {
				if (Tasks.getSupplies().eat()) ctx.onCondition(() -> !ctx.inventory.inventoryFull(), 2500);
			} else Tasks.getInventory().equipAll("guthan");
		}
	}
}

'''
'''--- api/tasks/Looting.java ---
package api.tasks;

import java.util.List;

import api.Tasks;
import api.Variables;
import api.simple.KSGroundItem;
import simple.hooks.queries.SimpleEntityQuery;
import simple.hooks.wrappers.SimpleGroundItem;
import simple.robot.api.ClientContext;

public class Looting {

	private ClientContext ctx;

	public Looting(ClientContext ctx) {
		this.ctx = ctx;
	}

	public boolean loot(String... loots) {
		SimpleEntityQuery<SimpleGroundItem> possible = ctx.groundItems.populate()
				.filter(item -> ctx.pathing.reachable(item.getLocation()));
		if (possible.population() == 0) return false;

		SimpleGroundItem loot;

		if (loots.length > 0) loot = possible.filter(p -> Tasks.getInventory().predicate(p, loots))
				.filter(item -> item.getId() != 995
						|| (item.getId() == 995 && item.getQuantity() >= 20000 && ctx.players.getLocal().distanceTo(item) <= 15))
				.nearest().next();
		else loot = possible.nearest().next();

		if (loot == null) return false;

		KSGroundItem item = new KSGroundItem(loot);

		if (ctx.inventory.canPickupItem(loot)) {
			Variables.STATUS = "Picking up loot " + item.getName();
			int population = ctx.inventory.populate().filter(loot.getId()).population(true);

			if (item.click("Take")) {
				ctx.sleep(200);
				ctx.onCondition(() -> population != ctx.inventory.populate().filter(loot.getId()).population(true));
				return true;
			}
		} else if (ctx.inventory.inventoryFull() && Tasks.getSupplies().hasFood()) {
			Tasks.getSupplies().eat();
			return true;
		}
		return false;

	}

	public boolean loot(List<String> loots) {
		return loot(loots.stream().toArray(String[]::new));
	}

}

'''
'''--- api/tasks/POHBanking.java ---
package api.tasks;

import api.Tasks;
import api.Variables;
import api.simple.KSItem;
import api.simple.KSObject;
import api.utils.Banks;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ObjectID;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;

public class POHBanking {

	private ClientContext ctx;

	public POHBanking(ClientContext ctx) {
		this.ctx = ctx;
	}

	@Getter
	@Setter
	private Banks currentBank = null;

	public boolean openBank() {
		if (currentBank == null) currentBank = Banks.getRandomBank(false);

		return currentBank.teleport() && currentBank.bank(true);
	}

	public boolean usePreset(boolean slayer) {
		if (currentBank == null) currentBank = Banks.getRandomBank(true);

		if (currentBank.teleport() && currentBank.bank(false)) {
			boolean slay = slayer && !Tasks.getInventory().contains("Slayer casket");
			boolean other = !slayer && (Tasks.getSupplies().hasFood() && Tasks.getSupplies().hasPrayer());

			KSObject bank = (KSObject) currentBank.get();

			if (bank.isNull()) {
				ctx.log("BANK is null");
				return false;
			}

			if ((slay || other) && !Variables.FORCE_BANK) return true;
			Variables.STATUS = "Getting last preset";
			if (ctx.inventory.itemSelectionState() == 1) ctx.inventory.populate().next().click(0);
			if (bank.click("Last-preset")) {
				ctx.onCondition(() -> Variables.LAST_MESSAGE.contains("preset"), 6000);
				Variables.FORCE_BANK = false;
				return true;
			}
		}
		return false;
	}

	public SimpleObject getPool() {
		return ctx.objects
				.populate().filter(ObjectID.FANCY_REJUVENATION_POOL, ObjectID.POOL_OF_REVITALISATION,
						ObjectID.POOL_OF_RESTORATION, ObjectID.ORNATE_REJUVENATION_POOL, ObjectID.POOL_OF_REJUVENATION)
				.nearest().next();
	}

	public boolean teleportHome() {
		if (!ctx.getClient().isInInstancedRegion()) {
			KSItem tab = new KSItem(Tasks.getInventory().getItem("Teleport to house"));
			if (tab.isNull()) {
				ctx.log("Out of teleports");
				ctx.sleep(15000);
				return false;
			}
			if (tab.click("Break")) ctx.onCondition(() -> ctx.getClient().isInInstancedRegion(), 5000);
		}
		return ctx.getClient().isInInstancedRegion();
	}

	public boolean usePool() {
		if (Tasks.getBanking().isFull()) return true;

		if (!teleportHome()) return false;
		SimpleObject box = getPool();
		if (box == null) return false;
		if (box.distanceTo(ctx.players.getLocal()) > 5) {
			Variables.STATUS = "Walking to pool";
			ctx.pathing.step(box.getLocation());
			ctx.sleep(450, 650);
			return false;
		}
		Variables.STATUS = "Refilling hitpoints";
		if (box.validateInteractable() && box.click("Drink")) ctx.onCondition(() -> Tasks.getBanking().isFull());
		return false;
	}
}

'''
'''--- api/tasks/Skill.java ---
package api.tasks;

import java.lang.reflect.Method;
import java.util.stream.Stream;

import api.MenuActions;
import api.Variables;
import net.runelite.api.MenuAction;
import net.runelite.api.VarPlayer;
import simple.hooks.filters.SimplePrayers.Prayers;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.simplebot.Game.Tab;
import simple.robot.api.ClientContext;

public class Skill {
	private ClientContext ctx;
	Method action;
	Class<?> _class;

	public Skill(ClientContext ctx) {
		this.ctx = ctx;
	}

	public int getPercentage(Skills skill) {
		float perc = ((float) ctx.skills.level(skill) / ctx.skills.realLevel(skill));
		float perc1 = (perc * 100);
		return (int) perc1;
	}

	public boolean shouldBoost(Skills s) {
		int lvl = ctx.skills.realLevel(s);
		int lvl1 = ctx.skills.level(s);
		int diff = lvl1 - lvl;
		int amt = 3;
		if (s == Skills.ATTACK || s == Skills.STRENGTH || s == Skills.DEFENCE) amt = 12;
		else if (s == Skills.RANGED) amt = 8;
		else if (s == Skills.MAGIC) amt = 2;
		else if (s == Skills.PRAYER) amt = 30;
		return diff == 0 || diff <= amt;
	}

	public void openTab(Tab tab) {
		if (!isTabOpen(tab)) ClientContext.instance().game.tab(tab);
	}

	public boolean isTabOpen(Tab tab) {
		return ClientContext.instance().game.tab().equals(tab);
	}

	public void flickPrayer(boolean enable) {
		try {
			synchronized (Variables.ACTIVE_PRAYERS) {
				Variables.ACTIVE_PRAYERS.forEach(enable ? this::enablePrayer : this::disablePrayer);
			}

		} catch (Exception e) {
			ctx.log("Exception");
		}
	}

	public void enablePrayer(Prayers prayer) {
		if (ctx.skills.level(Skills.PRAYER) == 0) return;
		if (!ctx.prayers.prayerActive(prayer)) MenuActions.invoke("Activate",
				"<col=ff9040>" + prayer.name().toString().replaceAll(" ", "_").toLowerCase() + "</col>", -1,
				MenuAction.CC_OP.getId(), 1, prayer.getWidgetInfo().getId());

	}

	public void disablePrayer(Prayers prayer) {
		if (ctx.prayers.prayerActive(prayer)) MenuActions.invoke("Deactivate",
				"<col=ff9040>" + prayer.name().toString().replaceAll(" ", "_").toLowerCase() + "</col>", -1,
				MenuAction.CC_OP.getId(), 1, prayer.getWidgetInfo().getId());
	}

	public void addPrayer(Prayers prayer) {
		if (Variables.ACTIVE_PRAYERS.contains(prayer)) return;
		if (prayer.name().toLowerCase().contains("protect"))
			Variables.ACTIVE_PRAYERS.removeIf(n -> n.name().toLowerCase().contains("protect"));
		Variables.ACTIVE_PRAYERS.add(prayer);
	}

	public void removePrayer(Prayers prayer) {
		if (Variables.ACTIVE_PRAYERS.contains(prayer)) {
			Variables.ACTIVE_PRAYERS.remove(prayer);
		}
		disablePrayer(prayer);
	}

	public void removeAll() {
		Stream.of(Prayers.values()).forEach(this::removePrayer);
	}

	public void removeAllBut(Prayers prayer) {
		Stream.of(Prayers.values()).filter(p -> p != prayer).forEach(this::removePrayer);
	}

	public void disablePrayers() {
		flickPrayer(false);
		Variables.USE_PRAYER = false;
	}

	public void enablePrayers() {
		flickPrayer(true);
		Variables.USE_PRAYER = true;
	}

	public boolean isPoisonedOrVenomed() {
		return ctx.getClient().getVar(VarPlayer.IS_POISONED) >= 30;
	}

}

'''
'''--- api/tasks/Slayer.java ---
package api.tasks;

import aioslayer.data.Constants;
import api.Locations;
import api.MenuActions;
import api.Tasks;
import api.Variables;
import api.panel.Config;
import api.simple.KSItem;
import api.simple.KSNPC;
import api.utils.Utils;
import api.utils.Weapons;
import net.runelite.api.MenuAction;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.filters.SimplePrayers.Prayers;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.api.ClientContext;

public class Slayer {

	private ClientContext ctx;

	public Slayer(ClientContext ctx) {
		this.ctx = ctx;
	}

	public void handleTask() {
		if (Constants.SHOULD_CHECK_TASK) {
			checkTask();
			return;
		}

		Tasks.getInventory().equipAll("defender", "whip", "scimitar", "ket-xil", "dragonfire shield");

		if (Constants.TASK == null) {
			if (Constants.SHOULD_SKIP && !getSkipScrolls()) return;
			if (!Constants.MASTER.atLocation()) {
				Constants.MASTER.travel();
				return;
			}
			KSNPC master = new KSNPC(ctx.npcs.populate().filter(Constants.MASTER.getId()).nearest().next());

			if (master.isNull()) return;

			ctx.bank.closeBank();
			Variables.STATUS = "Getting slayer task";
			if (ctx.pathing.distanceTo(master.getLocation()) > 3) {
				ctx.pathing.step(master.getLocation());
				ctx.onCondition(() -> ctx.pathing.distanceTo(master.getLocation()) < 4);
				return;
			}
			if (master.click("Assignment")) {
				ctx.onCondition(() -> ctx.dialogue.dialogueOpen());
				Constants.SHOULD_CHECK_TASK = true;
				Constants.SHOULD_SKIP = false;
			}
		}
	}

	public void useRing(String... option) {
		Variables.STATUS = "Attempting to travel";
		SimpleItem ring = Tasks.getInventory().getItem("slayer ring");
		if (ring == null) {
			getRing();
			return;
		}
		ctx.bank.closeBank();
		Variables.STATUS = "Going to slayer task";
		SimpleWidget teleportInterface = ctx.widgets.getWidget(187, 3);

		if (!Utils.validWidget(teleportInterface) && !ctx.dialogue.dialogueOpen()) {
			ctx.bank.closeBank();
			if (Tasks.getMenuAction().get(ring, "Rub").invoke())
				ctx.onCondition(() -> ctx.dialogue.dialogueOpen() || Utils.validWidget(teleportInterface));
		} else {

			String task = Constants.TASK.getName().toLowerCase();
			Config conf = Config.getItem(task);
			if (conf == null) {
				Variables.STATUS = "Unable to find config. " + task;
				return;
			}
			int opt = Tasks.getToken().getOption((String) conf.getValue());
			if (opt == -1) {
				Variables.STATUS = "Invalid location. " + conf.getValue();
				return;
			}
			if (opt == 0) opt++;
			ctx.keyboard.sendKeys(opt + "", false);
			ctx.sleep(450);
			ctx.sleepCondition(() -> ctx.players.getLocal().getAnimation() != -1, 450);
			ctx.sleepCondition(() -> ctx.players.getLocal().getAnimation() == -1, 550);
			ctx.sleep(650);
		}
	}

	private void checkTask() {
		KSItem ring = new KSItem(Tasks.getInventory().getItem("slayer ring"));
		boolean helm = Tasks.getInventory().isWearing(EquipmentSlot.HELMET);
		if (helm) {
			Variables.STATUS = "Checking slayer task";
			MenuActions.invoke("", "", -1, MenuAction.CC_OP.getId(), 4, 25362446);
			ctx.onCondition(() -> !Constants.SHOULD_CHECK_TASK);
		} else if (ring.isNull()) {
			getRing();
			return;
		}
		ctx.bank.closeBank();
		ctx.shop.closeShop();
		Variables.STATUS = "Checking slayer task";
		if (ring.click("Check")) ctx.onCondition(() -> !Constants.SHOULD_CHECK_TASK);
	}

	private boolean getSkipScrolls() {
		if (Tasks.getInventory().contains("slayer task skip")) return true;
		if (!ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
			Variables.STATUS = "Teleporting to edgeville";
			ctx.magic.castSpellOnce("Home");
			return false;
		}
		Variables.STATUS = "Getting slayer scrolls";
		return Tasks.getBanking().withdrawItem("Slayer task skip", 10);
	}

	private boolean getRing() {
		if (Tasks.getInventory().contains("slayer ring")) return true;
		if (!ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
			Variables.STATUS = "Teleporting to edgeville";
			ctx.magic.castSpellOnce("Home");
			return false;
		}
		Variables.STATUS = "Getting slayer ring";
		return Tasks.getBanking().withdrawItem("slayer ring");
	}

	public void fightNpc() {
		if (Constants.TASK == null) return;
		Tasks.getCombat().checkPots();
		Tasks.getSkill().addPrayer(Constants.TASK.getProtection());

		if (Tasks.getInventory().isWearing(EquipmentSlot.WEAPON, "crossbow")) Tasks.getSkill().addPrayer(Prayers.EAGLE_EYE);
		else addMeleePray();

		if (ctx.players.getLocal().getInteracting() != null) {
			Variables.STATUS = "Fighting...";
			return;
		}

		SimpleNpc npc = new KSNPC(Constants.TASK.getId()).inDistance(10).isAggressive(true).get();

		if (npc == null) npc = Tasks.getCombat().getAggressiveNPC(Constants.TASK.getId());
		if (npc == null) npc = Tasks.getCombat().getNPC(true, Constants.TASK.getId());
		if (npc == null) npc = Tasks.getCombat().getMultiNpc(Constants.TASK.getId());
		if (npc != null) {
			Weapons.SPECIAL_WEAPON = Weapons.getSpecialWeapon();
			if (Weapons.canSpecial(false) || Weapons.canSpecial(true)) Tasks.getCombat().useSpecialAttack(npc);
			else Tasks.getCombat().attack(npc);
		}
	}

	private void addMeleePray() {
		int prayerLvl = ctx.skills.realLevel(Skills.PRAYER);
		if (prayerLvl >= 31 && prayerLvl < 70) {
			Tasks.getSkill().addPrayer(Prayers.ULTIMATE_STRENGTH);
			Tasks.getSkill().addPrayer(Prayers.INCREDIBLE_REFLEXES);
		} else {
			Tasks.getSkill().addPrayer(Prayers.PIETY);
		}
	}

	public boolean shouldSkip(String name) {
		boolean slayerHelm = Tasks.getInventory().isWearing(EquipmentSlot.HELMET, "slayer");
		boolean rockHammer = Tasks.getInventory().contains("Rock hammer");
		boolean antiDragonShield = Tasks.getInventory().contains("dragon shield", "dragonfire")
				|| Tasks.getInventory().isWearing(EquipmentSlot.SHIELD, "dragonfire", "dragon shield");

		boolean leafSword = Tasks.getInventory().contains("Leaf-bladed")
				|| Tasks.getInventory().isWearing(EquipmentSlot.WEAPON, "Leaf-bladed");

		switch (name.toLowerCase()) {
			case "aberrant spectres":
			case "dust devils":
			case "smoke devils":
				return !slayerHelm;
			case "gargoyles":
				return !rockHammer;
			case "blue dragons":
			case "black dragons":
			case "iron dragons":
			case "red dragons":
			case "steel dragons":
				return !antiDragonShield;
			case "turoth":
			case "kurask":
				return !leafSword;
			case "adamant dragon":
			case "aviansie":
			case "rune dragons":
				// case "brine rat":
			case "cave kraken":
			case "drakes":
			case "fossil island wyverns":
			case "lizardmen":
				// case "minions of scabaras":
			case "mithril dragons":
			case "mutated Zygomites":
			case "rune dragon":
			case "skeletal wyverns":
			case "spiritual creatures":
			case "tzhaar":
			case "vampyre":
			case "wyrms":
			case "kalphites":
			case "mutated zygomites":
				return true;
		}
		return false;
	}

	public boolean shouldBank() {
		return !Tasks.getInventory().contains("antifire") || !Tasks.getInventory().contains("prayer", "restore", "sanfew")
				|| Tasks.getSkill().getPercentage(Skills.HITPOINTS) < 20 || Variables.FORCE_BANK;
	}
}

'''
'''--- api/tasks/Supplies.java ---
package api.tasks;

import api.Tasks;
import api.Variables;
import api.simple.KSItem;
import api.utils.Timer;
import lombok.AllArgsConstructor;
import lombok.Getter;
import simple.robot.api.ClientContext;

public class Supplies {

	@AllArgsConstructor
	public enum PotionType {
		ATTACK(new String[] { "attack", "combat" }),
		STRENGTH(new String[] { "strength", "combat" }),
		DEFENCE(new String[] { "defence", "combat" }),
		MAGE(new String[] { "magic" }),
		RANGED(new String[] { "ranging" }),
		ANTIPOISON(new String[] { "antipoison", "antidote" }),
		PRAYER(new String[] { "prayer", "restore" }),
		ANTIFIRE(new String[] { "antifire" }),
		ENERGY(new String[] { "energy", "stamina" }),;

		@Getter
		private String[] value;
	}

	private ClientContext ctx;

	public Supplies(ClientContext ctx) {
		this.ctx = ctx;
	}

	public Timer antiFire = new Timer(1);
	public Timer antiPoison = new Timer(1);

	public boolean drink(PotionType type) {
		if (type.equals(PotionType.ANTIFIRE) && antiFire.isRunning()) return true;

		KSItem potion = new KSItem(Tasks.getInventory().getItem(type.getValue()));
		if (potion.isNull()) return false;
		Variables.STATUS = "Drinking " + type.toString() + " potion";
		if (potion.click("Drink")) {
			if (type.equals(PotionType.ANTIFIRE)) antiFire = new Timer(200000);
			ctx.onCondition(() -> ctx.players.getLocal().getAnimation() != -1);
			ctx.onCondition(() -> ctx.players.getLocal().getAnimation() == -1);
			return true;
		}
		return false;
	}

	public boolean eat() {
		KSItem food = new KSItem(ctx.inventory.populate().filterHasAction("Eat").next());
		if (food.isNull()) return false;

		Variables.STATUS = "Eating food";
		if (food.click("Eat")) {
			ctx.onCondition(() -> ctx.players.getLocal().getAnimation() != -1);
			ctx.onCondition(() -> ctx.players.getLocal().getAnimation() == -1);
			return true;
		}
		return false;
	}

	public boolean eat(String name) {
		KSItem food = new KSItem(Tasks.getInventory().getItem(name));
		if (food.isNull()) return false;

		Variables.STATUS = "Eating food";
		if (food.click("Eat")) {
			ctx.onCondition(() -> ctx.players.getLocal().getAnimation() != -1);
			ctx.onCondition(() -> ctx.players.getLocal().getAnimation() == -1);
			return true;
		}
		return false;
	}

	public boolean hasFood() {
		return ctx.inventory.populate().filterHasAction("Eat").population() > 0;
	}

	public boolean hasPrayer() {
		return Tasks.getInventory().contains("prayer", "restore", "sanfew");
	}

}

'''
'''--- api/tasks/Token.java ---
package api.tasks;

import java.util.Arrays;
import java.util.stream.IntStream;

import api.Locations;
import api.Tasks;
import api.Variables;
import api.simple.KSItem;
import api.utils.Utils;
import joptsimple.internal.Strings;
import net.runelite.api.FriendsChatMember;
import net.runelite.api.VarClientStr;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.api.ClientContext;

public class Token {

	private ClientContext ctx;

	public Token(ClientContext ctx) {
		this.ctx = ctx;
	}

	public enum INSTANCES {
		KING_BLACK_DRAGON,
		DAGANNOTH_KINGS,
		BYROPHYTA,
		THERMONUCLEAR_SMOKE_DEVIL,
		GENERAL_GRAARDOR,
		KRIL_TSUTSAROTH,
		KREEARA,
		COMMANDER_ZILYANA,
		KALPHITE_QUEEN,
		SARACHNIS,
		CERBERUS,
		CORPOREAL_BEAST
	}

	public void createInstance(INSTANCES option) {
		SimpleWidget widget1 = ctx.widgets.getWidget(1028, 5);
		SimpleWidget widget2 = ctx.widgets.getWidget(1028, option.ordinal());

		if (ctx.dialogue.dialogueOpen()) {
			if (ctx.dialogue.clickDialogueOption(1)) ctx.onCondition(() -> !ctx.pathing.inArea(Locations.EDGEVILLE_AREA));
		} else if (Utils.validWidget(widget1)) {
			if (widget1.getChild(5).click(0)) ctx.sleep(500, 750);
		} else if (Utils.validWidget(widget2)) {
			SimpleWidget child2 = widget2.getChild(0);
			if (child2.getSpriteId() == 697) {
				child2.click(0);
				ctx.sleep(150, 250);
				ctx.sleepCondition(() -> ctx.dialogue.dialogueOpen(), 1000);
			} else {
				SimpleWidget confirm = ctx.widgets.getWidget(1028, 15);
				if (confirm != null && confirm.visibleOnScreen()) confirm.click(0);
			}
		}
	}

	private String getTitle() {
		SimpleWidget w = ctx.widgets.getWidget(219, 1);
		if (!Utils.validWidget(w)) return "";
		return w.getChild(0).getText();
	}

	public void joinInstance(boolean insurance) {
		if (ctx.dialogue.canContinue()) {
			ctx.dialogue.clickContinue();
			ctx.sleep(450, 600);
		} else if (getTitle().length() > 0) {
			if (getTitle().contains("private clan")) {
				SimpleWidget single = getDialogueOptionWidget("Pay one Instance token."),
						two = getDialogueOptionWidget("Pay 2 Instance tokens.");

				if (insurance && Utils.validWidget(single)) ctx.pathing.step(ctx.players.getLocal().getLocation());

				SimpleWidget w = insurance ? two : single;
				if (Utils.validWidget(w)) {
					if (w.click(0)) ctx.sleepCondition(() -> !ctx.pathing.inArea(Locations.EDGEVILLE_AREA), 1500);
				}
			} else if (getTitle().contains("personal insurance")) {
				SimpleWidget w = insurance ? getDialogueOptionWidget("Yes, I want the insurance!")
						: getDialogueOptionWidget("No thanks, I don't need it.");
				if (Utils.validWidget(w)) {
					if (w.click(0)) ctx.sleepCondition(() -> getTitle().contains("private clan"), 2500);
				}
			}
		}
	}

	public int getInterfaceOption(String option) {
		if (option == null) return -1;
		SimpleWidget w = ctx.widgets.getWidget(187, 3);
		if (!Utils.validWidget(w)) return -1;
		return IntStream.range(0, w.getChildren().length).filter(val -> Utils.validWidget(w.getChild(val))).filter(v -> {
			SimpleWidget c = w.getChild(v);
			return Utils.validWidget(c) && c.getText() != null && c.getText().toLowerCase().contains(option.toLowerCase());
		}).map(i -> i + 1).findFirst().orElse(-1);
	}

	public int getOption(String option) {
		if (option == null) return -1;
		SimpleWidget w = ctx.widgets.getWidget(219, 1);
		if (!Utils.validWidget(w)) return getInterfaceOption(option);
		return IntStream.range(0, w.getChildren().length).filter(val -> Utils.validWidget(w.getChild(val))).filter(v -> {
			SimpleWidget c = w.getChild(v);
			return Utils.validWidget(c) && c.getText() != null && c.getText().toLowerCase().contains(option.toLowerCase());
		}).findFirst().orElse(-1);
	}

	public SimpleWidget getDialogueOptionWidget(String option) {
		SimpleWidget w = ctx.widgets.getWidget(219, 1);
		if (!Utils.validWidget(w)) return null;
		return Arrays.stream(w.getChildren()).filter(Utils::validWidget).filter(v -> {
			if (option == null) return true;
			return v.getText().toLowerCase().contains(option.toLowerCase());
		}).findFirst().orElse(null);
	}

	public void handle(String hostName, boolean host, boolean insurance, INSTANCES... option) {
		KSItem token = new KSItem(Tasks.getInventory().getItem("Instance token"));
		if (!token.isNull()) {
			ctx.bank.closeBank();
			if (host) {
				if (ctx.widgets.getWidget(1028, 5) == null) token.click("Create");
				Variables.STATUS = "Creating instance";
				if (option.length == 1) createInstance(option[0]);
			} else {
				if (ctx.dialogue.pendingInput()) {
					Variables.STATUS = "Inputting host name";
					if (Strings.isNullOrEmpty(hostName)) hostName = getHost();

					ctx.log("Host Name: " + hostName);

					if (!Strings.isNullOrEmpty(hostName)) {
						ctx.getClient().setVar(VarClientStr.INPUT_TEXT, hostName);
						ctx.keyboard.sendKeys("", true);
						ctx.sleep(250, 350);
					}
				} else if (ctx.dialogue.dialogueOpen()) {
					Variables.STATUS = "Joining instance";
					joinInstance(insurance);
				} else {
					Variables.STATUS = "Clicking join";
					if (token.click("Join")) {
						ctx.onCondition(() -> ctx.dialogue.pendingInput());
					}
				}
			}
		}
	}

	public String getHost() {
		FriendsChatMember[] members = ctx.getClient().getFriendsChatManager().getMembers();
		String username = Arrays.asList(members).stream().map(player -> player.getName())
				.filter(name -> ctx.players.populate().filter(name).population() == 0).findFirst().orElse(null);
		return username;
	}

}

'''
'''--- api/threads/PrayerObserver.java ---
package api.threads;

import java.util.function.BooleanSupplier;

import api.Tasks;
import api.utils.Utils;
import net.runelite.api.GameState;
import simple.robot.api.ClientContext;

public class PrayerObserver extends Thread {
	private BooleanSupplier condition;
	private ClientContext ctx;

	private long currTick = 0;
	private boolean enabled = false;

	public PrayerObserver(ClientContext ctx, BooleanSupplier condition) {
		this.ctx = ctx;
		this.condition = condition;
		this.setUncaughtExceptionHandler(Utils.handler);
	}

	@Override
	public void run() {

		ctx.log("Running");
		while (ctx.getClient().getGameState() != GameState.LOGGED_IN) {
			ctx.log("Not logged in");
			ctx.sleep(500);
		}

		while (true) {
			if (!condition.getAsBoolean()) {
				ctx.sleep(250);
				continue;
			}

			if (ClientContext.instance().getClient().getSpellSelected()) {
				ctx.sleep(10);
				continue;
			}

			if (ctx.getClient().getTickCount() != currTick) {
				Tasks.getSkill().flickPrayer(!enabled);
				if (!enabled) currTick = ctx.getClient().getTickCount();

				enabled = !enabled;
			}
			ctx.sleep(10);
		}
	}
}

'''
'''--- api/utils/BankCheck.java ---
package api.utils;

import java.util.ArrayList;
import java.util.List;

import simple.hooks.wrappers.SimpleItem;
import simple.robot.api.ClientContext;

public class BankCheck {

	public static List<SimpleItem> CHECK_LIST = new ArrayList<SimpleItem>();

	public static boolean bankContains() {
		return !CHECK_LIST.stream().anyMatch(item -> {
			return ClientContext.instance().bank.populate().filter(item.getName()).population(true) < item.getQuantity();
		});
	}

}

'''
'''--- api/utils/Banks.java ---
package api.utils;

import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;

import api.Tasks;
import api.Variables;
import api.simple.KSNPC;
import api.simple.KSObject;
import lombok.AllArgsConstructor;
import lombok.Getter;
import simple.robot.api.ClientContext;

@AllArgsConstructor
@Getter
public enum Banks {

	CAMELOT("Cities", "Camelot", 10806, false, Type.OBJECT, "Bank booth"),
	CANAFIS("Cities", "Canifis", 13878, false, Type.OBJECT, "Bank Booth"),
	CATHERBY("Cities", "CATHERBY", 11061, true, Type.OBJECT, "Bank booth"),
	DRAYNOR("Cities", "Draynor", 12338, true, Type.OBJECT, "Bank booth"),
	LANDS_END("Cities", "Land's End", 5941, false, Type.OBJECT, "Bank chest"),
	NEITIZNOT("Cities", "Neitiznot", 9275, false, Type.OBJECT, "Bank chest"),
	SHILO_VILLAGE("Cities", "Shilo Village", 11310, false, Type.NPC, "Banker"),
	YANILLE("Cities", "Yanille", 10288, false, Type.NPC, "Banker"),
	PISCATORIS("Cities", "Piscatoris", 9273, false, Type.NPC, "Arnold Lydspor"),
	WINTERDTOTD("Skilling", "Firemaking: Wintertodt", 6461, true, Type.OBJECT, "Bank chest"),
	ANGLERFISH("Skilling", "Fishing: Anglerfish", 7227, false, Type.OBJECT, "Bank booth"),
	MLM("Skilling", "Mining: Motherlode mine", 14936, true, Type.OBJECT, "Bank chest"),
	// VARROCK_ANVIL("Skilling", "Smithing: Varrock Anvils", 12597, false,
	// Type.NPC, "Banker"),
	CASTLE_WARS("Minigames", "Castle Wars", 9776, true, Type.OBJECT, "Bank chest"),
	PEST_CONTROL("Minigames", "Pest Control", 10537, false, Type.OBJECT, "Bank booth"),;

	private String category, name;
	private int region;
	private boolean preset;

	private Type type;
	private String obj;

	public enum Type {
		NPC,
		OBJECT
	}

	public Object get() {
		ClientContext ctx = ClientContext.instance();
		return type.equals(Type.NPC) ? new KSNPC(ctx.npcs.populate().filter(obj).nearest().next())
				: new KSObject(ctx.objects.populate().filter(obj).nearest().next());
	}

	public boolean teleport() {
		ClientContext ctx = ClientContext.instance();

		if (ctx.players.getLocal().getLocation().getRegionID() != region) {
			if (!Utils.directTeleport(name) && Tasks.getTeleporter().open())
				Tasks.getTeleporter().teleportStringPath(category, name);
			ctx.onCondition(() -> ctx.players.getLocal().getLocation().getRegionID() == region, 2500);
		}
		return ctx.players.getLocal().getLocation().getRegionID() == region;
	}

	public boolean bank(boolean open) {
		ClientContext ctx = ClientContext.instance();

		if (!ctx.bank.bankOpen()) {
			if (type.equals(Type.NPC)) {
				KSNPC banker = (KSNPC) get();
				if (banker.isNull()) {
					ctx.log("Banker is null");
					return false;
				}
				if (banker.distanceTo(ctx.players.getLocal()) > 5) {
					Variables.STATUS = "Walking to banker";
					ctx.pathing.step(banker.getLocation());
					ctx.sleep(450, 650);
					return false;
				}
				Variables.STATUS = "Opening bank";
				if (open && banker.validateInteractable() && banker.click("Bank"))
					ctx.onCondition(() -> ctx.bank.bankOpen(), 2500);
				return open ? ctx.bank.bankOpen() : banker.distanceTo(ctx.players.getLocal()) < 5;
			} else {
				KSObject bank = (KSObject) get();
				if (bank.isNull()) {
					ctx.log("Banker is null");
					return false;
				}
				if (bank.distanceTo(ctx.players.getLocal()) > 10) {
					Variables.STATUS = "Walking to bank";
					ctx.pathing.step(bank.getLocation());
					ctx.sleep(450, 650);
					return false;
				}
				Variables.STATUS = "Opening bank";
				if (open && bank.validateInteractable() && bank.click(obj.contains("chest") ? "Use" : "Bank"))
					ctx.onCondition(() -> ctx.bank.bankOpen(), 2500);
				return open ? ctx.bank.bankOpen() : bank.distanceTo(ctx.players.getLocal()) < 10;
			}
		}
		return false;
	}

	public static Banks getRandomBank(boolean preset) {
		Random r = new Random();

		List<Banks> b = Arrays.stream(Banks.values()).filter(p -> preset ? p.isPreset() : p != null).collect(Collectors.toList());
		return b.get(r.nextInt(b.size()));
	}

}
'''
'''--- api/utils/Timer.java ---
package api.utils;

import lombok.Getter;
import simple.robot.util.Time;

public class Timer {
	@Getter
	public long start;

	private long period;

	private long end;

	public String toElapsedString() {
		return Time.formatTime(getElapsed());
	}

	public long setEndIn(long l) {
		this.end = System.currentTimeMillis() + l;
		return this.end;
	}

	public String toRemainingString() {
		return Time.formatTime(getRemaining());
	}

	public void end() {
		this.end = System.currentTimeMillis();
	}

	public void reset() {
		this.end = System.currentTimeMillis() + this.period;
	}

	public Timer() {
		this.period = this.start = System.currentTimeMillis();
	}

	public void restart() {
		this.period = this.start = System.currentTimeMillis();
	}

	public Timer(long l) {
		this.period = l;
		this.start = System.currentTimeMillis();
		this.end = this.start + l;
	}

	public long getElapsed() {
		return System.currentTimeMillis() - this.start;
	}

	public long getRemaining() {
		if (isRunning()) return this.end - System.currentTimeMillis();
		return 0L;
	}

	public boolean isRunning() {
		return System.currentTimeMillis() < this.end;
	}
}
'''
'''--- api/utils/Utils.java ---
package api.utils;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.annotation.Annotation;
import java.net.URL;
import java.net.URLConnection;
import java.nio.charset.StandardCharsets;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import api.Variables;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.simplebot.Game.Tab;
import simple.hooks.simplebot.Magic.SpellBook;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.api.ClientContext;
import simple.robot.utils.WorldArea;

public class Utils {
	private static Pattern regex = Pattern.compile("\\.(\\d+)[A-z]$");

	public static int distance(WorldPoint a) {
		return a.distanceTo(ClientContext.instance().players.getLocal().getLocation());
	}

	public static String formatComma(long start) {
		return new DecimalFormat("#,###,###,###").format(start);
	}

	public static String formatNumber(long num) {
		String[] suffix = new String[] { "K", "M", "B", "T" };
		int size = (num != 0) ? (int) Math.log10(num) : 0;
		if (size >= 3) {
			while (size % 3 != 0) {
				size = size - 1;
			}
		}
		String ret = (size >= 3) ? (+(Math.round((num / Math.pow(10, size)) * 10) / 10d) + suffix[(size / 3) - 1]) : +num + "";

		// if (!ret.endsWith("B") || ret.endsWith("0B"))
		// ret = ret.replaceAll("\\.\\d+", "");

		return ret;

	}

	public static String repeat(char what, int howmany) {
		if (howmany < 1) return new String();
		char[] chars = new char[howmany];
		Arrays.fill(chars, what);
		return new String(chars);
	}

	public static long reverseFormat(String start) {
		start = start.toLowerCase();
		Matcher m = regex.matcher(start);
		int zero = start.endsWith("k") ? 2 : start.endsWith("m") ? 5 : start.endsWith("b") ? 8 : 0;

		if (!start.contains(".")) zero++;
		if (m.find()) {
			int count = m.group(1).length();
			zero = zero - (count - 1);
		}
		return Long.parseLong(start.replace(".", "").replaceAll("k", repeat('0', zero)).replaceAll("m", repeat('0', zero))
				.replaceAll("b", repeat('0', zero)));
	}

	public static WorldPoint getPlayerLocation() {
		return ClientContext.instance().players.getLocal().getLocation();
	}

	public static WorldArea makeArea(int x, int y, int x2, int y2, int z) {
		return new WorldArea(new WorldPoint(x, y, z), new WorldPoint(x2, y2, z));
	}

	public static boolean directTeleport(String teleport) {
		ClientContext ctx = ClientContext.instance();
		ctx.bank.closeBank();
		ctx.shop.closeShop();

		while (!openTab(Tab.MAGIC)) {
		}
		SimpleWidget widget = ctx.widgets.getWidget(218, ctx.magic.spellBook() == SpellBook.MODERN ? 5 : 99);
		Variables.STATUS = "Teleporting to " + teleport;
		String[] actions = widget.getWidget().getActions();
		boolean action = actions.length > 0 && actions[actions.length - 1].contains(teleport);
		if (!action) return false;
		if (widget.click(3)) {
			ctx.sleep(450);
			ctx.sleepCondition(() -> ctx.players.getLocal().getAnimation() != -1, 450);
			ctx.sleepCondition(() -> ctx.players.getLocal().getAnimation() == -1, 550);
			ctx.sleep(1500);
		}
		return true;
	}

	public static boolean openTab(Tab tab) {
		if (!isTabOpen(tab)) ClientContext.instance().game.tab(tab);
		return isTabOpen(tab);
	}

	public static boolean isTabOpen(Tab tab) {
		return ClientContext.instance().game.tab().equals(tab);
	}

	public static boolean license(String url) throws Exception {
		URLConnection conn = new URL(url).openConnection();
		List<Integer> ids = new ArrayList<Integer>();
		try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
			reader.lines().mapToInt(Integer::parseInt).forEach(ids::add);
		}
		return ids.contains(ClientContext.instance().user.forumsId());
	}

	public static String getValue(Class<?> reflectClass, String val) {
		Annotation[] anno = reflectClass.getAnnotations();
		Class<? extends Annotation> type = anno[0].annotationType();
		return (String) Stream.of(type.getDeclaredMethods()).filter(m -> m.getName().equalsIgnoreCase(val)).map(m -> {
			try {
				return m.invoke(anno[0], (Object[]) null);
			} catch (Exception e) {
				e.printStackTrace();
				return "";
			}
		}).findFirst().orElse(null);
	}

	public static void setZoom(int zoom) {
		ClientContext ctx = ClientContext.instance();
		ctx.viewport.pitch(100);
		ctx.viewport.angle(0);

		if (!openTab(Tab.OPTIONS)) return;

		SimpleWidget widget = ctx.widgets.getWidget(261, 8 + zoom);
		if (widget != null && widget.visibleOnScreen()) widget.click(0);
	}

	public static String formatString(String... str) {
		return Arrays.asList(str).stream().map(t -> t.substring(0, 1).toUpperCase() + t.substring(1).toLowerCase())
				.collect(Collectors.joining(" "));
	}

	final static String tregex = "hint: (.*)";
	final static Pattern pattern = Pattern.compile(tregex);

	public static void doTriva() {
		ClientContext ctx = ClientContext.instance();
		SimpleWidget trivia = ctx.widgets.getWidget(162, 44);
		if (trivia != null && trivia.visibleOnScreen()) {
			String text = trivia.getText();
			ctx.log(text);
			if (text.length() == 0) return;
			Matcher matcher = pattern.matcher(text);
			if (matcher.find()) {
				final String answer = matcher.group(8);
				ctx.keyboard.sendKeys(answer, true);
			}
			return;
		}
	}

	public static boolean validWidget(SimpleWidget w) {
		return w != null && w.visibleOnScreen();
	}

	public static Thread.UncaughtExceptionHandler handler = new Thread.UncaughtExceptionHandler() {
		@Override
		public void uncaughtException(Thread th, Throwable ex) {
			ClientContext.instance().log("Uncaught exception: " + ex);
			StackTraceElement[] stackTrace = ex.getStackTrace();
			for (StackTraceElement st : stackTrace) {
				ClientContext.instance().log("Stacktrace: " + st);
			}
			// ctx.stopScript();
		}
	};

}

'''
'''--- api/utils/Weapons.java ---
package api.utils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.stream.Stream;

import api.Tasks;
import lombok.Getter;
import net.runelite.api.ItemID;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.wrappers.SimpleItem;
import simple.robot.api.ClientContext;

public class Weapons {

	public static ArrayList<Integer> MAGE_WEAPONS = new ArrayList<Integer>(
			Arrays.asList(ItemID.ANCIENT_STAFF, ItemID.TOXIC_STAFF_OF_THE_DEAD, 24423, 24424, 24425, ItemID.STAFF_OF_THE_DEAD,
					ItemID.STAFF_OF_LIGHT, ItemID.STAFF_OF_WATER, ItemID.AHRIMS_STAFF, ItemID.MASTER_WAND, ItemID.KODAI_WAND,
					ItemID.ZURIELS_STAFF, ItemID.THAMMARONS_SCEPTRE_U, ItemID.THAMMARONS_SCEPTRE, ItemID.VOID_KNIGHT_MACE,
					ItemID.VOID_KNIGHT_MACE_BROKEN, ItemID.VOID_KNIGHT_MACE_L));

	public static SPECIAL_WEAPONS SPECIAL_WEAPON = null;

	public enum SPEED {
		FAST,
		SLOW,
		MODERATE
	}

	public enum SPECIAL_WEAPONS {
		DRAGON_DAGGER("ragon dagger", SPEED.SLOW, 25, false),
		DRAGON_CLAWS("claws", SPEED.FAST, 50, false),
		A_GODSWORD("rmadyl godsword", SPEED.FAST, 50, true),
		B_GODSWORD("andos godsword", SPEED.FAST, 50, true),
		S_GODSWORD("aradomin godsword", SPEED.FAST, 50, true),
		Z_GODSWORD("amorak  godsword", SPEED.FAST, 50, true),
		D_HALLY("ragon halberd", SPEED.MODERATE, 30, true),
		VESTA_LONGSWORD("esta's longsword", SPEED.FAST, 25, false),
		STATIUS_WARHAMMER("s warhammer", SPEED.MODERATE, 25, false),
		DRAGON_WARHAMMER("warhammer", SPEED.FAST, 50, false),
		DRAGON_MACE("ragon mace", SPEED.SLOW, 25, false),
		DRAGON_LONGSWORD("ragon longsword", SPEED.SLOW, 25, false),
		DRAGON_HALBERD("ragon halberd", SPEED.SLOW, 30, true);

		@Getter
		private String itemName;
		@Getter
		private SPEED speed;
		@Getter
		private int energy;
		@Getter
		private boolean twoHanded;

		SPECIAL_WEAPONS(String itemName, SPEED speed, int energy, boolean twoHanded) {
			this.itemName = itemName;
			this.speed = speed;
			this.energy = energy;
			this.twoHanded = twoHanded;
		}

		public SimpleItem item() {
			return Tasks.getInventory().getItem(this.itemName);
		}

		public boolean itemEquiped() {
			return Tasks.getInventory().isWearing(EquipmentSlot.WEAPON, this.itemName);
		}

		public boolean needsRoom() {
			ClientContext ctx = ClientContext.instance();
			return isTwoHanded() && (ctx.equipment.getEquippedItem(EquipmentSlot.WEAPON) != null
					&& ctx.equipment.getEquippedItem(EquipmentSlot.SHIELD) != null);
		}
	}

	public static SPECIAL_WEAPONS getSpecialWeapon() {
		return Stream.of(SPECIAL_WEAPONS.values()).filter(weapon -> weapon.itemEquiped() || weapon.item() != null).findFirst()
				.orElse(null);
	}

	public static boolean canSpecial(boolean equipped) {
		ClientContext ctx = ClientContext.instance();
		if (SPECIAL_WEAPON == null) return false;
		if (SPECIAL_WEAPON.isTwoHanded() && ctx.inventory.inventoryFull()) return false;
		boolean can = ctx.combat.getSpecialAttackPercentage() >= SPECIAL_WEAPON.getEnergy();
		return equipped ? SPECIAL_WEAPON.itemEquiped() && can : can;
	}

	public static boolean isEquipped() {
		return SPECIAL_WEAPON != null && SPECIAL_WEAPON.itemEquiped();
	}

}

'''
'''--- barrow/Barrows.java ---
package barrow;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.util.stream.Stream;

import api.Locations;
import api.Tasks;
import api.Variables;
import api.tasks.Supplies.PotionType;
import api.utils.Utils;
import barrow.methods.Brothers;
import barrow.methods.Constants;
import barrow.methods.ScriptUtils;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.robot.script.Script;

@ScriptManifest(author = "KremeSickle", category = Category.MINIGAMES, description = "Barrows", discord = "", name = "Barrows", servers = {
		"Zaros" }, version = "2")
public class Barrows extends Script implements LoopingScript {
	final String[] STOP_MESSAGES = { "be found: prayer potion", "be found: shark", "enough ammo", "you are dead" };

	@Override
	public void onChatMessage(ChatMessage msg) {
		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			if (msg.getMessage().contains("opened the barrows chest")) {
				Variables.COUNT++;
				Brothers.reset();
			}
			if (!Variables.STOP) {
				Variables.STOP = Stream.of(STOP_MESSAGES).anyMatch(msg1 -> msg.getMessage().contains(msg1));
			}
		}
	}

	@Getter
	private ScriptUtils utils;

	@Override
	public void onExecute() {
		Tasks.init(ctx);
		utils = new ScriptUtils(ctx, this);
		Brothers.reset();
		Brothers.update();

		SimpleItem _switch = ctx.inventory.populate().filterHasAction("Wield").next();
		if (_switch != null) Constants.WEAPON_SWITCH = _switch.getName();

		Variables.STARTED = true;
	}

	@Override
	public void onProcess() {
		if (utils.checkWeapon()) {
			Variables.STATUS = "Filling staff";
			utils.fillStaff();
			return;
		}

		ctx.combat.toggleAutoRetaliate(true);
		if (ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
			Tasks.getSkill().removeAll();
			if (!Tasks.getBanking().heal()) return;
			if (!Tasks.getBanking().usePreset()) return;
			if (Utils.directTeleport("Barrows")) return;
			if (Tasks.getTeleporter().open()) Tasks.getTeleporter().teleportStringPath("Minigames", "Barrows");

		} else if (ctx.pathing.inArea(Locations.BARROWS_HILLS)) {
			Tasks.getSkill().removeAll();
			Brothers next = Brothers.getNextBrother();
			if (next == null) return;
			if (!ctx.pathing.inArea(next.getDigArea())) {
				Variables.STATUS = "Walking to dig location";
				ctx.pathing.step(next.getDigArea().randomTile());
				ctx.onCondition(() -> ctx.pathing.inArea(next.getDigArea()), 1000, 3);
			} else {
				Variables.STATUS = "Digging";
				utils.dig();
			}
		} else if (ctx.pathing.plane() == 3 || ctx.pathing.inArea(Locations.BARROWS_FINAL_SARCO)) {
			boolean _final = ctx.pathing.inArea(Locations.BARROWS_FINAL_SARCO);
			Brothers current = utils.currentBrother();

			if (_final && Brothers.getTotalKilled() == 0) {
				ctx.magic.castSpellOnce("Home");
				return;
			}
			if (!_final && (current != null && current.isKilled())
					|| (Brothers.getTotalKilled() < 5 && current.equals(Brothers.getTunnelBrother()))) {
				Tasks.getSkill().removeAll();
				utils.exitCrypt();
				return;
			}

			if (ctx.dialogue.dialogueOpen() && Brothers.getTotalKilled() == 5) {
				if (!ctx.dialogue.canContinue()) {
					Variables.STATUS = "Clicking continue again";
					ctx.dialogue.clickDialogueOption(1);
					ctx.sleep(350, 700);
				} else {
					Variables.STATUS = "Clicking continue";
					ctx.dialogue.clickContinue();
					ctx.sleep(150, 300);
				}
				return;
			}
			if (Tasks.getSkill().getPercentage(Skills.PRAYER) < 20) Tasks.getSupplies().drink(PotionType.PRAYER);
			if (Tasks.getSkill().getPercentage(Skills.HITPOINTS) < 50) Tasks.getSupplies().eat();

			SimpleNpc npc = utils.aggressiveNPC();
			if (current == null || npc == null) {
				Variables.STATUS = "Opening coffin";
				utils.searchCoffin("Search");
				ctx.sleep(150, 450);
				return;
			}

			if (npc.isDead()) {
				utils.exitCrypt();
				return;
			}

			Tasks.getSkill().enablePrayer(current.getPrayer());
			boolean ahrim = current.equals(Brothers.AHRIM);
			if (ahrim) Tasks.getSupplies().drink(PotionType.RANGED);
			Tasks.getInventory().equip(ahrim ? Constants.WEAPON_SWITCH : "Trident of the seas");

			if (ctx.players.getLocal().getInteracting() == null || ctx.players.getLocal().getInteracting() != npc
					|| !ctx.players.getLocal().inCombat())
				Tasks.getCombat().attack(npc);

		} else {
			Variables.STATUS = "Not sure";
			// Variables.STOP = true;
		}

	}

	@Override
	public int loopDuration() {
		return 60;
	}

	@Override
	public void onTerminate() {
		ctx.log("Shutting down.. Thank you for using the script");
	}

	@Override
	public void paint(Graphics Graphs) {
		Graphics2D g = (Graphics2D) Graphs;
		g.setColor(Color.BLACK);
		g.fillRect(5, 5, 200, 60);
		g.setColor(Color.GREEN);
		g.drawRect(5, 5, 200, 60);
		g.setColor(Color.CYAN);
		g.drawString("Total run time: " + Variables.START_TIME.toElapsedString(), 7, 20);
		g.drawString(String.format("%s: %s", "Status", Variables.STATUS), 7, 30);
		g.drawString(String.format("Chests: %s (%s /hr)", Variables.COUNT,
				ctx.paint.valuePerHour((int) Variables.COUNT, Variables.START_TIME.start)), 7, 45);

		g.drawString("In Area: " + ctx.pathing.inArea(Locations.BARROWS_HILLS), 7, 60);
	}

}

'''
'''--- barrow/methods/Brothers.java ---
package barrow.methods;

import java.util.Arrays;

import api.utils.Utils;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.Varbits;
import simple.hooks.filters.SimplePrayers.Prayers;
import simple.robot.api.ClientContext;
import simple.robot.utils.WorldArea;

@RequiredArgsConstructor
@Getter
public enum Brothers {

	VERAC(Utils.makeArea(3553, 3302, 3560, 3296, 0), Utils.makeArea(3567, 9711, 3582, 9701, 3), Prayers.PROTECT_FROM_MELEE,
			Varbits.BARROWS_KILLED_VERAC),
	TORAG(Utils.makeArea(3550, 3285, 3557, 3279, 0), Utils.makeArea(3563, 9692, 3576, 9681, 3), Prayers.PROTECT_FROM_MELEE,
			Varbits.BARROWS_KILLED_TORAG),
	KARIL(Utils.makeArea(3562, 3278, 3568, 3273, 0), Utils.makeArea(3543, 9689, 3558, 9677, 3), Prayers.PROTECT_FROM_MISSILES,
			Varbits.BARROWS_KILLED_KARIL),
	AHRIM(Utils.makeArea(3562, 3290, 3567, 3286, 0), Utils.makeArea(3550, 9704, 3562, 9694, 3), Prayers.PROTECT_FROM_MAGIC,
			Varbits.BARROWS_KILLED_AHRIM),
	GUTHAN(Utils.makeArea(3573, 3284, 3578, 3279, 0), Utils.makeArea(3533, 9708, 3545, 9699, 3), Prayers.PROTECT_FROM_MELEE,
			Varbits.BARROWS_KILLED_GUTHAN),
	DHAROK(Utils.makeArea(3571, 3300, 3575, 3296, 0), Utils.makeArea(3549, 9720, 3561, 9710, 3), Prayers.PROTECT_FROM_MELEE,
			Varbits.BARROWS_KILLED_DHAROK);

	private final WorldArea digArea, tunnelArea;
	private final Prayers prayer;
	private final Varbits bit;
	@Setter
	private boolean tunnel = false;

	public boolean isKilled() {
		return ClientContext.instance().varpbits.varpbit(this.bit) == 1;
	}

	public static long getTotalKilled() {
		return Arrays.stream(Brothers.values()).filter(b -> b.isKilled()).count();
	}

	public static Brothers getNextBrother() {
		for (Brothers b : Brothers.values()) {

			if (getTotalKilled() == 5 && !b.isKilled() && b.isTunnel()) return b;
			if (!b.isKilled() && !b.isTunnel()) return b;
		}
		return null;
	}

	public static Brothers getTunnelBrother() {
		long killed = Brothers.getTotalKilled();
		return Arrays.stream(Brothers.values()).filter(bro -> {
			if (killed == 5) { return bro.isTunnel() || (!bro.isTunnel() && !bro.isKilled()); }
			return bro.isTunnel();
		}).findFirst().orElse(null);
	}

	public static void update() {
		if (Brothers.getTotalKilled() == 5)
			Arrays.stream(Brothers.values()).filter(b -> !b.isKilled()).forEach(b -> b.setTunnel(true));
	}

	public static void reset() {
		Arrays.stream(Brothers.values()).forEach(b -> b.setTunnel(false));
	}

}
'''
'''--- barrow/methods/Constants.java ---
package barrow.methods;

public class Constants {

	public static String WEAPON_SWITCH = "";
}

'''
'''--- barrow/methods/ScriptUtils.java ---
package barrow.methods;

import java.util.stream.Stream;

import api.Locations;
import api.Tasks;
import api.Variables;
import barrow.Barrows;
import net.runelite.api.NPC;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;

public class ScriptUtils {

	public ClientContext ctx;

	public Barrows main;

	public ScriptUtils(ClientContext ctx, Barrows main) {
		this.ctx = ctx;
		this.main = main;
	}

	public void exitCrypt() {
		SimpleObject stairs = ctx.objects.populate().filter("Staircase").nearest().next();
		if (stairs != null && stairs.validateInteractable()) {
			stairs.click("Climb");
			ctx.sleepCondition(() -> ctx.players.getLocal().getLocation().getPlane() != 3, 500);
		}
	}

	public SimpleNpc aggressiveNPC() {
		NPC target = ctx.getClient().getHintArrowNpc();
		if (target != null) {
			SimpleNpc other = new SimpleNpc(target);
			if (other != null) return other;
		}
		return ctx.npcs.populate().filter(
				n -> n.getInteracting() != null && n.getInteracting().equals(ctx.players.getLocal().getPlayer()) && isBrother(n))
				.nearest().next();

	}

	private boolean isBrother(SimpleNpc n) {
		for (Brothers bro : Brothers.values()) {
			if (n.getName().toLowerCase().contains(bro.name().toLowerCase())) { return true; }
		}
		return false;
	}

	public void searchCoffin(String option) {
		SimpleObject coffin = ctx.objects.populate().filter("Sarcophagus", "Chest").nearest().next();
		if (coffin != null) {
			// ctx.viewport.turnTo(coffin);

			coffin.click(0);
			ctx.sleep(350, 500);
			while (ctx.pathing.inMotion()) {
				ctx.sleep(20, 40);
			}

			if (ctx.dialogue.canContinue() && ctx.dialogue.getDialogueTitleAndMessage()[1].contains("you find a hidden tunnel")) {
				Brothers b = currentBrother();
				if (b != null && Brothers.getTunnelBrother() == null) {
					b.setTunnel(true);
					ctx.log("Found current boss: %s", b.name());
				}

			}
		}
	}

	public void dig() {
		SimpleItem spade = ctx.inventory.populate().filter(952).next();
		if (spade != null) {
			spade.click("Dig");
		}
	}

	public Brothers currentBrother() {
		Brothers currentRoom = null;
		try {
			if (ctx.pathing.inArea(Locations.BARROWS_FINAL_SARCO)) { return Brothers.getTunnelBrother(); }
			currentRoom = Stream.of(Brothers.values()).filter(b -> ctx.pathing.inArea(b.getTunnelArea())).findFirst()
					.orElse(null);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return currentRoom;
	}

	public boolean checkWeapon() {
		return Tasks.getInventory().contains("Uncharged trident")
				|| Tasks.getInventory().isWearing(EquipmentSlot.WEAPON, "Uncharged trident");
	}

	public void fillStaff() {
		if (!checkWeapon()) return;
		if (!ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
			ctx.magic.castSpellOnce("Home");
			return;
		}

		int fireRune = ctx.inventory.populate().filter("Fire Rune").population(true);
		int chaosRune = ctx.inventory.populate().filter("Chaos rune").population(true);
		int deathRune = ctx.inventory.populate().filter("Death Rune").population(true);
		int coins = ctx.inventory.populate().filter("Coins").population(true);

		if (fireRune < 100 || chaosRune < 100 || deathRune < 100 || coins < 1000) {
			Variables.STATUS = "Grabbing supplies from bank";
			if (Tasks.getBanking().open()) {
				ctx.bank.withdraw("Fire Rune", 12495 - fireRune);
				ctx.bank.withdraw("Chaos Rune", 2499 - chaosRune);
				ctx.bank.withdraw("Death Rune", 2499 - deathRune);
				ctx.bank.withdraw("Coins", 24990 - coins);
			}
		} else if (!Tasks.getInventory().contains("Uncharged trident")
				&& Tasks.getInventory().isWearing(EquipmentSlot.WEAPON, "Uncharged trident")) {
					ctx.bank.closeBank();
					Variables.STATUS = "Unequipping staff";
					SimpleItem staff = ctx.equipment.populate().filter("Uncharged trident").next();
					if (staff != null) staff.click(0);
				} else {
					SimpleItem invStaff = Tasks.getInventory().getItem("Uncharged trident");
					SimpleItem coin = Tasks.getInventory().getItem("Coins");
					if (invStaff != null && coin != null) {
						if (ctx.dialogue.pendingInput()) {
							ctx.keyboard.sendKeys("2499", true);
							return;
						}
						coin.click("Use");
						ctx.sleep(150);
						invStaff.click(0);
						ctx.sleepCondition(() -> ctx.dialogue.pendingInput(), 1500);
					} else {
						Variables.STATUS = "NO";
					}
				}

	}

}

'''
'''--- blastfurnace/Core.java ---
package blastfurnace;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import api.Locations;
import api.MenuActions;
import api.Tasks;
import api.Variables;
import api.utils.Timer;
import api.utils.Utils;
import blastfurnace.data.Ore;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ItemID;
import net.runelite.api.MenuAction;
import net.runelite.api.Varbits;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.script.Script;

@ScriptManifest(author = "KremeSickle", category = Category.SMITHING, description = "Does blast furnace", name = "Blast furnace", servers = {
		"Zaros" }, version = "0.1", discord = "")

public class Core extends Script implements LoopingScript {

	// upstairs [ region-11679 stairs-9084 ]
	// downstairs [ region-7757 stairs-9138]
	// Bar dispense
	// Converyor - 9100

	boolean goldgaunts, bucket, teleport, stamina, iceglove, coffer, coalbag;

	Ore ore = Ore.RUNITE_BAR;

	@Override
	public void onExecute() {
		Tasks.init(ctx);
		Variables.STOP = false;
		goldgaunts = false;
		bucket = false;
		teleport = false;
		stamina = true;
		iceglove = true;
		coffer = false;
		coalbag = true;

		if (coalbag && ore.getSecondaryOre() != ItemID.COAL) coalbag = false;
		if (goldgaunts && ore != Ore.GOLD_BAR) goldgaunts = false;

		full = ore.getBars() > 0;
	}

	boolean full;
	boolean COALBAG_FULL = false;

	@Override
	public void onProcess() {

		if (Variables.STOP) return;
		if (!ctx.pathing.inArea(Locations.EDGEVILLE_AREA) && Tasks.getAntiban().staffNearby()) {
			System.out.println("Staff found at " + ctx.players.getLocal().getLocation());
			Variables.STOP = true;
			return;
		}
		if (ctx.players.getLocal().getLocation().getRegionID() == 11679) {
			// ctx.viewport.angle(58);
			SimpleObject stairs = ctx.objects.populate().filter(9084).nearest().next();
			if (Tasks.getMenuAction().get(stairs, "Climb-down").setWidget(52).invoke())
				// if (stairs != null /* && stairs.validateInteractable() */ &&
				// MenuActions.invoke(m))
				ctx.onCondition(() -> ctx.players.getLocal().getLocation().getRegionID() == 7757);
		} else if (ctx.players.getLocal().getLocation().getRegionID() == 7757) {
			if (!ctx.pathing.running() && ctx.pathing.energyLevel() > 10) ctx.pathing.running(true);

			if (getCoffer() <= 5000) {
				fillCoffer();
				return;
			}

			if (shouldStamina()) {
				drinkStamina();
				return;
			}

			if (!full) {
				full = isFull();
				if (full) return;

				while (!handleCoalBag(false))
					return;

				if (ctx.inventory.populate().filter(ore.getSecondaryOre()).population() < 27) {
					Variables.STATUS = "Retrieving secondary ore";
					if (!withdrawBucket()) return;
					withdraw(ore.getSecondaryOre(), 27, ItemID.BUCKET);
				} else {
					Variables.STATUS = "Depositing secondary ore";
					deposit(true);
				}
			} else {
				if (ore.getSecondary() < 10 && ore.getBars() == 0) full = false;

				if (pendingBars() == 2 || pendingBars() == 3) {
					Variables.STATUS = "Retrieving bars";
					retrieve();
				} else if (ctx.inventory.populate().filter(ore.getPrimaryOre()).isEmpty()) {
					Variables.STATUS = "Retrieving primary ore";
					if (!withdrawBucket()) return;

					withdraw(ore.getPrimaryOre(), 27, ItemID.BUCKET, ItemID.BUCKET_OF_WATER);
				} else {
					Variables.STATUS = "Depositing primary ore";
					if (deposit(false)) cool();
				}
			}
		}
	}

	public boolean deposit(boolean coal) {
		SimpleObject convey = ctx.objects.populate().filter(9100).nearest().next();

		if (convey == null) {
			Variables.STATUS = "Unable to find Conveyor";
			return false;
		}

		if (ctx.pathing.distanceTo(convey.getLocation()) > 8) {
			ctx.pathing.step(new WorldPoint(1942, 4967, 0));
			ctx.onCondition(() -> ctx.pathing.distanceTo(convey.getLocation()) < 5);
			return false;
		}
		if (Tasks.getMenuAction().get(convey, "Put-ore-on").invoke()) {
			/*
			 * if (/*convey.validateInteractable() &&
			 * convey.click("Put-ore-on")) {
			 */
			ctx.onCondition(() -> ctx.inventory.populate().population() < 20, 2500);

			while (coal && !handleCoalBag(true))
				return false;

			return true;
		}
		return false;
	}

	public boolean withdraw(int id, int amt, int... ignore) {
		if (openBank(id == ItemID.COAL)) {
			if (!ctx.inventory.populate().isEmpty()) {
				ctx.bank.depositAllExcept(id, ItemID.GOLDSMITH_GAUNTLETS, ItemID.BUCKET_OF_WATER, ItemID.ICE_GLOVES,
						ItemID.COAL_BAG_12019);
			}
			SimpleItem item = ctx.bank.populate().filter(id).next();
			if (item != null && !Tasks.getBanking().withdrawItem(item.getName(), amt)) return false;
			ctx.sleepCondition(() -> !ctx.inventory.populate().isEmpty(), 250);
			return true;
		}
		return false;
	}

	public boolean cool() {
		if (pendingBars() == 3) return true;
		SimpleObject dispenser = ctx.objects.populate().filter("Bar dispenser").filter(new WorldPoint(1940, 4963, 0)).next();
		if (bucket && withdrawBucket()) {
			if (dispenser != null && dispenser.validateInteractable()) {
				SimpleItem bucket = ctx.inventory.populate().filter(ItemID.BUCKET_OF_WATER).next();
				if (bucket == null) return true;

				if (ctx.inventory.itemSelectionState() == 0) bucket.click(0);
				if (dispenser.click(0)) {
					ctx.onCondition(() -> pendingBars() == 3);
					return pendingBars() == 3;
				}
			}
		} else if (iceglove) {
			ctx.sleepCondition(() -> pendingBars() >= 2, 5000);
			return equip(ItemID.ICE_GLOVES);
		} else if (teleport) {
			if (!Utils.directTeleport("Blast Furnace") && Tasks.getTeleporter().open())
				Tasks.getTeleporter().teleportStringPath("Minigames", "Blast Furnace");
			return true;
		}
		return false;
	}

	public boolean openBank(boolean preset) {
		if (!preset && ctx.bank.bankOpen()) return true;
		if (preset) ctx.bank.closeBank();

		if (preset) return Tasks.getBanking().usePreset();
		else Tasks.getBanking().open();

		ctx.sleepCondition(() -> preset ? ctx.inventory.inventoryFull() : ctx.bank.bankOpen(), 2000);
		/*
		 * SimpleObject bank =
		 * ctx.objects.populate().filter(26707).nearest().next(); if (bank !=
		 * null && bank.validateInteractable()) { if
		 * (ctx.inventory.itemSelectionState() == 1)
		 * ctx.inventory.populate().next().click(0); bank.click(preset ?
		 * "Last-preset" : "Use"); ctx.sleepCondition(() -> preset ?
		 * ctx.inventory.inventoryFull() : ctx.bank.bankOpen(), 2000); }
		 */
		return ctx.bank.bankOpen();
	}

	WorldPoint banktile = new WorldPoint(1948, 4957, 0);

	public boolean shouldStamina() {
		if (ctx.pathing.distanceTo(banktile) > 3) return false;
		return stamina && !staminaTimer.isRunning() && ctx.pathing.energyLevel() < 30;
	}

	private Timer staminaTimer = new Timer(1);

	private final Pattern STAMINA_POTION = Pattern.compile("Stamina potion(.*)");

	public void drinkStamina() {
		SimpleItem staminaPot = ctx.inventory.populate().filter(STAMINA_POTION).next();
		if (staminaPot == null) {
			if (openBank(false)) {
				ctx.bank.depositInventory();
				Tasks.getBanking().withdrawItem("Stamina potion", 1);
				/*
				 * SimpleItem potion =
				 * ctx.bank.populate().filter(STAMINA_POTION).next(); if (potion
				 * == null) { stamina = false; return; } if
				 * (Tasks.getBanking().withdrawItem(potion.getName(), 1+""))
				 * ctx.sleepCondition(() ->
				 * ctx.inventory.populate().contains(potion), 500);
				 */

			}
		} else {
			if (ctx.bank.bankOpen()) ctx.bank.closeBank();
			while (ctx.pathing.energyLevel() < 80) {
				staminaPot = ctx.inventory.populate().filter(STAMINA_POTION).next();
				if (staminaPot != null) staminaPot.click(0);
				else break;
				ctx.sleep(150, 400);
			}
			staminaTimer = new Timer(TimeUnit.MINUTES.toMillis(1));
		}
	}

	public boolean isFull() {
		if (ore.getSecondaryOre() == ItemID.COAL) return ore.getSecondary() >= 250;
		return ore.getSecondary() >= 50 || (ore == Ore.GOLD_BAR && ore.getBars() >= 50);
	}

	public void retrieve() {
		if (!cool()) return;

		int population = ctx.inventory.populate().filter(ore.getBarName()).population();

		if (population > 0 || ctx.inventory.populate().population() > 1) {
			if (openBank(false)) ctx.bank.depositInventory();
		} else {
			SimpleObject dispenser = ctx.objects.populate().filter(new WorldPoint(1940, 4963, 0)).next();

			if (dispenser != null) { /*
										 * && dispenser.validateInteractable())
										 * {
										 */
				if (dispenser.distanceTo(ctx.players.getLocal()) > 4) {
					ctx.pathing.step(new WorldPoint(1940, 4962, 0));
					return;
				}
				if (ctx.dialogue.dialogueOpen()) {
					String body = ctx.dialogue.getDialogueTitleAndMessage()[1];
					if (body != null && body.contains("ou just recently")) {
						Variables.STATUS = "Still cookin";
						return;
					}
				}

				SimpleWidget BAR = ctx.widgets.getWidget(270, 14);

				if (goldgaunts) equip(ItemID.GOLDSMITH_GAUNTLETS);

				if (Utils.validWidget(BAR)) {
					if (BAR.click(0)) ctx.sleepCondition(() -> !ctx.dialogue.dialogueOpen());
				} else {

					LocalPoint loc = dispenser.getTileObject().getLocalLocation();
					if (MenuActions.invoke("", "", 52, MenuAction.GAME_OBJECT_FIRST_OPTION.getId(), 9092, loc.getSceneY()))
						ctx.onCondition(() -> Utils.validWidget(ctx.widgets.getWidget(270, 14)));
				}
			}
		}
	}

	public boolean equip(int itemId) {
		SimpleItem item = ctx.inventory.populate().filter(itemId).next();
		if (item == null || !ctx.equipment.populate().contains(item)) return true;
		if (item.click(0)) ctx.onCondition(() -> !ctx.equipment.filter(ItemID.GOLDSMITH_GAUNTLETS).isEmpty());
		return true;
	}

	public boolean withdrawBucket() {
		if (!bucket) return true;
		SimpleItem bucket = ctx.inventory.populate().filter(ItemID.BUCKET_OF_WATER, ItemID.BUCKET).next();

		if (bucket == null) {
			Variables.STATUS = "Withdrawing bucket";
			if (!withdraw(ItemID.BUCKET_OF_WATER, 1)) withdraw(ItemID.BUCKET, 1);
		} else if (bucket.getId() == ItemID.BUCKET) {
			fillBucket();
		}
		return bucket.getId() == ItemID.BUCKET_OF_WATER;
	}

	public void fillBucket() {
		ctx.bank.closeBank();
		SimpleObject sink = ctx.objects.populate().filter("Sink").next();

		if (sink != null && sink.validateInteractable() && sink.click("Fill-bucket"))
			ctx.onCondition(() -> !ctx.inventory.populate().filter(ItemID.BUCKET_OF_WATER).isEmpty());
	}

	public int pendingBars() {
		int step = ctx.varpbits.varpbit(Varbits.BAR_DISPENSER);
		if (step == 2 && !ctx.equipment.filter(ItemID.ICE_GLOVES).isEmpty()) return 3;
		return step;
	}

	public int getCoffer() {
		return ctx.varpbits.varpbit(Varbits.BLAST_FURNACE_COFFER);
	}

	public void fillCoffer() {
		if (!coffer) {
			Variables.STATUS = "Coffer is out";
			return;
		}
		Variables.STATUS = "Need to refill coffer";

	}

	public boolean handleCoalBag(boolean empty) {
		SimpleItem bag = ctx.inventory.populate().filter(ItemID.COAL_BAG_12019).next();
		if (bag == null) return true;
		if (!coalbag || ore.getSecondaryOre() != ItemID.COAL) return true;

		if (!empty && COALBAG_FULL) return true;

		if (empty && !COALBAG_FULL) return true;

		if (empty) {
			Variables.STATUS = "Emptying coal bag";
			if (Tasks.getMenuAction().get(bag, "Empty").invoke()) {
				ctx.onCondition(
						() -> ctx.dialogue.dialogueOpen() || ctx.inventory.populate().filter(ItemID.COAL).population() > 0);
				if (ctx.dialogue.dialogueOpen()) COALBAG_FULL = false;

			}

			return !COALBAG_FULL;
		} else {
			ctx.bank.closeBank();
			Variables.STATUS = "Filling coal bag";
			if (ctx.inventory.populate().filter(ore.getSecondaryOre()).isEmpty())
				withdraw(ore.getSecondaryOre(), 27, ore.getSecondaryOre(), ItemID.COAL_BAG_12019);
			else if (Tasks.getMenuAction().get(bag, "Fill").invoke()) {
				ctx.onCondition(() -> ctx.dialogue.dialogueOpen() || !ctx.inventory.inventoryFull());

				if (ctx.dialogue.dialogueOpen()) COALBAG_FULL = true;
			}

			return COALBAG_FULL;
		}
	}

	@Override
	public void paint(Graphics Graphs) {
		Graphics2D g = (Graphics2D) Graphs;
		g.setColor(Color.BLACK);
		g.fillRect(5, 5, 200, 75);
		g.setColor(Color.GREEN);
		g.drawRect(5, 5, 200, 75);
		g.setColor(Color.CYAN);
		g.drawString("Total run time: " + Variables.START_TIME.toElapsedString(), 7, 20);
		g.drawString("Status: " + Variables.STATUS, 7, 35);
		g.drawString("Primary: " + ore.getOres(), 7, 50);
		g.drawString("Secondary: " + ore.getSecondary(), 7, 65);
		g.drawString("Bars: " + ore.getBars(), 7, 80);
		g.drawString("Coal Bag: " + COALBAG_FULL, 7, 95);
		g.drawString("STAMINA: " + staminaTimer.getRemaining(), 7, 108);

	}

	final String[] STOP_MESSAGES = { "be found:", "you are dead" };

	@Override
	public void onChatMessage(ChatMessage msg) {
		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			if (!Variables.STOP) {
				Variables.STOP = Stream.of(STOP_MESSAGES).anyMatch(msg1 -> msg.getMessage().contains(msg1));
			}
		}
	}

	@Override
	public int loopDuration() {
		// TODO Auto-generated method stub
		return 150;
	}

	@Override
	public void onTerminate() {
		// TODO Auto-generated method stub

	}

}

'''
'''--- blastfurnace/data/Ore.java ---
package blastfurnace.data;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;
import net.runelite.api.Varbits;
import simple.robot.api.ClientContext;

@RequiredArgsConstructor
@Getter
public enum Ore {

	BRONZE_BAR("Bronze bar", new int[] { ItemID.TIN_ORE, ItemID.COPPER_ORE }, Varbits.BLAST_FURNACE_TIN_ORE,
			Varbits.BLAST_FURNACE_COPPER_ORE, Varbits.BLAST_FURNACE_BRONZE_BAR),
	IRON_BAR("Iron bar", new int[] { ItemID.IRON_ORE, ItemID.IRON_ORE }, Varbits.BLAST_FURNACE_IRON_ORE,
			Varbits.BLAST_FURNACE_IRON_ORE, Varbits.BLAST_FURNACE_IRON_BAR),
	STEEL_BAR("Steel bar", new int[] { ItemID.IRON_ORE, ItemID.COAL }, Varbits.BLAST_FURNACE_IRON_ORE, Varbits.BLAST_FURNACE_COAL,
			Varbits.BLAST_FURNACE_IRON_BAR),
	GOLD_BAR("Gold bar", new int[] { ItemID.GOLD_ORE, ItemID.GOLD_ORE }, Varbits.BLAST_FURNACE_GOLD_ORE,
			Varbits.BLAST_FURNACE_GOLD_ORE, Varbits.BLAST_FURNACE_GOLD_BAR),
	MITHRIL_BAR("Mithril bar", new int[] { ItemID.MITHRIL_ORE, ItemID.COAL }, Varbits.BLAST_FURNACE_MITHRIL_ORE,
			Varbits.BLAST_FURNACE_COAL, Varbits.BLAST_FURNACE_MITHRIL_BAR),
	ADAMANTITE_BAR("Adamantite bar", new int[] { ItemID.ADAMANTITE_ORE, ItemID.COAL }, Varbits.BLAST_FURNACE_ADAMANTITE_ORE,
			Varbits.BLAST_FURNACE_COAL, Varbits.BLAST_FURNACE_ADAMANTITE_BAR),
	RUNITE_BAR("Runite bar", new int[] { ItemID.RUNITE_ORE, ItemID.COAL }, Varbits.BLAST_FURNACE_RUNITE_ORE,
			Varbits.BLAST_FURNACE_COAL, Varbits.BLAST_FURNACE_RUNITE_BAR),

	;

	private final ClientContext ctx = ClientContext.instance();

	private final String barName;
	private final int[] oreId;
	private final Varbits oreVarb, oreSVarb, barVarb;

	public int getPrimaryOre() {
		return oreId[0];
	}

	public int getSecondaryOre() {
		return oreId[1];
	}

	public int getOres() {
		return ctx.varpbits.varpbit(oreVarb);
	}

	public int getBars() {
		return ctx.varpbits.varpbit(barVarb);
	}

	public int getSecondary() {
		return ctx.varpbits.varpbit(oreSVarb);
	}

}

'''
'''--- combat/Core.java ---
package combat;

import java.awt.Graphics;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import api.Locations;
import api.Tasks;
import api.Variables;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ItemID;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Combat.Style;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.robot.script.Script;

@ScriptManifest(author = "KremeSickle", category = Category.COMBAT, description = "Combat", discord = "", name = "Combat", servers = {
		"Zaros" }, version = "2")
public class Core extends Script implements LoopingScript {
	final String[] STOP_MESSAGES = { "be found: prayer potion", "be found: shark", "you are dead" };

	@Getter
	public class Task {
		private Skills skill;
		private int level;
		private Style style;

		public Task(Skills skill, int level) {
			this.skill = skill;
			this.level = level;
			this.style = skill == Skills.ATTACK ? Style.ACCURATE : skill == Skills.DEFENCE ? Style.DEFENSIVE : Style.AGGRESSIVE;
		}
	}

	private List<Task> tasks = new ArrayList<Task>();

	@Override
	public void onChatMessage(ChatMessage msg) {

		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			if (!Variables.STOP) {
				Variables.STOP = Stream.of(STOP_MESSAGES).anyMatch(msg1 -> msg.getMessage().contains(msg1));
			}

			if (msg.getMessage().contains("rune runes to cast")) {
				tasks.removeIf(task -> task.getSkill() == Skills.MAGIC);
			}

			if (msg.getMessage().contains("enough ammo")) {
				tasks.removeIf(task -> task.getSkill() == Skills.RANGED);
			}
		}
	}

	@Override
	public void onExecute() {
		Tasks.init(ctx);
		tasks.clear();

		setTasks();

		tasks = tasks.stream().filter(task -> ctx.skills.level(task.getSkill()) < task.getLevel()).collect(Collectors.toList());

		Variables.STARTED = true;
	}

	public void setTasks() {
		tasks.add(new Task(Skills.STRENGTH, 20));
		tasks.add(new Task(Skills.ATTACK, 40));
		tasks.add(new Task(Skills.DEFENCE, 55));
		tasks.add(new Task(Skills.STRENGTH, 70));
		tasks.add(new Task(Skills.ATTACK, 70));
		tasks.add(new Task(Skills.DEFENCE, 70));
		tasks.add(new Task(Skills.STRENGTH, 95));
		tasks.add(new Task(Skills.ATTACK, 95));
		tasks.add(new Task(Skills.DEFENCE, 90));
		if (ranging) tasks.add(new Task(Skills.RANGED, 70));

		if (maging) tasks.add(new Task(Skills.MAGIC, 99));

		tasks.add(new Task(Skills.STRENGTH, 99));
		tasks.add(new Task(Skills.ATTACK, 99));
		tasks.add(new Task(Skills.DEFENCE, 99));
		tasks.add(new Task(Skills.RANGED, 99));

	}

	boolean ranging = true;
	boolean maging = true;

	@Override
	public void onProcess() {

		if (!ctx.pathing.inArea(Locations.EDGEVILLE_AREA) && Tasks.getAntiban().staffNearby()) {
			System.out.println("Staff found at " + ctx.players.getLocal().getLocation());
			Variables.STOP = true;
			return;
		}

		if (tasks.size() == 0) {
			Variables.STOP = true;
			return;
		}

		Task task = tasks.get(0);

		if (ctx.skills.level(task.getSkill()) >= task.getLevel()) {
			tasks.remove(0);
			return;
		}
		if (task.getSkill() != Skills.MAGIC) ctx.combat.style(task.getStyle());

		if (Tasks.getSkill().getPercentage(Skills.HITPOINTS) < 20) Tasks.getSupplies().eat();

		if (!equipGear(task)) return;

		SimpleNpc yak = Tasks.getCombat().getNPC("Yak");
		if (yak != null) {
			if (task.getSkill() == Skills.MAGIC) useSpell(yak);
			else if (ctx.players.getLocal().getInteracting() == null) Tasks.getCombat().attack(yak);
		}
	}

	public boolean equipGear(Task task) {
		int attackLvl = ctx.skills.level(Skills.ATTACK);
		int strLvl = ctx.skills.level(Skills.STRENGTH);
		int defLvl = ctx.skills.level(Skills.DEFENCE);
		int ranged = ctx.skills.level(Skills.RANGED);
		int magic = ctx.skills.level(Skills.MAGIC);

		if (task.getSkill() == Skills.RANGED) {
			int weapon = ranged >= 50 ? ItemID.MAGIC_SHORTBOW : ItemID.SHORTBOW;
			if (ctx.equipment.populate().filter(weapon).population() == 0) {
				SimpleItem scim = ctx.inventory.populate().filter(weapon).next();
				if (scim != null) {
					scim.click(0);
					ctx.sleep(250, 450);
					return false;
				}
			}
			if (ranged >= 70) {
				SimpleItem hide = ctx.inventory.populate().filter(item -> item.getName().contains("lack d'")).next();
				if (hide != null) {
					hide.click(0);
					ctx.sleep(250, 450);
					return false;
				}
			}
		} else if (task.getSkill() == Skills.MAGIC) {
			SimpleItem item = Tasks.getInventory().getItem("full helm", "platebody", "plateleg", "staff", "vamb", "kiteshield");
			if (item != null) {
				item.click(0);
				ctx.sleep(250, 450);
				return false;
			}
			SimpleItem amulet = ctx.equipment.populate().filter("Amulet of glory").next();
			if (amulet != null) {
				amulet.click(0);
				ctx.sleep(250, 450);
				return false;
			}
		} else {
			int weapon = /*
							 * attackLvl >= 70 ? ItemID.ABYSSAL_WHIP :
							 */ attackLvl >= 60 ? ItemID.DRAGON_SCIMITAR
					: attackLvl >= 40 ? ItemID.RUNE_SCIMITAR : ItemID.IRON_SCIMITAR;

			if (ctx.equipment.populate().filter(weapon).population() == 0) {
				SimpleItem scim = ctx.inventory.populate().filter(weapon).next();
				if (scim != null) {
					scim.click(0);
					ctx.sleep(250, 450);
					return false;
				}
			}
		}
		return true;
	}

	public void useSpell(SimpleNpc npc) {
		int lvl = ctx.skills.level(Skills.MAGIC);
		if (lvl < 21) {
			ctx.magic.castSpellOnNPC("Wind strike", npc);
			ctx.onCondition(() -> ctx.players.getLocal().getAnimation() != -1);
		} else if (lvl < 66) {
			SimpleItem fire = Tasks.getInventory().getItem("Mind rune");
			if (fire != null) ctx.magic.castSpellOnItem(lvl < 55 ? "Low Level Alchemy" : "High Level Alchemy", fire.getId());
			ctx.onCondition(() -> ctx.players.getLocal().getAnimation() != -1);
		} else {
			String spell = lvl >= 80 ? "Stun" : lvl >= 73 ? "Enfeeble" : "Vulnerability";
			ctx.magic.castSpellOnNPC(spell, npc);
			ctx.onCondition(() -> ctx.players.getLocal().getAnimation() != -1);
		}
	}

	@Override
	public int loopDuration() {
		return 150;
	}

	@Override
	public void onTerminate() {
		Variables.reset();
		ctx.log("Shutting down.. Thank you for using the script");
	}

	@Override
	public void paint(Graphics Graphs) {

	}

}

'''
'''--- combat/Inferno.java ---
package combat;

import java.awt.Graphics;

import api.Tasks;
import api.Variables;
import net.runelite.api.ChatMessageType;
import net.runelite.api.NpcID;
import simple.hooks.queries.SimpleEntityQuery;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleNpc;
import simple.robot.script.Script;

@ScriptManifest(author = "KremeSickle", category = Category.COMBAT, description = "Inferno", discord = "", name = "Inferno", servers = {
		"Zaros" }, version = "2")
public class Inferno extends Script {
	final String[] STOP_MESSAGES = { "be found: prayer potion", "be found: shark", "you are dead" };

	@Override
	public void onChatMessage(ChatMessage msg) {

		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			if (!Variables.STOP) {
				// Variables.STOP = Stream.of(STOP_MESSAGES).anyMatch(msg1 ->
				// msg.getMessage().contains(msg1));
			}

		}
	}

	@Override
	public void onExecute() {
		Tasks.init(ctx);
		Variables.STARTED = true;
	}

	@Override
	public void onProcess() {

		if (!ctx.getClient().isInInstancedRegion()) return;

		SimpleNpc ZUK = Tasks.getCombat().getNPC(7706);

		if (ZUK != null) {
			if (activeHealers()) attackHealer();
			else if (!isFightingJad()) Tasks.getCombat().attack(ZUK);

		} else {
			SimpleNpc JAD = Tasks.getCombat().getNPC(7700);
			if (JAD == null) return;
			if (activeHealers()) {
				attackHealer();
			} else if (!isFightingJad()) Tasks.getCombat().attack(JAD);
		}
	}

	private boolean isFightingJad() {
		if (ctx.players.getLocal().getInteracting() != null && ctx.players.getLocal().getInteracting().getName() != null) {
			// ctx.log("name: " +
			// ctx.players.getLocal().getInteracting().getName());
			String name = ctx.players.getLocal().getInteracting().getName().toLowerCase();
			return name.contains("jad") || name.contains("zuk");
		}
		return false;
	}

	private boolean activeHealers() {

		SimpleEntityQuery<SimpleNpc> healers = ctx.npcs.populate().filter(3128, NpcID.JALMEJJAK, NpcID.YTHURKOT_7705);
		for (SimpleNpc healer : healers) {
			if (healer.getInteracting() != null && healer.getInteracting().getName() != null
					&& !healer.getInteracting().getName().equals(ctx.players.getLocal().getName())) {
				return true;
			}
		}
		return false;
	}

	private void attackHealer() {

		SimpleNpc healer = ctx.npcs.populate().filter(3128, NpcID.JALMEJJAK, NpcID.YTHURKOT_7705)
				.filter(h -> h.getInteracting() != null && h.getInteracting().getName() != null
						&& !h.getInteracting().getName().equals(ctx.players.getLocal().getName()))
				.nearest().next();
		if (healer != null) {
			Tasks.getCombat().attack(healer);
		}
	}

	@Override
	public void onTerminate() {
		Variables.reset();
		ctx.log("Shutting down.. Thank you for using the script");
	}

	@Override
	public void paint(Graphics Graphs) {

	}

}

'''
'''--- combat/dragons/Dragons.java ---
package combat.dragons;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.util.Arrays;
import java.util.stream.Stream;

import api.Locations;
import api.Tasks;
import api.Variables;
import api.simple.KSObject;
import api.tasks.Supplies.PotionType;
import api.threads.PrayerObserver;
import api.utils.Timer;
import api.utils.Utils;
import combat.dragons.data.Constants;
import combat.dragons.data.Constants.TYPES;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimplePrayers.Prayers;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.robot.script.Script;
import simple.robot.utils.WorldArea;

@ScriptManifest(author = "KremeSickle", category = Category.COMBAT, description = "Rune Dragons", discord = "", name = "KS | Rune Dragons", servers = {
		"Zaros" }, version = "2")
public class Dragons extends Script implements LoopingScript {
	final String[] STOP_MESSAGES = { "be found:", "enough ammo", "you are dead" };

	private PrayerObserver prayerObserver = null;

	@Override
	public void onChatMessage(ChatMessage msg) {
		Variables.LAST_MESSAGE = msg.getMessage();
		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			if (msg.getMessage().contains("antifire potion has expired")) {
				Tasks.getSupplies().antiFire = new Timer(1);
			}
			if (!Variables.STOP) {
				Variables.STOP = Stream.of(STOP_MESSAGES).anyMatch(msg1 -> msg.getMessage().contains(msg1));
			}
		}
	}

	@Override
	public void onExecute() {
		Tasks.init(ctx);

		Constants.TYPE = TYPES.RUNE_DRAGON;

		Tasks.getSkill().addPrayer(Prayers.PROTECT_FROM_MAGIC);
		Tasks.getSkill().addPrayer(Prayers.PIETY);

		Variables.LOOTABLES.clear();
		Variables.LOOTABLES.addAll(Arrays.asList("Runite", "platebody", "longsword", "scimitar", "platelegs", "plateskirt",
				"Dragon bolts", "Runite bolts", "Rune javelin", "Brimstone", "limbs", "lump", "Draconic"));
		System.out.println("Loaded " + Variables.LOOTABLES.size() + " lootable items");

		prayerObserver = new PrayerObserver(ctx, () -> Variables.USE_PRAYER);
		prayerObserver.start();

		Variables.STARTED = true;
	}

	@Override
	public void onProcess() {

		if (Variables.STOP) {
			Tasks.getAntiban().panic();
			return;
		}

		if (Tasks.getAntiban().check()) {
			Variables.STOP = true;
			return;
		}

		if (ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
			Tasks.getSkill().disablePrayers();
			if (!Tasks.getBanking().heal()) return;
			if (!Tasks.getBanking().usePreset()) return;
			if (!Utils.directTeleport("Adamant & Rune Dragons") && Tasks.getTeleporter().open())
				Tasks.getTeleporter().teleportStringPath("Monsters", "Adamant & Rune Dragons");

		} else if (ctx.pathing.inArea(getLocation())) {
			Tasks.getSkill().enablePrayers();
			if (Tasks.getLoot().loot(Variables.LOOTABLES)) return;
			if (!Tasks.getSupplies().hasFood() || !Tasks.getSupplies().hasPrayer()) {

				ctx.magic.castSpellOnce("Home Teleport");
				return;
			}

			Tasks.getCombat().checkPots();

			if (!Tasks.getSupplies().antiFire.isRunning()) Tasks.getSupplies().drink(PotionType.ANTIFIRE);

			SimpleItem bones = Tasks.getInventory().getItem("dragon bones");
			if (bones != null) bones.click(0);

			SimpleNpc aggr = Tasks.getCombat().getAggressiveNPC(getMonster());
			if (aggr != null && aggr.distanceTo(ctx.players.getLocal()) < 6 && false) {
				Variables.STATUS = "Moving away from dragon";
				WorldPoint npcLocation = aggr.getLocation();

				WorldPoint north = new WorldPoint(npcLocation.getX() + 7, npcLocation.getY(), 0);
				WorldPoint south = new WorldPoint(npcLocation.getX() - 7, npcLocation.getY(), 0);
				WorldPoint east = new WorldPoint(npcLocation.getX(), npcLocation.getY() + 7, 0);
				WorldPoint west = new WorldPoint(npcLocation.getX(), npcLocation.getY() - 7, 0);

				if (ctx.pathing.reachable(north)) ctx.pathing.step(north);
				else if (ctx.pathing.reachable(south)) ctx.pathing.step(south);
				else if (ctx.pathing.reachable(east)) ctx.pathing.step(east);
				else if (ctx.pathing.reachable(west)) ctx.pathing.step(west);
			}
			if (ctx.players.getLocal().getInteracting() == null) Tasks.getCombat().attack(getMonster());
			else Variables.STATUS = "In combat";
		} else if (ctx.pathing.inArea(Constants.DRAGON_LOBBY_AREA)) {
			KSObject gate = new KSObject(ctx.objects.populate().filter(getGate()).nearest().next());
			if (gate.isNull()) return;
			if (gate.distanceTo(ctx.players.getLocal()) > 2) {
				Variables.STATUS = "Walking to gate";
				if (ctx.pathing.step(gate.getLocation())) ctx.onCondition(() -> !ctx.pathing.inMotion());
			} else if (gate.validateInteractable()) {
				Variables.STATUS = "Going through gate";
				if (gate.click(Variables.USE_PACKETS ? "Pass" : null)) ctx.onCondition(() -> ctx.pathing.inArea(getLocation()));
			}
		}

	}

	public String getMonster() {
		return Constants.TYPE.equals(TYPES.ADAMANT_DRAGON) ? "Adamant dragon" : "Rune dragon";
	}

	public WorldArea getLocation() {
		return Constants.TYPE.equals(TYPES.ADAMANT_DRAGON) ? Constants.ADAMANT_DRAGON_AREA : Constants.RUNE_DRAGON_AREA;
	}

	public WorldPoint getGate() {
		return Constants.TYPE.equals(TYPES.ADAMANT_DRAGON) ? Constants.ADAMANT_GATE_LOCATION : Constants.RUNE_GATE_LOCATION;
	}

	@Override
	public int loopDuration() {
		return 150;
	}

	@Override
	public void onTerminate() {
		ctx.log("Shutting down.. Thank you for using the script");
		Variables.reset();
	}

	@Override
	public void paint(Graphics Graphs) {
		if (!Variables.STARTED) return;
		Graphics2D g = (Graphics2D) Graphs;
		g.setColor(Color.BLACK);
		g.fillRect(5, 5, 200, 40);
		g.setColor(Color.GREEN);
		g.drawRect(5, 5, 200, 40);
		g.setColor(Color.CYAN);
		g.drawString("Uptime: " + Variables.START_TIME.toElapsedString(), 7, 20);
		g.drawString("Status: " + Variables.STATUS, 7, 35);
	}

}

'''
'''--- combat/dragons/data/Constants.java ---
package combat.dragons.data;

import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

public class Constants {
	public final static WorldArea DRAGON_LOBBY_AREA = new WorldArea(new WorldPoint(1536, 5090, 0), new WorldPoint(1605, 5056, 0));

	public final static WorldPoint RUNE_GATE_LOCATION = new WorldPoint(1574, 5074, 0);
	public final static WorldArea RUNE_DRAGON_AREA = new WorldArea(new WorldPoint(1574, 5085, 0), new WorldPoint(1599, 5061, 0));

	public final static WorldPoint ADAMANT_GATE_LOCATION = new WorldPoint(1561, 5073, 0);
	public final static WorldArea ADAMANT_DRAGON_AREA = new WorldArea(new WorldPoint(1561, 5061, 0),
			new WorldPoint(1538, 5087, 0));

	public static TYPES TYPE;

	public enum TYPES {
		RUNE_DRAGON,
		ADAMANT_DRAGON
	}

}

'''
'''--- combat/fastslayer/Core.java ---
package combat.fastslayer;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.util.Arrays;
import java.util.stream.Stream;

import api.Tasks;
import api.Variables;
import combat.fastslayer.data.Constants;
import combat.fastslayer.data.SlayerTask;
import combat.fastslayer.methods.Methods;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.teleporter.Teleporter;
import simple.robot.script.Script;

@ScriptManifest(author = "Trester/Steganos", category = Category.SLAYER, description = "Does slayer", name = "Slayer", servers = {
		"Zaros" }, version = "0.1", discord = "")

public class Core extends Script {
	// You're assigned to kill Ankou; only 1 more to go.
	// Nieve wants you to stick to your Slayer assignments in this area.
	// You've completed one task and received 30 points

	@Getter
	private Teleporter teleport;

	@Getter
	private Methods methods;

	@Override
	public void onExecute() {
		Tasks.init(ctx);
		resetVariables();
		teleport = new Teleporter(ctx);
		methods = new Methods(ctx, this);
		resetVariables();

		Constants.SKIP_TASKS.addAll(Arrays.asList("dragon", "gargoyles", "kalphite", "aberrant spectre", "banshee", "wall beast",
				"black demon", "cave horror"));
	}

	public void resetVariables() {
		Constants.SKIP_TASKS.clear();
		Constants.TOTAL_TASKS = -1;
		Constants.TASK = null;
		Constants.SKIP = false;
		Constants.CHECK_TASK = false;
		Variables.STARTED = true;
	}

	@Override
	public void onProcess() {
		if (!Constants.SKIP && getMethods().requiresBank()) {
			getMethods().bank();
		} else if (!Constants.CHECK_TASK) {
			getMethods().checkTask();
		} else if (Constants.TASK == null || Constants.SKIP) {
			if (Constants.TOTAL_TASKS == 20) {
				Variables.STOP = true;
				return;
			}
			boolean ten = Constants.TOTAL_TASKS > 1 && Constants.TOTAL_TASKS % 10 == 9;
			getMethods().getTask(ten, Constants.SKIP);
		} else if (ctx.pathing.inArea(Constants.BURTHORPE_AREA) || ctx.pathing.inArea(Constants.EDGEVILLE_AREA)) {
			getMethods().goToTask();
		} else {
			getMethods().attack();
		}

	}

	@Override
	public void paint(Graphics Graphs) {
		Graphics2D g = (Graphics2D) Graphs;
		g.setColor(Color.BLACK);
		g.fillRect(5, 5, 200, 75);
		g.setColor(Color.GREEN);
		g.drawRect(5, 5, 200, 75);
		g.setColor(Color.CYAN);
		g.drawString("Total run time: " + Variables.START_TIME.toElapsedString(), 7, 20);
		g.drawString("Status: " + Variables.STATUS, 7, 35);
	}

	final String[] STOP_MESSAGES = { "you are dead", "no ammo" };

	// You've completed 5 tasks and received 2 points, giving you a total of 28;
	// return to a Slayer master.
	@Override
	public void onChatMessage(ChatMessage msg) {
		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			String message = msg.getMessage();
			if (message.contains("and received")) {
				int totalTask = 0;

				try {
					totalTask = Integer.parseInt(message.replaceAll(".* completed (.*) task .*", "$1"));
				} catch (Exception e) {
					totalTask = 1;
				}
				ctx.log("Total: " + totalTask);

				if (totalTask > 0) Constants.TOTAL_TASKS = totalTask;

				Constants.TASK = null;
				Constants.CHECK_TASK = true;
			}
			if (message.contains("you're assigned to kill")) {
				String name = msg.getMessage().replaceAll("(.*) kill (.*); (.*)", "$2");
				Constants.SKIP = false;
				if (name != "") {
					Constants.TASK = new SlayerTask(name, 1);
					Constants.CHECK_TASK = true;
					System.out.println(Constants.TASK);

					if (getMethods().shouldSkipTask()) {
						Constants.SKIP = true;
						Constants.TASK = null;
					} else Constants.SKIP = false;
				}
				// You're assigned to kill Ankou; only 1 more to go.
			}
			if (message.contains("wants you to stick to your slayer assignments") || message.contains("something new to")
					|| message.contains("completed one task")) {
				Constants.TASK = null;
				Constants.CHECK_TASK = true;
			}
			if (!Variables.STOP) {
				Variables.STOP = Stream.of(STOP_MESSAGES).anyMatch(msg1 -> message.contains(msg1));
			}
		}
	}

	@Override
	public void onTerminate() {
		// TODO Auto-generated method stub

	}

}

'''
'''--- combat/fastslayer/data/Constants.java ---
package combat.fastslayer.data;

import java.util.ArrayList;
import java.util.List;

import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

public class Constants {

	public static final WorldPoint[] BURTHORPE_PATH = new WorldPoint[] { new WorldPoint(2899, 3552, 0),
			new WorldPoint(2899, 3545, 0), new WorldPoint(2907, 3545, 0), new WorldPoint(2916, 3545, 0),
			new WorldPoint(2923, 3540, 0), new WorldPoint(2931, 3536, 0) };
	public static final WorldPoint[] EDGEVILLE_PATH = new WorldPoint[] { new WorldPoint(3086, 3493, 0),
			new WorldPoint(3087, 3489, 0), new WorldPoint(3091, 3484, 0) };;
	public static SlayerTask TASK = null;
	public final static WorldArea EDGEVILLE_AREA = new WorldArea(new WorldPoint(3081, 3502, 0), new WorldPoint(3098, 3481, 0));
	public final static WorldArea BURTHORPE_AREA = new WorldArea(new WorldPoint(2892, 3557, 0), new WorldPoint(2934, 3529, 0));;

	public static boolean CHECK_TASK = false;
	public static int TOTAL_TASKS = -1;

	public static List<String> SKIP_TASKS = new ArrayList<String>();
	public static boolean SKIP = false;

}

'''
'''--- combat/fastslayer/data/SlayerTask.java ---
package combat.fastslayer.data;

import lombok.Data;

@Data
public class SlayerTask {
	private String name;
	private int amount;

	public SlayerTask(String name, int amount) {
		this.name = name;
		this.amount = amount;
	}

	public String getName() {
		return replace(this.name);
	}

	public String replace(String name) {
		name = name.replace("wolves", "wolf");
		return name;
	}

}

'''
'''--- combat/fastslayer/methods/Methods.java ---
package combat.fastslayer.methods;

import java.util.regex.Pattern;

import api.Tasks;
import api.Variables;
import api.tasks.Supplies.PotionType;
import api.utils.Utils;
import combat.fastslayer.Core;
import combat.fastslayer.data.Constants;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.wrappers.SimpleGroundItem;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.api.ClientContext;

public class Methods {

	private final Pattern SLAYER_RING_PATTERN = Pattern.compile("Slayer ring \\(\\d+\\)");
	private final Pattern RANGED_POTION_PATTERN = Pattern.compile("Ranging potion\\(\\d+\\)");

	private ClientContext ctx;
	private Core main;

	public Methods(ClientContext ctx, Core main) {
		this.ctx = ctx;
		this.main = main;
	}

	public void checkTask() {
		SimpleItem ring = Tasks.getInventory().getItem("slayer ring");
		if (ring == null) return;
		ctx.bank.closeBank();
		ctx.shop.closeShop();
		Variables.STATUS = "Checking slayer task";
		ring.click("Check");
		ctx.sleep(150, 200);
		if (Constants.TASK != null) Constants.CHECK_TASK = true;
	}

	public void goToTask() {
		SimpleItem ring = Tasks.getInventory().getItem("slayer ring");
		if (ring == null) return;
		Variables.STATUS = "Going to slayer task";
		SimpleWidget w = ctx.widgets.getWidget(187, 3);
		if ((w == null || !w.visibleOnScreen()) && !ctx.dialogue.dialogueOpen()) {
			ring.click("Rub");
			ctx.sleep(150, 200);
			ctx.sleepCondition(() -> ctx.dialogue.dialogueOpen(), 2000);
		} else {
			int count = ctx.dialogue.dialogueOpen() ? ctx.dialogue.getDialogueOptions().length : 1;
			count = count > 3 ? 2 : 1;
			ctx.keyboard.sendKeys(count + "", false);
			ctx.sleep(450);
			ctx.sleepCondition(() -> ctx.players.getLocal().getAnimation() != -1, 450);
			ctx.sleepCondition(() -> ctx.players.getLocal().getAnimation() == -1, 550);
			ctx.sleep(650);
		}
	}

	public void getTask(boolean ten, boolean skip) {
		if (skip && Tasks.getInventory().contains("slayer task skip")) {
			getScrolls();
			return;
		}
		if (ten) {
			getEdgeTask();
		} else {
			getBurthorpeTask();
		}
	}

	public void getEdgeTask() {
		if (!ctx.pathing.inArea(Constants.EDGEVILLE_AREA)) {
			Variables.STATUS = "Teleporting to edgeville";
			if (!Utils.directTeleport("Edgeville")) {
				ctx.magic.castSpellOnce("Home");
			}
		} else {

			SimpleNpc master = ctx.npcs.populate().filter(6797).nearest().next();

			if (master == null || ctx.pathing.distanceTo(master.getLocation()) > 5) {
				Variables.STATUS = "Walking to slayer master";
				ctx.pathing.walkPath(Constants.EDGEVILLE_PATH);
				return;
			}

			if (Constants.TASK == null) {
				Variables.STATUS = "Getting slayer task";
				if (master.click("Assignment")) {
					ctx.sleep(250, 500);
					Constants.CHECK_TASK = false;
					Constants.SKIP = false;
				}
			}
		}
	}

	public void getBurthorpeTask() {
		if (!ctx.pathing.inArea(Constants.BURTHORPE_AREA)) {
			Variables.STATUS = "Teleporting to burthorpe";
			if (!Utils.directTeleport("Burthorpe")) {
				if (main.getTeleport().open()) main.getTeleport().teleportStringPath("Cities", "Burthorpe");
			}
		} else {
			SimpleNpc master = ctx.npcs.populate().filter("Turael").nearest().next();

			if (master == null || ctx.pathing.distanceTo(master.getLocation()) > 5) {
				Variables.STATUS = "Walking to slayer master";
				ctx.pathing.walkPath(Constants.BURTHORPE_PATH);
				return;
			}

			if (Constants.TASK == null) {
				Variables.STATUS = "Getting slayer task";
				if (master.click("Assignment")) {
					ctx.sleep(250, 500);
					Constants.CHECK_TASK = false;
					Constants.SKIP = false;
				}
			}
		}
	}

	public void attack() {
		if (Constants.TASK == null) return;
		SimpleGroundItem casket = ctx.groundItems.populate().filter("Slayer casket").next();
		if (casket != null && casket.validateInteractable()) {
			casket.click("Take");
			return;
		}

		if (Tasks.getSkill().shouldBoost(Skills.RANGED)) Tasks.getSupplies().drink(PotionType.RANGED);
		if (Tasks.getSkill().getPercentage(Skills.HITPOINTS) < 50) Tasks.getSupplies().eat();

		if (ctx.players.getLocal().getInteracting() != null) return;
		SimpleNpc target = ctx.npcs.populate().filter(npc -> {
			return validNPC(npc) && !npc.isDead() && ctx.pathing.reachable(npc)
					&& (npc.getInteracting() == null || npc.getInteracting().equals(ctx.players.getLocal().getPlayer()));
		}).filterWithin(15).nearest().next();

		Variables.STATUS = "Attacking monsters";

		if (target != null && target.validateInteractable()) {
			target.click("Attack");
			ctx.sleep(250, 350);
		}
	}

	public boolean requiresBank() {
		int food = ctx.inventory.populate().filterHasAction("Eat").population();
		int ring = ctx.inventory.populate().filter(SLAYER_RING_PATTERN).population();
		int pots = ctx.inventory.populate().filter(RANGED_POTION_PATTERN).population();
		// System.out.println (food + " "+ring +" "+ pots);
		return food == 0 && (ring == 0 && ctx.pathing.inArea(Constants.EDGEVILLE_AREA));
	}

	public boolean inMonsterArea() {
		return Constants.TASK != null && ctx.npcs.populate().filter(npc -> {
			return validNPC(npc);
		}).population() > 0;
	}

	public boolean validNPC(SimpleNpc npc) {
		return npc != null && npc.getName() != null && (npc.getName().toLowerCase().contains(Constants.TASK.getName())
				|| Constants.TASK.getName().contains(npc.getName().toLowerCase()));
	}

	public void bank() {
		if (!ctx.pathing.inArea(Constants.EDGEVILLE_AREA)) {
			Variables.STATUS = "Teleporting to edgeville";
			if (!Utils.directTeleport("Edgeville")) {
				ctx.magic.castSpellOnce("Home");
			}
			return;
		}

		if (!Tasks.getBanking().heal()) {
			if (!Tasks.getSupplies().hasFood()) {
				Tasks.getBanking().usePreset();
			} else if (!Tasks.getInventory().contains("slayer ring")) {
				if (withdraw("slayer ring")) ctx.bank.closeBank();
			}

		}
	}

	public boolean withdraw(String name) {
		if (Tasks.getBanking().open()) {
			SimpleItem item = Tasks.getBanking().getItem(name);
			if (item == null) {
				Variables.STOP = true;
				return false;
			}
			return ctx.bank.withdraw(item.getId(), 1);
		}
		return false;
	}

	public boolean shouldSkipTask() {
		return Constants.SKIP_TASKS.stream().anyMatch(line -> Constants.TASK.getName().toLowerCase().contains(line));
	}

	public void getScrolls() {
		if (!ctx.pathing.inArea(Constants.EDGEVILLE_AREA)) {
			Variables.STATUS = "Teleporting to edgeville";
			if (!Utils.directTeleport("Edgeville")) {
				ctx.magic.castSpellOnce("Home");
			}
		} else {
			Variables.STATUS = "Getting slayer scrolls";
			if (Tasks.getBanking().open()) {
				ctx.bank.depositInventory();
				if (!Tasks.getBanking().contains("slayer skip scroll")) {
					Variables.STOP = true;
					return;
				}
				withdraw("slayer skip scroll");
				withdraw("slayer ring");
				ctx.sleep(750, 1000);
				ctx.bank.closeBank();
			}
		}

	}

}

'''
'''--- combat/sararacha/Core.java ---
package combat.sararacha;

import java.awt.Graphics;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

import api.Tasks;
import api.Variables;
import api.utils.Utils;
import combat.sararacha.data.Constants;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ItemID;
import simple.hooks.filters.SimplePrayers.Prayers;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleGroundItem;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.script.Script;

@ScriptManifest(author = "KremeSickle", category = Category.UTILITY, description = "Sarachnis", discord = "", name = "Sarachnis", servers = {
		"Zaros" }, version = "2")
public class Core extends Script implements LoopingScript {

	private static List<Integer> LOOT = new ArrayList<Integer>();
	final String[] STOP_MESSAGES = { "be found:", "you are dead" };

	@Override
	public void onChatMessage(ChatMessage msg) {
		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			if (!Variables.STOP) {
				Variables.STOP = Stream.of(STOP_MESSAGES).anyMatch(msg1 -> msg.getMessage().contains(msg1));
			}
		}
	}

	@Override
	public void onExecute() {
		Tasks.init(ctx);

		LOOT.clear();
		LOOT.addAll(Arrays.asList(ItemID.SARACHNIS_CUDGEL, 23495, ItemID.DRAGON_MED_HELM, ItemID.GIANT_EGG_SACFULL,
				ItemID.TORSTOL_SEED, ItemID.DWARF_WEED_SEED, ItemID.COINS_995, ItemID.GRIMY_TORSTOL, ItemID.SNAPDRAGON_SEED,
				ItemID.CRYSTAL_KEY, ItemID.ONYX_BOLT_TIPS, ItemID.YEW_SEED, ItemID.RUNITE_ORE, ItemID.BLOOD_RUNE,
				ItemID.BATTLESTAFF, ItemID.DRAGON_BONES));

		Variables.STARTED = true;

	}

	public void eatFood() {

		while (ctx.skills.level(Skills.HITPOINTS) < 80) {
			SimpleItem food = ctx.inventory.populate().filter("Shark").next();
			if (food == null) break;
			food.click(0);
			ctx.sleep(250);
		}

	}

	public boolean needBank() {
		return ctx.inventory.inventoryFull() || ctx.inventory.populate().filter("Shark").population() < 3
				|| ctx.skills.level(Skills.PRAYER) == 0 || ctx.skills.level(Skills.HITPOINTS) <= 20;
	}

	public void usePotions() {
		SimpleItem attack = ctx.inventory.populate()
				.filter(ItemID.SUPER_ATTACK4, ItemID.SUPER_ATTACK3, ItemID.SUPER_ATTACK2, ItemID.SUPER_ATTACK1).next();
		if (ctx.skills.level(Skills.ATTACK) <= 115 && attack != null) {
			attack.click(0);
			ctx.sleep(250);
		}

		SimpleItem strength = ctx.inventory.populate()
				.filter(ItemID.SUPER_STRENGTH4, ItemID.SUPER_STRENGTH3, ItemID.SUPER_STRENGTH2, ItemID.SUPER_STRENGTH1).next();
		if (ctx.skills.level(Skills.STRENGTH) <= 115 && strength != null) {
			strength.click(0);
			ctx.sleep(250);
		}
	}

	public boolean atHome() {
		return ctx.objects.populate().filter(29237).population() == 1;
	}

	public SimpleGroundItem loot() {
		return ctx.groundItems.populate().filter(item -> item != null && LOOT.contains(item.getId())).nearest().next();
	}

	@Override
	public void onProcess() {

		if (ctx.pathing.inArea(Constants.EDGEVILE_AREA)) {
			Tasks.getSkill().removeAll();
			if (!needBank()) {
				Utils.directTeleport("Sarachnis");
			} else {
				if (!Tasks.getBanking().heal()) Tasks.getBanking().usePreset();
			}

		} else if (ctx.pathing.inArea(Constants.MONSTER_AREA)) {
			if (needBank()) {
				ctx.magic.castSpellOnce("Home Teleport");
				return;
			}

			if (ctx.widgets.getWidget(1002, 0) != null) Utils.directTeleport("Sarachnis");

			Tasks.getSkill().enablePrayer(Prayers.PROTECT_FROM_MISSILES);
			Tasks.getSkill().enablePrayer(Prayers.PIETY);
			usePotions();
			if (ctx.players.getLocal().getLocation().getY() > 9912) {
				SimpleObject gate = ctx.objects.populate().filter(34858).nearest().next();
				if (gate != null) {
					if (gate.click("Quick-Enter")) {
						ctx.sleep(250, 365);
						ctx.sleepCondition(() -> ctx.players.getLocal().getLocation().getX() > 9912, 150);
					}
				}
			} else if (loot() != null) {
				SimpleGroundItem item = loot();
				if (item != null) item.click("Take");

			} else if (ctx.combat.getSpecialAttackPercentage() >= 30) {

				SimpleNpc target = ctx.npcs.populate().filter(8713).nearest().next();
				if (target != null) {

					ctx.combat.toggleSpecialAttack(true);

					if (target.distanceTo(ctx.players.getLocal()) > 5) ctx.pathing.step(target.getLocation());

					if (ctx.players.getLocal().getInteracting() == null) target.click(0);
				}

			} else {
				ctx.magic.castSpellOnce("Teleport to house");
			}
		} else if (atHome()) {
			Tasks.getSkill().removeAll();
			eatFood();
			SimpleObject pool = ctx.objects.populate().filter(29237).next();
			if (pool != null && pool.validateInteractable()) {
				pool.click(0);
				ctx.sleepCondition(() -> ctx.combat.getSpecialAttackPercentage() == 100, 750);
				if (needBank() && ctx.combat.getSpecialAttackPercentage() == 100) {
					ctx.magic.castSpellOnce("Home Teleport");
					return;
				}

				if (ctx.combat.getSpecialAttackPercentage() == 100) Utils.directTeleport("Sarachnis");
			}
		}

	}

	@Override
	public int loopDuration() {
		return 100;
	}

	@Override
	public void paint(Graphics Graphs) {

	}

	@Override
	public void onTerminate() {
		// TODO Auto-generated method stub

	}

}

'''
'''--- combat/sararacha/data/Constants.java ---
package combat.sararacha.data;

import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

public class Constants {
	public final static WorldArea EDGEVILE_AREA = new WorldArea(new WorldPoint(3081, 3502, 0), new WorldPoint(3098, 3481, 0));

	public final static WorldArea MONSTER_AREA = new WorldArea(new WorldPoint(1829, 9915, 0), new WorldPoint(1856, 9888, 0));
}

'''
'''--- construction/CraftingTable.java ---
package construction;

import java.awt.Graphics;
import java.util.stream.Stream;

import javax.swing.JFrame;

import net.runelite.api.ChatMessageType;
import simple.api.Locations;
import simple.api.Utils;
import simple.api.Variables;
import simple.api.panel.Config;
import simple.api.panel.Panel;
import simple.api.panel.Tabs;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Game.Tab;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.script.Script;

@ScriptManifest(author = "KremeSickle", category = Category.CONSTRUCTION, description = "<br>This script will build crafting tables using Molten glass<br><br>Have the room built & near portal<br>Have your preset to include everything required.<br><br>If using the Teleport to House option, have the runes/teleport tab in your preset<br><br>Script will shut down once out of materials<br><br>Please message me on discord with any questions/concerns.", discord = "Datev#0660", name = "KS | Molten Crafting Table", servers = {
		"Zaros" }, version = "1")
public class CraftingTable extends Script implements LoopingScript {

	private JFrame frame;
	private Panel panel;

	@Override
	public void onExecute() {
		try {
			Variables.reset();
			addConfig();
			String title = Utils.getValue(getClass(), "name") + " v" + Utils.getValue(getClass(), "version");
			panel = new Panel();
			frame = panel.init(title, panel);
			Utils.setZoom(5);
		} catch (Exception e) {
			ctx.log(e.getMessage());
			e.printStackTrace();
		}
	}

	public void addConfig() {
		Config.TABS.add(new Tabs(0, "Script Config", "Choose your configuration"));
		Config.CONFIGURATION
				.add(new Config(0, boolean.class, true, "Crafting table 2", "Build the Crafting table 2", "craftTable2"));
		Config.CONFIGURATION
				.add(new Config(0, boolean.class, true, "Crafting table 3", "Build the Crafting table 3", "craftTable3"));
		Config.CONFIGURATION
				.add(new Config(0, boolean.class, false, "Use PoH teleport", "Uses the Teleport to House spell", "pohteleport"));
		Config.CONFIGURATION
				.add(new Config(0, boolean.class, false, "Logout on finish", "Logout when out of ingredients?", "logout"));
		Config.setConfigChanged(true);
	}

	@Override
	public void onProcess() {
		if (Variables.PAUSED) return;
		if (Variables.STOP && getGlass() < 2) {
			if (Config.getB("logout")) ctx.sendLogout();
			else ctx.stopScript();
			return;
		}

		if (!Variables.STARTED) {
			Variables.STATUS = "Waiting to be started";
			return;
		}

		if (ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
			if (getGlass() > 2) {
				if (Config.getB("pohteleport")) {
					SimpleItem tab = ctx.inventory.populate().filter("Teleport to house").next();
					if (tab != null) tab.click(0);
					else ctx.magic.castSpellOnce("Teleport to house");
					ctx.onCondition(() -> ctx.getClient().isInInstancedRegion());
				} else {
					SimpleObject portal = ctx.objects.populate().filter("Portal").nearest().next();
					if (ctx.pathing.distanceTo(portal.getLocation()) > 4) {
						Variables.STATUS = "Walking path to portal";
						ctx.pathing.step(portal.getLocation());
						return;
					}
					if (portal.click("Build")) ctx.onCondition(() -> ctx.getClient().isInInstancedRegion());
				}
			} else {
				bank();
			}
		} else if (ctx.getClient().isInInstancedRegion()) {
			if (ctx.widgets.getWidget(71, 5) != null) return;
			if (getGlass() < 2) {
				ctx.magic.castSpellOnce("Home Teleport");
				ctx.onCondition(() -> ctx.pathing.inArea(Locations.EDGEVILLE_AREA));
				return;
			}

			if (ctx.varpbits.varpbit(780) == 0) {
				Variables.STATUS = "Entering build mode";
				SimpleWidget build = ctx.widgets.getWidget(261, 101);
				SimpleWidget check = ctx.widgets.getWidget(370, 5);

				if (Utils.validWidget(check) && check.getSpriteId() != 699) {
					if (check.click(0)) ctx.onCondition(() -> ctx.varpbits.varpbit(780) == 1);
				} else if (Utils.validWidget(build)) {
					if (build.click(0)) ctx.onCondition(() -> Utils.validWidget(ctx.widgets.getWidget(370, 5)));
				} else Utils.openTab(Tab.OPTIONS);
				return;
			}
			SimpleObject object = ctx.objects.populate().filter("Clockmaker's bench", "Clockmaking space").nearest().next();
			SimpleWidget screen = ctx.widgets.getWidget(458, 1);

			if (object == null) {
				Variables.STATUS = "Unable to find object";
				ctx.log("Unable to find object");
				return;
			}
			if (object.getId() == 15441) {
				if (screen == null || !screen.visibleOnScreen()) {
					Variables.STATUS = "Opening construction widget";
					if (object.validateInteractable() && object.click("Build"))
						ctx.onCondition(() -> ctx.widgets.getWidget(458, 1).visibleOnScreen());
				} else {
					int index = getIndex();
					if (index == -1) {
						Variables.STATUS = "Select at least one table";
						return;
					}
					SimpleWidget build = ctx.widgets.getWidget(458, 4 + index);
					Variables.STATUS = "Building object";
					if (build != null && build.visibleOnScreen()) {
						if (build.click(0)) {
							ctx.onCondition(() -> object.getId() != 15441, 1500);
							ctx.sleep(300, 450);
						}
					}
				}
			} else {
				Variables.STATUS = "Removing object";
				if (ctx.dialogue.dialogueOpen()) {
					ctx.dialogue.clickDialogueOption(1);
					ctx.onCondition(() -> !ctx.dialogue.dialogueOpen());
				}
				if (object.validateInteractable() && object.click("Remove")) {
					ctx.onCondition(() -> ctx.dialogue.dialogueOpen());
				}
			}
		}

	}

	@Override
	public int loopDuration() {
		return 200;
	}

	@Override
	public void onTerminate() {
		if (frame != null) frame.dispose();
		ctx.log("Shutting down.. Thank you for using the script");
		Variables.reset();
		Config.clear();
	}

	@Override
	public void paint(Graphics Graphs) {
		if (panel != null) panel.update(Variables.STATUS);
	}

	final String[] STOP_MESSAGES = { "item could not be found", "don't have the right", "need a hammer", "need a saw" };

	@Override
	public void onChatMessage(ChatMessage msg) {
		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			if (!Variables.STOP) {
				Variables.STOP = Stream.of(STOP_MESSAGES).anyMatch(msg1 -> msg.getMessage().contains(msg1));
			}
		}
	}

	public void bank() {
		SimpleObject bank = ctx.objects.populate().filter("Bank booth").nearest().next();
		if (bank == null) {
			Variables.STATUS = "Bank unable to be found";
			return;
		}
		if (bank.distanceTo(ctx.players.getLocal()) > 5) {
			Variables.STATUS = "Walking path to bank";
			ctx.pathing.step(bank.getLocation());
		} else if (bank.validateInteractable()) {
			Variables.STATUS = "Getting last preset";
			if (bank.click("Last-preset")) {
				ctx.onCondition(() -> ctx.inventory.populate().population() > 0, 500);
			}
		}
	}

	public int getGlass() {
		return ctx.inventory.populate().filter("Molten glass").population();
	}

	public int getIndex() {
		int level = ctx.skills.level(Skills.CONSTRUCTION);
		if (Config.getB("craftTable3") && level >= 34) return 2;
		else if (Config.getB("craftTable2") && level >= 25) return 1;
		return -1;
	}
}

'''
'''--- construction/Hoster.java ---
package construction;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.util.stream.Stream;

import net.runelite.api.ChatMessageType;
import simple.api.Locations;
import simple.api.Variables;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.script.Script;

@ScriptManifest(author = "KremeSickle", category = Category.CONSTRUCTION, description = "", discord = "Datev#0660", name = "KS | PoH Hoster", servers = {
		"Zaros" }, version = "1")
public class Hoster extends Script implements LoopingScript {

	@Override
	public void onExecute() {
		Variables.reset();
		Variables.STARTED = true;
	}

	@Override
	public void onProcess() {
		if (Variables.STOP) {
			ctx.stopScript();
			return;
		}
		if (!Variables.STARTED) return;

		boolean marr = ctx.inventory.populate().filter("Marrentill").population() > 0;
		if (ctx.getClient().isInInstancedRegion()) {
			if (ctx.widgets.getWidget(71, 5) != null) return;
			if (!marr) {
				teleportHome();
				return;
			}
			SimpleObject lit = ctx.objects.populate().filter(13213).nearest().next();
			SimpleObject unlit = ctx.objects.populate().filter(13212).nearest().next();
			if (unlit != null && ctx.pathing.distanceTo(unlit.getLocation()) > 5) ctx.pathing.step(unlit.getLocation());
			if (lit != null && ctx.pathing.distanceTo(lit.getLocation()) > 5) ctx.pathing.step(lit.getLocation());
			if (ctx.players.populate().filter(p -> p.distanceTo(ctx.players.getLocal()) < 6).population() == 1) {
				Variables.STATUS = "Waiting for people";
				return;
			}
			;
			if (unlit != null && marr && ctx.inventory.populate().filter("Tinderbox").population() > 0) {
				Variables.STATUS = "Relighting burners";
				if (unlit.validateInteractable() && unlit.click("Light"))
					ctx.onCondition(() -> ctx.players.getLocal().getAnimation() != -1);
				return;
			}
		} else if (ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
			if (!marr) {
				bank();
				return;
			}
			SimpleObject portal = ctx.objects.populate().filter("Portal").nearest().next();
			if (ctx.pathing.distanceTo(portal.getLocation()) > 4) {
				Variables.STATUS = "Walking path to portal";
				ctx.pathing.step(portal.getLocation());
				return;
			}
			if (portal.validateInteractable() && portal.click("Home"))
				ctx.onCondition(() -> ctx.getClient().isInInstancedRegion());
		}
	}

	@Override
	public int loopDuration() {
		return 200;
	}

	@Override
	public void onTerminate() {
		Variables.reset();
		ctx.log("Shutting down.. Thank you for using the script");
	}

	@Override
	public void paint(Graphics Graphs) {
		Graphics2D g = (Graphics2D) Graphs;
		g.setColor(Color.BLACK);
		g.fillRect(5, 5, 200, 30);
		g.setColor(Color.GREEN);
		g.drawRect(5, 5, 200, 30);
		g.setColor(Color.CYAN);
		g.drawString("Total run time: " + Variables.START_TIME.toElapsedString(), 7, 20);
		g.drawString("Status: " + Variables.STATUS, 7, 30);
	}

	final String[] STOP_MESSAGES = { "don't have the right", "be found:" };

	@Override
	public void onChatMessage(ChatMessage msg) {
		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			if (!Variables.STOP) {
				Variables.STOP = Stream.of(STOP_MESSAGES).anyMatch(msg1 -> msg.getMessage().contains(msg1));
			}
		}
	}

	public void teleportHome() {
		Variables.STATUS = "Teleporting home";
		ctx.magic.castSpellOnce("Home");
		ctx.onCondition(() -> ctx.pathing.inArea(Locations.EDGEVILLE_AREA));
	}

	public void bank() {
		SimpleObject bank = ctx.objects.populate().filter("Bank booth").nearest().next();
		if (bank.validateInteractable()) {
			Variables.STATUS = "Getting last preset";
			if (bank.click("Last-preset")) {
				ctx.onCondition(() -> ctx.inventory.populate().population() > 0, 500);
			}
		}
	}

}

'''
'''--- construction/MagicalBalance.java ---
package construction;

import java.awt.Graphics;
import java.util.stream.Stream;

import javax.swing.JFrame;

import net.runelite.api.ChatMessageType;
import simple.api.Utils;
import simple.api.Variables;
import simple.api.panel.Config;
import simple.api.panel.Panel;
import simple.api.panel.Tabs;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.script.Script;

@ScriptManifest(author = "KremeSickle", category = Category.CONSTRUCTION, description = "<br>This script builds Magic balance's in your POH.<br><br>Start near the Elemental Balance Space in your house in build mode<br><br>Have the required runes in your inventory (Fire,Air,Earth,Water), saw & hammer<br><br>Script will advance onto the highest balance once level is reached.<br><br>Script will shut down after runes run out.", discord = "Datev#0660", name = "KS | Magic Balance", servers = {
		"Zaros" }, version = "2")
public class MagicalBalance extends Script implements LoopingScript {

	private JFrame frame;
	private Panel panel;

	@Override
	public void onExecute() {
		try {
			Variables.reset();
			addConfig();
			String title = Utils.getValue(getClass(), "name") + " v" + Utils.getValue(getClass(), "version");
			panel = new Panel();
			frame = panel.init(title, panel);
			Utils.setZoom(1);
		} catch (Exception e) {
			ctx.log(e.getMessage());
			e.printStackTrace();
		}
	}

	public void addConfig() {
		Config.TABS.add(new Tabs(0, "Script Config", "Choose your configuration"));
		Config.CONFIGURATION.add(
				new Config(0, boolean.class, true, "Lesser magical balance", "Build the Lesser magical balance", "buildLesser"));
		Config.CONFIGURATION.add(
				new Config(0, boolean.class, true, "Medium magical balance", "Build the Medium magical balance", "buildMedium"));
		Config.CONFIGURATION.add(new Config(0, boolean.class, true, "Greater magical balance",
				"Build the Greater magical balance", "buildGreator"));
		Config.CONFIGURATION
				.add(new Config(0, boolean.class, false, "Logout on finish", "Logout when out of ingredients?", "logout"));
		Config.setConfigChanged(true);
	}

	@Override
	public void onProcess() {
		if (Variables.PAUSED) return;
		if (Variables.STOP) {
			Variables.STATUS = "Shutting down";
			if (Config.getB("logout")) ctx.sendLogout();
			else ctx.stopScript();
			return;
		}
		if (!Variables.STARTED) {
			Variables.STATUS = "Waiting to be started";
			return;
		}
		SimpleObject object = ctx.objects.populate().filter("Elemental balance", "Elemental balance space").nearest().next();
		SimpleWidget screen = ctx.widgets.getWidget(458, 1);
		if (object == null) {
			ctx.log("Unable to find object");
			Variables.STOP = true;
			return;
		}
		if (object.getId() == 15345) {
			if (screen == null || !screen.visibleOnScreen()) {
				Variables.STATUS = "Opening construction widget";
				if (object.validateInteractable() && object.click("Build"))
					ctx.onCondition(() -> ctx.widgets.getWidget(458, 1).visibleOnScreen());
			} else {
				int index = getIndex();
				if (index == -1) {
					Variables.STATUS = "Select at least one balance";
					return;
				}
				SimpleWidget build = ctx.widgets.getWidget(458, 4 + index);
				Variables.STATUS = "Building object";
				if (build != null && build.visibleOnScreen()) {
					if (build.click(0)) {
						ctx.onCondition(() -> object.getId() != 15345, 1500);
						ctx.sleep(300, 450);
					}
				}
			}
		} else {
			Variables.STATUS = "Removing object";
			if (ctx.dialogue.dialogueOpen()) {
				ctx.dialogue.clickDialogueOption(1);
				ctx.onCondition(() -> !ctx.dialogue.dialogueOpen());
			}
			if (object.validateInteractable() && object.click("Remove")) {
				ctx.onCondition(() -> ctx.dialogue.dialogueOpen());
			}
		}
	}

	@Override
	public int loopDuration() {
		return 200;
	}

	@Override
	public void onTerminate() {
		if (frame != null) frame.dispose();
		ctx.log("Shutting down.. Thank you for using the script");
		Variables.reset();
		Config.clear();
	}

	@Override
	public void paint(Graphics Graphs) {
		if (panel != null) panel.update(Variables.STATUS);
	}

	final String[] STOP_MESSAGES = { "don't have the right", "need a hammer", "need a saw" };

	@Override
	public void onChatMessage(ChatMessage msg) {
		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			if (!Variables.STOP) {
				Variables.STOP = Stream.of(STOP_MESSAGES).anyMatch(msg1 -> msg.getMessage().contains(msg1));
			}
		}
	}

	public int getIndex() {
		int level = ctx.skills.level(Skills.CONSTRUCTION);
		if (Config.getB("buildGreator") && level >= 77) return 2;
		else if (Config.getB("buildMedium") && level >= 57) return 1;
		else if (Config.getB("buildLesser")) return 0;
		return -1;
	}

}

'''
'''--- herblore/HerbloreAIO.java ---
package herblore;

import java.awt.Graphics;
import java.util.Arrays;
import java.util.List;

import javax.swing.JFrame;

import herblore.data.Constants;
import herblore.data.Herbs;
import herblore.data.Potions;
import herblore.data.tasks.CleanHerb;
import herblore.data.tasks.CreatePotion;
import herblore.data.tasks.CreateUnfPotion;
import herblore.data.tasks.Tasks;
import herblore.data.tasks.Tasks.Type;
import simple.api.Utils;
import simple.api.Variables;
import simple.api.panel.Config;
import simple.api.panel.Panel;
import simple.api.panel.Tabs;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.robot.api.ClientContext;
import simple.robot.script.Script;

@ScriptManifest(author = "KremeSickle", category = Category.HERBLORE, description = "<br>This script will creates potions/cleans herbs<br><br>Start the script in Edgeville with the bank open<br><br>There is 4 modes for this script, AIO, Clean Herb, Make Unf Potion, Make Potion<br>~ AIO ~<br>- Cleans all available herbs<br>- Creates all available unfinished potions<br>- Creates all available final potions<br><br>Please PM me on discord with any bugs", discord = "Datev#0660", name = "KS | AIO Herblore", servers = {
		"Zaros" }, version = "2")

public class HerbloreAIO extends Script implements LoopingScript {

	private JFrame frame;
	private Panel panel;

	@Override
	public void onExecute() {
		try {
			Variables.reset();
			addConfig();
			String title = Utils.getValue(getClass(), "name") + " v" + Utils.getValue(getClass(), "version");
			panel = new Panel();
			frame = panel.init(title, panel);
			Utils.setZoom(1);
		} catch (Exception e) {
			ClientContext.instance().log(e.getMessage());
			e.printStackTrace();
		}
	}

	private enum TYPE {
		ALL_IN_ONE,
		CLEAN_HERB,
		UNFINISHED_POTION,
		FULL_POTION
	}

	private CleanHerb cleanHerb;
	private CreateUnfPotion unfPotion;
	private CreatePotion potion;

	public void addConfig() {
		cleanHerb = new CleanHerb(ctx);
		unfPotion = new CreateUnfPotion(ctx);
		potion = new CreatePotion(ctx);

		Config.TABS.add(new Tabs(0, "Script Config", "Choose your configuration"));

		Config.CONFIGURATION.add(new Config(0, TYPE.class, "ALL_IN_ONE", "Mode", "Choose your herblore mode", "mode"));
		Config.CONFIGURATION.add(new Config(0, Herbs.class, "GUAM_LEAF", "Grimy Herb", "Which herb to clean", "herb"));

		Config.CONFIGURATION
				.add(new Config(0, Herbs.class, "GUAM_LEAF", "Unfinished", "Which unfinished potion to make", "unfinish"));

		Config.CONFIGURATION.add(new Config(0, Potions.class, "ATTACK", "Finished", "Which finished potion to make", "finish"));

		Config.CONFIGURATION.add(new Config(0, boolean.class, false, "Logout on finish", "Logout on finish?", "logout"));

		Config.setConfigChanged(true);
	}

	public void check() {
		Constants.tasks.clear();
		if (getType() != TYPE.ALL_IN_ONE) return;

		int level = ctx.skills.realLevel(Skills.HERBLORE);
		if (!ctx.bank.bankOpen()) {
			ctx.log("==== RERUN SCRIPT WITH BANK OPEN ===");
			return;
		}
		List<Herbs> canClean = Herbs.getCleanable(level);
		List<Herbs> canMakeUnf = Herbs.getUnfMakeable(level);
		List<Potions> canMake = Potions.getMakeable(level);
		ctx.log("[Herb clean] Found %s tasks", canClean.size());
		ctx.log("[Unf potion] Found %s tasks", canMakeUnf.size());
		ctx.log("[Fin potion] Found %s tasks", canMake.size());
		if (canClean.size() > 0) Constants.tasks.add(new Tasks(Type.CLEAN_HERB, canClean));
		if (canMakeUnf.size() > 0) Constants.tasks.add(new Tasks(Type.UNFINISHED_POTION, canMakeUnf));
		if (canMake.size() > 0) Constants.tasks.add(new Tasks(Type.FULL_POTION, canMake));
	}

	public boolean check(Tasks current) {
		if (current.getValid().size() == 0) {
			check();
			return true;
		}
		return false;
	}

	public void setTasks() {
		Constants.tasks.clear();
		if (getType().equals(TYPE.ALL_IN_ONE)) check();
		else if (getType().equals(TYPE.CLEAN_HERB)) Constants.tasks.add(new Tasks(Type.CLEAN_HERB, Arrays.asList(getHerb())));
		else if (getType().equals(TYPE.UNFINISHED_POTION))
			Constants.tasks.add(new Tasks(Type.UNFINISHED_POTION, Arrays.asList(getUnfPot())));
		else if (getType().equals(TYPE.FULL_POTION)) Constants.tasks.add(new Tasks(Type.FULL_POTION, Arrays.asList(getPot())));

	}

	@Override
	public void onProcess() {
		if (Variables.PAUSED) return;
		if (Variables.STOP) {
			if (Config.getB("logout")) ctx.sendLogout();
			else ctx.stopScript();
			return;
		}
		if (!Variables.STARTED) {
			Variables.STATUS = "Waiting to be started";
			return;
		}

		if (Config.isConfigChanged()) {
			if (Utils.openBank() && ctx.bank.depositInventory()) {
				setTasks();
				Config.setConfigChanged(false);
			}
			return;
		}

		if (Constants.tasks.size() == 0) {
			Variables.STOP = true;
			Variables.STATUS = "No tasks left";
			Variables.DEBUG = "";
			return;
		}

		Tasks currentTask = Constants.tasks.get(0);

		if (check(currentTask)) return;

		switch (currentTask.getType()) {
			case CLEAN_HERB:
				Herbs h = (Herbs) currentTask.getValid().get(0);
				if (h != null && cleanHerb.process(h)) {
					Constants.tasks.get(0).getValid().remove(0);
					cleanHerb.setStop(false);
				}
				break;
			case FULL_POTION:
				Potions p = (Potions) currentTask.getValid().get(0);
				if (p != null && potion.process(p)) {
					Constants.tasks.get(0).getValid().remove(0);
					potion.setStop(false);
				}
				break;
			case UNFINISHED_POTION:
				Herbs u = (Herbs) currentTask.getValid().get(0);
				if (u != null && unfPotion.process(u)) {
					Constants.tasks.get(0).getValid().remove(0);
					unfPotion.setStop(false);
				}
				break;
		}
	}

	@Override
	public int loopDuration() {
		return 600;
	}

	@Override
	public void onTerminate() {
		if (frame != null) frame.dispose();
		ctx.log("Shutting down.. Thank you for using the script");
		Variables.reset();
		Config.clear();
	}

	public void paint(Graphics Graphs) {
		if (panel != null) panel.update(Variables.STATUS);
	}

	@Override
	public void onChatMessage(ChatMessage e) {

	}

	public void resetVariables() {
		Constants.tasks.clear();
		Constants.reverse = false;
		Variables.reset();
	}

	public TYPE getType() {
		return Config.getValue("mode");
	}

	public Herbs getHerb() {
		return Config.getValue("herb");
	}

	public Herbs getUnfPot() {
		return Config.getValue("unfinish");
	}

	public Potions getPot() {
		return Config.getValue("finish");
	}

}

'''
'''--- herblore/data/Constants.java ---
package herblore.data;

import java.util.ArrayList;
import java.util.List;

import herblore.data.tasks.Tasks;

public class Constants {

	public static List<Tasks> tasks = new ArrayList<Tasks>();
	public static boolean reverse;

}

'''
'''--- herblore/data/Herbs.java ---
package herblore.data;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;
import simple.api.Utils;
import simple.robot.api.ClientContext;

@AllArgsConstructor
@Getter
public enum Herbs {

	GUAM_LEAF(3, 3, ItemID.GRIMY_GUAM_LEAF, ItemID.GUAM_LEAF, ItemID.GUAM_POTION_UNF),
	MARRENTILL(5, 5, ItemID.GRIMY_MARRENTILL, ItemID.MARRENTILL, ItemID.MARRENTILL_POTION_UNF),
	TARROMIN(11, 12, ItemID.GRIMY_TARROMIN, ItemID.TARROMIN, ItemID.TARROMIN_POTION_UNF),
	HARRALANDER(20, 22, ItemID.GRIMY_HARRALANDER, ItemID.HARRALANDER, ItemID.HARRALANDER_POTION_UNF),
	RANARR_WEED(25, 30, ItemID.GRIMY_RANARR_WEED, ItemID.RANARR_WEED, ItemID.RANARR_POTION_UNF),
	TOADFLAX(30, 34, ItemID.GRIMY_TOADFLAX, ItemID.TOADFLAX, ItemID.TOADFLAX_POTION_UNF),
	IRIT_LEAF(40, 45, ItemID.GRIMY_IRIT_LEAF, ItemID.IRIT_LEAF, ItemID.IRIT_POTION_UNF),
	AVANTOE(48, 50, ItemID.GRIMY_AVANTOE, ItemID.AVANTOE, ItemID.AVANTOE_POTION_UNF),
	KWUARM(54, 55, ItemID.GRIMY_KWUARM, ItemID.KWUARM, ItemID.KWUARM_POTION_UNF),
	SNAPDRAGON(59, 63, ItemID.GRIMY_SNAPDRAGON, ItemID.SNAPDRAGON, ItemID.SNAPDRAGON_POTION_UNF),
	CADANTINE(65, 66, ItemID.GRIMY_CADANTINE, ItemID.CADANTINE, ItemID.CADANTINE_POTION_UNF),
	LANTADYME(67, 69, ItemID.GRIMY_LANTADYME, ItemID.LANTADYME, ItemID.LANTADYME_POTION_UNF),
	DWARF_WEED(70, 72, ItemID.GRIMY_DWARF_WEED, ItemID.DWARF_WEED, ItemID.DWARF_WEED_POTION_UNF),
	TORSTOL(75, 78, ItemID.GRIMY_TORSTOL, ItemID.TORSTOL, ItemID.TORSTOL_POTION_UNF);

	;

	private int cleanLevel, unfLevel;
	private int grimyId, cleanId, unfId;

	public String getName() {
		return Utils.formatString(this.name().split("_"));
	}

	public String getString() {
		return String.format("{Name: %s, cleanLevel: %s, unfLevel: %s, grimyId: %s, cleanId: %s, unfId: %s}", getName(),
				cleanLevel, unfLevel, grimyId, cleanId, unfId);
	}

	@Override
	public String toString() {
		return getName();
	}

	public static List<Herbs> getCleanable(int level) {
		return Arrays.asList(Herbs.values()).stream().filter(herb -> {

			return level >= herb.getCleanLevel()
					&& ClientContext.instance().bank.populate().filter(herb.getGrimyId()).population(true) > 0;
		}).collect(Collectors.toList());
	}

	public static List<Herbs> getUnfMakeable(int level) {
		ClientContext.instance().bank.populate();
		return Arrays.asList(Herbs.values()).stream().filter(herb -> {

			return level >= herb.getUnfLevel()
					&& ClientContext.instance().bank.populate().filter(herb.getCleanId()).population(true) > 0;
		}).collect(Collectors.toList());
	}

	public static Herbs find(String name) {
		return Arrays.asList(Herbs.values()).stream().filter(val -> val.getName().equals(name)).findFirst().orElse(null);
	}

	public static String[] getNames() {
		return Arrays.asList(Herbs.values()).stream().map(Herbs::getName).toArray(String[]::new);
	}
}

'''
'''--- herblore/data/Potions.java ---
package herblore.data;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;
import simple.api.Utils;
import simple.robot.api.ClientContext;

@AllArgsConstructor
@Getter
public enum Potions {

	ATTACK(3, ItemID.ATTACK_POTION3, ItemID.EYE_OF_NEWT, Herbs.GUAM_LEAF),
	ANTIPOISON(5, ItemID.ANTIPOISON3, ItemID.UNICORN_HORN_DUST, Herbs.MARRENTILL),
	STRENGTH(12, ItemID.STRENGTH_POTION3, ItemID.LIMPWURT_ROOT, Herbs.TARROMIN),
	SERUM_207(15, ItemID.SERUM_207_3, ItemID.ASHES, Herbs.TARROMIN),
	COMPOST(22, ItemID.COMPOST_POTION3, ItemID.VOLCANIC_ASH, Herbs.HARRALANDER),
	RESTORE(22, ItemID.RESTORE_POTION3, ItemID.RED_SPIDERS_EGGS, Herbs.HARRALANDER),
	ENERGY(26, ItemID.ENERGY_POTION3, ItemID.CHOCOLATE_DUST, Herbs.HARRALANDER),
	DEFENCE(30, ItemID.DEFENCE_POTION3, ItemID.WHITE_BERRIES, Herbs.RANARR_WEED),
	AGILITY(34, ItemID.AGILITY_POTION3, ItemID.TOADS_LEGS, Herbs.TOADFLAX),
	COMBAT(84, ItemID.COMBAT_POTION3, ItemID.GOAT_HORN_DUST, Herbs.HARRALANDER),
	PRAYER(38, ItemID.PRAYER_POTION3, ItemID.SNAPE_GRASS, Herbs.RANARR_WEED),
	SUPER_ATTACK(45, ItemID.SUPER_ATTACK3, ItemID.EYE_OF_NEWT, Herbs.IRIT_LEAF),
	SUPERANTIPOISON(48, ItemID.SUPERANTIPOISON3, ItemID.UNICORN_HORN_DUST, Herbs.IRIT_LEAF),
	SUPER_ENERGY(52, ItemID.SUPER_ENERGY3, ItemID.MORT_MYRE_FUNGUS, Herbs.AVANTOE),
	SUPER_STRENGTH(55, ItemID.SUPER_STRENGTH3, ItemID.LIMPWURT_ROOT, Herbs.KWUARM),
	SUPER_RESTORE(63, ItemID.SUPER_RESTORE3, ItemID.RED_SPIDERS_EGGS, Herbs.SNAPDRAGON),
	SUPER_DEFENCE(66, ItemID.SUPER_DEFENCE3, ItemID.WHITE_BERRIES, Herbs.CADANTINE),
	ANTIFIRE(69, ItemID.ANTIFIRE_POTION3, ItemID.DRAGON_SCALE_DUST, Herbs.LANTADYME),
	RANGING(72, ItemID.RANGING_POTION3, ItemID.WINE_OF_ZAMORAK, Herbs.DWARF_WEED),
	MAGIC(76, ItemID.MAGIC_POTION3, ItemID.POTATO_CACTUS, Herbs.LANTADYME),
	// STAMINA(77, ItemID.STAMINA_POTION3, ItemID.AMYLASE_CRYSTAL, null)
	SARADOMIN_BREW(81, ItemID.SARADOMIN_BREW3, ItemID.CRUSHED_NEST, Herbs.TOADFLAX),

	;

	private int reqLevel, potionId, ingredientId;
	private Herbs reqHerb;

	public String getName() {
		return Utils.formatString(this.name().split("_"));
	}

	public String getString() {
		return String.format("{Name: %s, reqLevel: %s, reqHerb: %s, ingredientId: %s, potionId: %s}", getName(), reqLevel,
				reqHerb.getName(), ingredientId, potionId);
	}

	@Override
	public String toString() {
		return getName();
	}

	public static List<Potions> getMakeable(int level) {
		return Arrays.asList(Potions.values()).stream().sorted(Comparator.reverseOrder()).filter(potion -> {

			return level >= potion.getReqLevel()
					&& ClientContext.instance().bank.populate().filter(potion.getIngredientId()).population(true) > 0
					&& ClientContext.instance().bank.populate().filter(potion.getReqHerb().getUnfId()).population(true) > 0;
		}).collect(Collectors.toList());
	}

	public static Potions find(String name) {
		return Arrays.asList(Potions.values()).stream().filter(val -> val.getName().equals(name)).findFirst().orElse(null);
	}

	public static String[] getNames() {
		return Arrays.asList(Potions.values()).stream().map(Potions::getName).toArray(String[]::new);
	}
}

'''
'''--- herblore/data/tasks/CleanHerb.java ---
package herblore.data.tasks;

import herblore.data.Herbs;
import lombok.Setter;
import simple.api.Utils;
import simple.api.Variables;
import simple.hooks.queries.SimpleItemQuery;
import simple.hooks.wrappers.SimpleItem;
import simple.robot.api.ClientContext;

public class CleanHerb {

	private ClientContext ctx;

	public CleanHerb(ClientContext ctx) {
		this.ctx = ctx;
	}

	private Herbs current = null;
	@Setter
	private boolean stop = false;

	public boolean process(Herbs valid) {
		current = valid;

		if (getHerbs()) {
			cleanHerb();
		}

		return stop;
	}

	public boolean hasItems(boolean both) {
		boolean herbs = ctx.inventory.populate().filter(current.getGrimyId()).population() > 0;

		if (both) {
			if (!herbs) herbs = ctx.bank.populate().filter(current.getGrimyId()).population(true) > 0;
		}
		return herbs;
	}

	public void cleanHerb() {
		if (ctx.bank.bankOpen()) {
			ctx.bank.closeBank();
			ctx.sleepCondition(() -> ctx.bank.bankOpen(), 500);
		}
		Variables.STATUS = "Cleaning herbs";
		Variables.DEBUG = "[CLEAN] " + current.getName();
		SimpleItemQuery<SimpleItem> query = ctx.inventory.populate().filter(current.getGrimyId());

		query.forEach(item -> {
			if (item != null) item.click(0);
			ctx.sleep(250, 350);
		});
	}

	public boolean getHerbs() {
		if (hasItems(false)) return true;
		if (Utils.openBank()) {
			Variables.STATUS = "Withdrawing items";
			ctx.bank.depositAllExcept(current.getGrimyId());
			if (!hasItems(true)) {
				stop = true;
				return false;
			}
			ctx.sleep(150, 250);
			ctx.bank.withdraw(current.getGrimyId(), 28);
			ctx.sleep(450, 750);
		}
		return hasItems(false);
	}

}

'''
'''--- herblore/data/tasks/CreatePotion.java ---
package herblore.data.tasks;

import herblore.data.Potions;
import lombok.Setter;
import simple.api.Timer;
import simple.api.Utils;
import simple.api.Variables;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.api.ClientContext;

public class CreatePotion {

	private ClientContext ctx;

	public CreatePotion(ClientContext ctx) {
		this.ctx = ctx;
	}

	private Potions current = null;
	private Timer lastAnimation = new Timer(1);
	@Setter
	private boolean stop = false;

	public boolean process(Potions valid) {
		current = valid;
		if (ctx.players.getLocal().getAnimation() == 363) lastAnimation = new Timer(2000);
		if (!lastAnimation.isRunning() && getIngredients()) createPotion();
		return stop;
	}

	public boolean hasItems(boolean both) {
		boolean herbs = ctx.inventory.populate().filter(current.getReqHerb().getUnfId()).population() > 0;
		boolean vial = ctx.inventory.populate().filter(current.getIngredientId()).population() > 0;

		if (both) {
			if (!herbs) herbs = ctx.bank.populate().filter(current.getReqHerb().getUnfId()).population(true) > 0;
			if (!vial) vial = ctx.bank.populate().filter(current.getIngredientId()).population(true) > 0;
		}
		return herbs && vial;
	}

	public void createPotion() {
		if (ctx.bank.bankOpen()) {
			ctx.bank.closeBank();
			ctx.sleepCondition(() -> ctx.bank.bankOpen(), 500);
		}
		Variables.STATUS = "Making " + current.getName() + " potion";
		Variables.DEBUG = "[FIN] " + current.getName();
		SimpleItem vial = ctx.inventory.populate().filter(current.getReqHerb().getUnfId()).next();
		SimpleItem herb = ctx.inventory.populate().filter(current.getIngredientId()).reverse().next();

		SimpleWidget w = ctx.widgets.getWidget(270, 14);

		if (w != null && !w.isHidden()) {
			if (w.click(0)) {
				ctx.sleep(450, 750);
				lastAnimation = new Timer(2000);
			}

		} else if (herb != null && vial != null && herb.click(0)) {
			vial.click(0);
			ctx.sleep(250, 350);
		}
	}

	public boolean getIngredients() {
		if (hasItems(false)) return true;
		if (Utils.openBank()) {
			Variables.STATUS = "Withdrawing items";
			ctx.bank.depositAllExcept(current.getReqHerb().getUnfId(), current.getIngredientId());
			if (!hasItems(true)) {
				stop = true;
				return false;
			}
			int amt1 = ctx.inventory.populate().filter(current.getIngredientId()).population(true);
			int amt2 = ctx.inventory.populate().filter(current.getReqHerb().getUnfId()).population(true);

			ctx.sleep(150, 250);
			ctx.bank.withdraw(current.getIngredientId(), 14 - amt1);
			ctx.bank.withdraw(current.getReqHerb().getUnfId(), 14 - amt2);
			ctx.sleep(450, 750);
		}
		return hasItems(false);
	}

}

'''
'''--- herblore/data/tasks/CreateUnfPotion.java ---
package herblore.data.tasks;

import herblore.data.Herbs;
import lombok.Setter;
import net.runelite.api.ItemID;
import simple.api.Timer;
import simple.api.Utils;
import simple.api.Variables;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.api.ClientContext;

public class CreateUnfPotion {

	private ClientContext ctx;

	public CreateUnfPotion(ClientContext ctx) {
		this.ctx = ctx;
	}

	private Herbs current = null;
	private Timer lastAnimation = new Timer(1);
	@Setter
	private boolean stop = false;

	public boolean process(Herbs valid) {
		current = valid;
		if (ctx.players.getLocal().getAnimation() == 363) lastAnimation = new Timer(2000);
		if (!lastAnimation.isRunning() && getIngredients()) createPotion();
		return stop;
	}

	public boolean hasItems(boolean both) {
		boolean herbs = ctx.inventory.populate().filter(current.getCleanId()).population() > 0;
		boolean vial = ctx.inventory.populate().filter(ItemID.VIAL_OF_WATER).population() > 0;

		if (both) {
			if (!herbs) herbs = ctx.bank.populate().filter(current.getCleanId()).population(true) > 0;
			if (!vial) vial = ctx.bank.populate().filter(ItemID.VIAL_OF_WATER).population(true) > 0;
		}
		return herbs && vial;
	}

	public void createPotion() {
		if (ctx.bank.bankOpen()) {
			ctx.bank.closeBank();
			ctx.sleepCondition(() -> ctx.bank.bankOpen(), 500);
		}
		Variables.STATUS = "Making unfinished " + current.getName();
		Variables.DEBUG = "[UNF] " + current.getName();
		SimpleItem vial = ctx.inventory.populate().filter(ItemID.VIAL_OF_WATER).next();
		SimpleItem herb = ctx.inventory.populate().filter(current.getCleanId()).reverse().next();

		SimpleWidget w = ctx.widgets.getWidget(270, 14);

		if (w != null && !w.isHidden()) {
			if (w.click(0)) {
				ctx.sleep(450, 750);
				lastAnimation = new Timer(2000);
			}

		} else if (herb != null && vial != null && herb.click(0)) {
			vial.click(0);
			ctx.sleep(250, 350);
		}
	}

	public boolean getIngredients() {
		if (hasItems(false)) return true;
		if (Utils.openBank()) {
			ctx.bank.depositAllExcept(current.getCleanId(), ItemID.VIAL_OF_WATER);
			Variables.STATUS = "Withdrawing items";
			if (!hasItems(true)) {
				stop = true;
				return false;
			}
			int amt1 = ctx.inventory.populate().filter(ItemID.VIAL_OF_WATER).population(true);
			int amt2 = ctx.inventory.populate().filter(current.getCleanId()).population(true);
			ctx.sleep(150, 250);
			ctx.bank.withdraw(ItemID.VIAL_OF_WATER, 14 - amt1);
			ctx.bank.withdraw(current.getCleanId(), 14 - amt2);
			ctx.sleep(450, 750);
		}
		return hasItems(false);
	}

}

'''
'''--- herblore/data/tasks/Tasks.java ---
package herblore.data.tasks;

import java.util.LinkedList;
import java.util.List;

import lombok.Data;

@Data
public class Tasks {

	public enum Type {
		CLEAN_HERB,
		UNFINISHED_POTION,
		FULL_POTION
	}

	private Type type;
	private List<?> valid;

	public Tasks(Type type, List<?> valid) {
		this.type = type;
		this.valid = new LinkedList<>(valid);
	}

}

'''
'''--- instancedBandos/Core.java ---
package instancedBandos;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.util.Arrays;
import java.util.stream.Stream;

import api.Locations;
import api.Tasks;
import api.Variables;
import api.simple.KSObject;
import api.tasks.Token.INSTANCES;
import api.threads.PrayerObserver;
import api.utils.Timer;
import instancedBandos.data.Constants;
import instancedBandos.methods.GUI;
import instancedBandos.methods.Methods;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.GameState;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.robot.script.Script;

@ScriptManifest(author = "KremeSickle", category = Category.COMBAT, description = "KS | Bandos Killer", discord = "", name = "KS | Bandos Killer", servers = {
		"Zaros" }, version = "1.1")

public class Core extends Script implements LoopingScript {
	final String[] STOP_MESSAGES = { "be found:", "he owner of the username" };

	private PrayerObserver prayerObserver = null;

	@Override
	public void onChatMessage(ChatMessage msg) {
		if (msg.getType() == ChatMessageType.FRIENDSCHAT) {
			if (msg.getMessage().equals("<<<")) Variables.STOP = true;
		}
		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			if (msg.getMessage().contains("kill count")) Variables.COUNT++;
			if (msg.getMessage().contains("you are dead") && !Constants.USE_INSURANCE) Variables.STOP = true;
			if (!Variables.STOP) Variables.STOP = Stream.of(STOP_MESSAGES).anyMatch(msg1 -> msg.getMessage().contains(msg1));
		}
	}

	@Getter
	private Methods methods;
	private GUI gui = new GUI();

	@Override
	public void onExecute() {
		Tasks.init(ctx);
		Variables.reset();
		methods = new Methods(ctx);
		Constants.USUAL_ITEMS = ctx.equipment.populate().toStream().map(item -> item.getName()).toArray(String[]::new);

		Variables.LOOTABLES.clear();
		Variables.LOOTABLES
				.addAll(Arrays.asList("Bandos", "Godsword", "Rune platebody", "Coins", "Super restore", "Shark", "potato"));
		System.out.println("Loaded " + Variables.LOOTABLES.size() + " lootable items");

		prayerObserver = new PrayerObserver(ctx, () -> Variables.USE_PRAYER);
		prayerObserver.start();

		gui.setVisible(true);

	}

	@Override
	public void onProcess() {
		if (Variables.STOP) {
			if (!ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
				ctx.magic.castSpellOnce("Home Teleport");
			} else if (!ctx.players.getLocal().inCombat()) {
				while (ctx.getClient().getGameState() == GameState.LOGGED_IN) {
					ctx.sendLogout();
				}
			}
			return;
		}
		if (!Variables.STARTED) return;

		if (!ctx.pathing.inArea(Locations.EDGEVILLE_AREA) && Tasks.getAntiban().staffNearby()) {
			System.out.println("Staff found at " + ctx.players.getLocal().getLocation());
			Variables.STOP = true;
			return;
		}

		if (ctx.pathing.energyLevel() > 10) ctx.pathing.running(true);
		if (ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
			Tasks.getSkill().disablePrayers();
			if (!Tasks.getInventory().contains("token")) Variables.FORCE_BANK = true;
			if (!Tasks.getBanking().heal()) return;
			if (!Tasks.getBanking().usePreset()) return;
			Constants.DOOR_TILE = null;
			Tasks.getToken().handle(Constants.HOST_NAME, Constants.IS_HOST, Constants.USE_INSURANCE, INSTANCES.GENERAL_GRAARDOR);
		} else if (ctx.getClient().isInInstancedRegion()) {
			if (!Tasks.getSupplies().hasFood() || !Tasks.getSupplies().hasPrayer()) {
				ctx.magic.castSpellOnce("Home Teleport");
				return;
			}
			if (ctx.players.getLocal().getLocation().getRegionX() <= 46) {
				KSObject door = new KSObject(ctx.objects.populate().filter(26503).next());
				if (!door.isNull() && door.click("Open")) {
					if (Constants.DOOR_TILE == null) Constants.DOOR_TILE = door.getLocation();
					Variables.STATUS = "Going through door";
					ctx.sleep(500, 600);
					ctx.sleepCondition(() -> ctx.players.getLocal().getLocation().getRegionX() > 46, 1000);
					trip.restart();
					trips++;
				}
			} else {
				methods.handleBandos();
			}
		}
	}

	@Override
	public int loopDuration() {
		return 400;
	}

	@Override
	public void onTerminate() {
		Variables.reset();
		if (gui != null) gui.dispose();
		if (!ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) ctx.magic.castSpellOnce("Home Teleport");
		ctx.log("Shutting down.. Thank you for using the script");
	}

	private Timer trip = new Timer();
	private int trips = 0;

	@Override
	public void paint(Graphics Graphs) {
		Graphics2D g = (Graphics2D) Graphs;
		g.setColor(Color.BLACK);
		g.fillRect(5, 5, 200, 80);
		g.setColor(Color.GREEN);
		g.drawRect(5, 5, 200, 80);
		g.setColor(Color.CYAN);
		g.drawString("Uptime: " + Variables.START_TIME.toElapsedString(), 7, 20);
		g.drawString("Status: " + Variables.STATUS, 7, 35);
		g.drawString(String.format("Kills: %s (%s p/hr)", Variables.COUNT,
				ctx.paint.valuePerHour((int) Variables.COUNT, Variables.START_TIME.getStart())), 7, 48);
		g.drawString("Current trip: " + trip.toElapsedString(), 7, 61);
		g.drawString("Trips: " + trips, 7, 73);

	}

}

'''
'''--- instancedBandos/data/Constants.java ---
package instancedBandos.data;

import net.runelite.api.coords.WorldPoint;

public class Constants {

	public static boolean IS_HOST = false;
	public static boolean USE_INSURANCE = false;
	public static String[] USUAL_ITEMS = null;
	public static String HOST_NAME = "";
	public static boolean TANKING = false;
	public static boolean USE_SAFESPOT = true;

	public static WorldPoint DOOR_TILE = null;
	public static WorldPoint STAND_TILE = null;
}

'''
'''--- instancedBandos/methods/GUI.java ---
package instancedBandos.methods;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;

import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.border.EmptyBorder;

import api.Variables;
import instancedBandos.data.Constants;
import simple.robot.api.ClientContext;

@SuppressWarnings("serial")
public class GUI extends JFrame {

	private JPanel contentPane;
	private JTextField txtHostName;

	public GUI() {
		setTitle("GUI");
		setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		setBounds(100, 100, 281, 173);
		contentPane = new JPanel();
		contentPane.setBorder(new EmptyBorder(5, 5, 5, 5));
		setContentPane(contentPane);
		contentPane.setLayout(null);

		JButton btnStart = new JButton("Start");
		btnStart.setBounds(66, 94, 108, 23);
		contentPane.add(btnStart);

		txtHostName = new JTextField();
		txtHostName.setText("");
		txtHostName.setBounds(102, 8, 108, 20);
		contentPane.add(txtHostName);
		txtHostName.setColumns(10);

		JLabel lblNewLabel = new JLabel("Host name:");
		lblNewLabel.setBounds(22, 11, 70, 14);
		contentPane.add(lblNewLabel);

		JCheckBox chckbxTanking = new JCheckBox("Tanking");
		chckbxTanking.setBounds(6, 64, 77, 23);
		contentPane.add(chckbxTanking);

		JCheckBox chckbxSafeSpot = new JCheckBox("Use Safespot");
		chckbxSafeSpot.setBounds(130, 38, 129, 23);
		chckbxSafeSpot.setSelected(true);
		contentPane.add(chckbxSafeSpot);

		JCheckBox chckbxInsurance = new JCheckBox("Buy Insurance");
		chckbxInsurance.setBounds(6, 38, 122, 23);
		contentPane.add(chckbxInsurance);

		JCheckBox chckbxHosting = new JCheckBox("Hosting");
		chckbxHosting.setBounds(130, 64, 97, 23);
		contentPane.add(chckbxHosting);

		btnStart.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				Constants.TANKING = chckbxTanking.isSelected();
				Constants.USE_SAFESPOT = chckbxSafeSpot.isSelected();
				Constants.USE_INSURANCE = chckbxInsurance.isSelected();
				Constants.IS_HOST = chckbxHosting.isSelected();
				Constants.HOST_NAME = txtHostName.getText().trim();

				Variables.STARTED = true;
				dispose();
			}
		});

		addWindowListener(new WindowAdapter() {
			@Override
			public void windowClosing(java.awt.event.WindowEvent windowEvent) {
				if (JOptionPane.showConfirmDialog(contentPane, "Are you sure you want to close this window?", "Close Window?",
						JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION) {
					ClientContext.instance().stopScript();
				}
			}
		});
	}
}

'''
'''--- instancedBandos/methods/Methods.java ---
package instancedBandos.methods;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import api.Tasks;
import api.Variables;
import api.utils.Weapons;
import api.utils.Weapons.SPECIAL_WEAPONS;
import instancedBandos.data.Constants;
import net.runelite.api.NpcID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.filters.SimplePrayers.Prayers;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.wrappers.SimpleNpc;
import simple.robot.api.ClientContext;
import simple.robot.util.Random;

public class Methods {

	private ClientContext ctx;

	public Methods(ClientContext ctx) {
		this.ctx = ctx;
	}

	private final List<Integer> TARGETS = new ArrayList<Integer>(Arrays.asList(NpcID.GENERAL_GRAARDOR, NpcID.SERGEANT_STEELWILL,
			NpcID.SERGEANT_GRIMSPIKE, NpcID.SERGEANT_STRONGSTACK));

	public void handleBandos() {
		Variables.USE_PRAYER = true;
		SimpleNpc target = Tasks.getCombat().getNPC(TARGETS);
		int heal = Tasks.getInventory().isWearing(EquipmentSlot.WEAPON, "Guthan's warspear") ? 40 : 70;
		Weapons.SPECIAL_WEAPON = Weapons.getSpecialWeapon();
		if (Tasks.getSkill().getPercentage(Skills.HITPOINTS) < heal) Tasks.getSupplies().eat();
		Tasks.getCombat().checkPots();
		if (target != null) {
			if (Constants.STAND_TILE != null) Constants.STAND_TILE = null;
			if (target.getId() == NpcID.GENERAL_GRAARDOR) {
				if (target.getInteracting() != null && target.getInteracting().equals(ctx.players.getLocal().getPlayer()))
					Tasks.getSkill().addPrayer(Prayers.PROTECT_FROM_MELEE);
				else if (target.getInteracting() != null) Tasks.getSkill().addPrayer(Prayers.PROTECT_FROM_MISSILES);
				Tasks.getSkill().addPrayer(Prayers.PIETY);
				Tasks.getInventory().equipAll(Constants.USUAL_ITEMS);
			} else {
				if (Tasks.getSkill().getPercentage(Skills.HITPOINTS) < 90) Tasks.getInventory().equipGuthans();
				else Tasks.getInventory().equipAll(Constants.USUAL_ITEMS);

				if (Tasks.getCombat().isNpcAggressive(NpcID.SERGEANT_STEELWILL))
					Tasks.getSkill().addPrayer(Prayers.PROTECT_FROM_MAGIC);
				else if (Tasks.getCombat().isNpcAggressive(NpcID.SERGEANT_GRIMSPIKE))
					Tasks.getSkill().addPrayer(Prayers.PROTECT_FROM_MISSILES);
				else if (Tasks.getCombat().isNpcAggressive(NpcID.SERGEANT_STRONGSTACK))
					Tasks.getSkill().addPrayer(Prayers.PROTECT_FROM_MELEE);
				else Tasks.getSkill().removeAllBut(Prayers.PIETY);
			}

			if (ctx.players.getLocal().getInteracting() == null
					|| !ctx.players.getLocal().getInteracting().getName().equals(target.getName())) {
				if ((Weapons.SPECIAL_WEAPON == SPECIAL_WEAPONS.S_GODSWORD && ctx.skills.level(Skills.HITPOINTS) < 70)
						&& (Weapons.canSpecial(false) || Weapons.canSpecial(true)))
					Tasks.getCombat().useSpecialAttack(target);
				else Tasks.getCombat().attack(target);
			}
		} else {
			Tasks.getInventory().equipAll(Constants.USUAL_ITEMS);
			Variables.STATUS = "Waiting for respawn";
			Tasks.getSkill().disablePrayers();
			Tasks.getBanking().prayAtAltar("Bandos altar");
			if (!Tasks.getLoot().loot(Variables.LOOTABLES)) walkSafeSpot();
		}
	}

	private void walkSafeSpot() {
		if (!Constants.USE_SAFESPOT) return;

		if (Constants.STAND_TILE == null) {
			int x = Constants.TANKING ? Constants.DOOR_TILE.getX() + 6 : Constants.DOOR_TILE.getX() + 1;
			int y = Constants.TANKING ? Constants.DOOR_TILE.getY() + 7
					: Random.between(Constants.DOOR_TILE.getY() + 2, Constants.DOOR_TILE.getY() + 15);
			Constants.STAND_TILE = new WorldPoint(x, y, 2);
		}
		if (!ctx.pathing.onTile(Constants.STAND_TILE)) {
			Variables.STATUS = "Walking to safe spot";
			ctx.pathing.step(Constants.STAND_TILE);
		}
	}
}

'''
'''--- molten/MoltenGlass.java ---
package molten;

import java.awt.Graphics;
import java.util.stream.Stream;

import javax.swing.JFrame;

import molten.data.Shops;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ItemID;
import simple.api.Utils;
import simple.api.Variables;
import simple.api.panel.Config;
import simple.api.panel.Panel;
import simple.api.panel.Tabs;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Magic.SpellBook;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.script.Script;

@ScriptManifest(author = "KremeSickle", category = Category.CRAFTING, description = "<br>Either purchase the ingredients to create molten glass or use the Superglass Make spell to create it.<br><br>Script will stop once out of coins/supplies.<br><br>To buy supplies, have your last-preset with coins in inventory only and start at selected location<br><br>To cast spell, have your last-preset with astral runes, fire runes, x13 seaweed, x13 bucket of sand & equipped staff of air. Start in Edgeville", discord = "Datev#0660", name = "KS | Molten Glass", servers = {
		"Zaros" }, version = "2", vip = true)
public class MoltenGlass extends Script implements LoopingScript {

	private JFrame frame;
	private Panel panel;

	@Override
	public void onExecute() {
		try {
			Variables.reset();
			addConfig();
			String title = Utils.getValue(getClass(), "name") + " v" + Utils.getValue(getClass(), "version");
			panel = new Panel();
			frame = panel.init(title, panel);
			Utils.setZoom(1);
		} catch (Exception e) {
			ctx.log(e.getMessage());
			e.printStackTrace();
		}
	}

	public enum BUYABLE {
		BUCKET_OF_SAND,
		SEAWEED,
		SODA_ASH
	}

	public void addConfig() {
		Config.TABS.add(new Tabs(0, "Script Config", "Choose your configuration"));
		Config.CONFIGURATION
				.add(new Config(0, boolean.class, false, "Create Molten Glass", "Use the spell to create molten glass", "spell"));
		Config.CONFIGURATION.add(new Config(0, boolean.class, true, "Purchase items", "Purchase Items?", "purchase"));
		Config.CONFIGURATION.add(new Config(0, BUYABLE.class, "BUCKET_OF_SAND", "", "Purchase this item", "itemPurchase"));
		Config.CONFIGURATION.add(new Config(0, Shops.class, "CATHERBY", "", "Location to shop at", "shopLocation"));
		Config.CONFIGURATION.add(new Config(0, boolean.class, false, "Logout on finish", "Logout on finish?", "logout"));

		Config.setConfigChanged(true);
	}

	public void getPreset() {
		SimpleObject bank = ctx.objects.populate().filter(Config.getB("purchase") ? getLocation().getBankId() : 10355).nearest()
				.next();
		if (bank != null && bank.validateInteractable()) {
			Variables.STATUS = "Getting last preset";
			if (bank.click("Last-preset")) {
				ctx.onCondition(() -> ctx.inventory.populate().population() == 1, 500);
			}
		}
	}

	public void bank() {
		SimpleObject bank = ctx.objects.populate().filter(getLocation().getBankId()).nearest().next();
		if (bank == null || bank.distanceTo(ctx.players.getLocal()) > 9) {
			Variables.STATUS = "Walking path to bank";
			if (Config.getB("purchase")) {
				ctx.pathing.walkPath(getLocation().getPath(), true);
				ctx.sleepCondition(() -> ctx.pathing.inMotion(), 1500);
			} else {
				Variables.STATUS = "Teleport to edgeville";
			}
		} else {
			if (!getLocation().isDepositBox()) {
				getPreset();
				return;
			}
			if (!ctx.bank.depositBoxOpen()) {
				Variables.STATUS = "Opening deposit box";
				if (bank.click("Deposit")) ctx.sleepCondition(() -> ctx.bank.depositBoxOpen(), 650);
			} else {
				Variables.STATUS = "Depositing items";
				if (ctx.bank.depositAllExcept(995)) ctx.sleepCondition(() -> ctx.bank.populate().population() == 1, 450);
			}
		}
	}

	public void doBuy() {
		if (ctx.inventory.inventoryFull()) {
			bank();
		} else {
			SimpleNpc npc = ctx.npcs.populate().filter(getLocation().getNpcId()).nearest().next();
			if (npc == null || npc.distanceTo(ctx.players.getLocal()) > 10) {
				Variables.STATUS = "Walking path to npc";
				ctx.pathing.walkPath(getLocation().getPath());
				return;
			}
			if (!ctx.shop.shopOpen()) {
				Variables.STATUS = "Opening shop";
				if (npc.validateInteractable() && npc.click("Trade")) {
					ctx.sleep(75, 150);
					ctx.sleepCondition(() -> ctx.shop.shopOpen());
				}
			} else {
				Variables.STATUS = "Buying ingredients";
				SimpleItem shop = ctx.shop.populate().filter(getItem()).next();
				if (shop.getQuantity() > 0) {
					shop.click("Buy 10");
					ctx.sleep(150, 200);
				}
			}
		}
	}

	public boolean hasItem(int id) {
		return ctx.inventory.populate().filter(id).population() > 0;
	}

	public void doMake() {
		if (hasItem(ItemID.BUCKET_OF_SAND) && (hasItem(ItemID.GIANT_SEAWEED) || hasItem(ItemID.SEAWEED)
				|| hasItem(ItemID.SODA_ASH) || hasItem(ItemID.SWAMP_WEED))) {
			Variables.STATUS = "Casting spell";
			if (ctx.magic.castSpellOnce("Superglass make")) {
				ctx.sleep(350, 600);
				ctx.onCondition(() -> hasItem(ItemID.MOLTEN_GLASS));
			}
		} else {
			getPreset();
		}
	}

	@Override
	public void onProcess() {
		if (Variables.PAUSED) return;
		if (Variables.STOP) {
			if (Config.getB("logout")) ctx.sendLogout();
			else ctx.stopScript();
			return;
		}
		if (!Variables.STARTED) {
			Variables.STATUS = "Waiting to be started";
			return;
		}

		if (Config.getB("purchase")) {
			if (!getLocation().inDistance()) {
				Variables.STATUS = "Teleport near start area";
				return;
			}
			if (!hasCoins()) {
				Variables.STATUS = "Get more coins";
				return;
			}
			doBuy();
		} else if (Config.getB("spell")) {
			if (!hasMagicLevel() || !onLunars() || !hasRunes()) {
				Variables.STATUS = "Get requirements for spell";
				return;
			}
			doMake();
		}
	}

	@Override
	public int loopDuration() {
		return 150;
	}

	@Override
	public void paint(Graphics Graphs) {
		if (panel != null) panel.update(Variables.STATUS);
	}

	final String[] STOP_MESSAGES = { "don't have the required", "not be found:", "enough coins" };

	@Override
	public void onChatMessage(ChatMessage msg) {
		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			if (!Variables.STOP) {
				Variables.STOP = Stream.of(STOP_MESSAGES).anyMatch(msg1 -> msg.getMessage().contains(msg1));
			}
		}
	}

	public boolean hasCoins() {
		return ctx.inventory.populate().filter(995).population(true) > 1000;
	}

	public boolean onLunars() {
		return ctx.magic.spellBook() == SpellBook.LUNAR;
	}

	public boolean hasMagicLevel() {
		return ctx.skills.level(Skills.MAGIC) >= 77;
	}

	public boolean hasRunes() {
		return ctx.inventory.populate().filter("Astral rune", "Fire rune").population() == 2;
	}

	@Override
	public void onTerminate() {
		if (frame != null) frame.dispose();
		ctx.log("Shutting down.. Thank you for using the script");
		Variables.reset();
		Config.clear();
	}

	public Shops getLocation() {
		return Config.getValue("shopLocation");
	}

	public String getItem() {
		BUYABLE item = Config.getValue("itemPurchase");
		return Utils.formatString(item.name()).replace("_", " ");
	}

}

'''
'''--- molten/data/Shops.java ---
package molten.data;

import java.util.Arrays;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;
import simple.api.Utils;
import simple.robot.api.ClientContext;

@AllArgsConstructor
@Getter
public enum Shops {

	CATHERBY(9312, 10355, false,
			new WorldPoint[] { new WorldPoint(2808, 3439, 0), new WorldPoint(2804, 3432, 0), new WorldPoint(2803, 3420, 0),
					new WorldPoint(2795, 3413, 0) }),
	PORT_SARIM(9379, 26254, true,
			new WorldPoint[] { new WorldPoint(3045, 3235, 0), new WorldPoint(3035, 3235, 0), new WorldPoint(3027, 3234, 0),
					new WorldPoint(3027, 3226, 0), new WorldPoint(3027, 3218, 0), new WorldPoint(3027, 3210, 0),
					new WorldPoint(3027, 3204, 0), new WorldPoint(3031, 3198, 0), new WorldPoint(3035, 3193, 0),
					new WorldPoint(3040, 3193, 0)
			}),
	PORT_PHASMATYS(9314, 29106, true,
			new WorldPoint[] { new WorldPoint(3689, 3469, 0), new WorldPoint(3690, 3473, 0), new WorldPoint(3699, 3474, 0),
					new WorldPoint(3699, 3482, 0), new WorldPoint(3699, 3490, 0), new WorldPoint(3699, 3496, 0),
					new WorldPoint(3702, 3500, 0) }),
	PORT_KHAZARD(9317, 26707, false, new WorldPoint[] {

			new WorldPoint(2661, 3159, 0), new WorldPoint(2662, 3154, 0), new WorldPoint(2667, 3149, 0),
			new WorldPoint(2673, 3148, 0) })
	;

	private int npcId, bankId;
	private boolean depositBox;
	private WorldPoint[] path;

	public boolean inDistance() {
		try {
			double bankDistance = ClientContext.instance().pathing.distanceTo(this.getPath()[0]);
			double shopDistance = ClientContext.instance().pathing.distanceTo(this.getPath()[this.getPath().length - 1]);
			return bankDistance < 30 && shopDistance < 30;
		} catch (ArrayIndexOutOfBoundsException e) {
			return false;
		}
	}

	public String getName() {
		return Utils.formatString(this.name().split("_"));
	}

	public static Shops find(String name) {
		return Arrays.asList(Shops.values()).stream().filter(val -> val.getName().equals(name)).findFirst().orElse(null);
	}

	public static String[] getNames() {
		return Arrays.asList(Shops.values()).stream().map(Shops::getName).toArray(String[]::new);
	}

}

'''
'''--- prayer/AltarPrayer.java ---
package prayer;

import java.awt.Graphics;
import java.util.regex.Pattern;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import javax.swing.JFrame;

import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import simple.api.Utils;
import simple.api.Variables;
import simple.api.panel.Config;
import simple.api.panel.Panel;
import simple.api.panel.Tabs;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.script.Script;
import simple.robot.utils.WorldArea;

@ScriptManifest(author = "KremeSickle", category = Category.PRAYER, description = "<br>Uses altar in public / own POH w/ lighting option<br><br>Start the script in Edgeville<br><br>Have bones as your last preset (Marrentills + tinderbox if lighting)<br><br>Script will run until no more bones in preset<br><br>Please report all bugs to me on Discord", discord = "Datev#0660", name = "KS | POH Altar for Bones", servers = {
		"Zaros" }, version = "2")
public class AltarPrayer extends Script implements LoopingScript {
	private final WorldArea EDGEVILLE = new WorldArea(new WorldPoint(3074, 3515, 0), new WorldPoint(3105, 3480, 0));

	private JFrame frame;
	private Panel panel;

	@Override
	public void onExecute() {
		try {
			Variables.reset();
			addConfig();
			String title = Utils.getValue(getClass(), "name") + " v" + Utils.getValue(getClass(), "version");
			panel = new Panel();
			frame = panel.init(title, panel);
			Utils.setZoom(1);
		} catch (Exception e) {
			ctx.log(e.getMessage());
			e.printStackTrace();
		}
	}

	private boolean VALID_HOST = false;

	public void addConfig() {
		Config.TABS.add(new Tabs(0, "Script Config", "Choose your configuration"));

		Config.CONFIGURATION
				.add(new Config(0, boolean.class, true, "Use Own House", "Use your own house instead of public", "ownHouse"));
		Config.CONFIGURATION
				.add(new Config(0, boolean.class, true, "Light Burners", "Light incense burners yourself", "doLight"));

		Config.CONFIGURATION.add(new Config(0, boolean.class, false, "Logout on finish", "Logout on finish?", "logout"));

		Config.setConfigChanged(true);
	}

	public SimpleWidget validHouse() {
		SimpleWidget w = ctx.widgets.getWidget(52, 13);
		int index = IntStream.range(0, w.getChildren().length).filter(i -> "Y".equals(w.getChild(i).getText())).findFirst()
				.orElse(-1);
		return index > -1 ? ctx.widgets.getWidget(52, 19).getChild(index) : null;
	}

	public int getBones() {
		return ctx.inventory.populate().filter(Pattern.compile("(.*) bones")).population();
	}

	@Override
	public void onProcess() {
		if (Variables.PAUSED) return;
		if (Variables.STOP && getBones() == 0) {
			if (Config.getB("logout")) ctx.sendLogout();
			else ctx.stopScript();
			return;
		}
		if (!Variables.STARTED) {
			Variables.STATUS = "Waiting to be started";
			return;
		}
		if (ctx.pathing.inArea(EDGEVILLE)) {
			SimpleObject portal = ctx.objects.populate().filter("Portal").nearest().next();
			SimpleObject post = ctx.objects.populate().filter("House Advertisement").nearest().next();
			if (getBones() == 0) {
				bank();
				return;
			}
			if (ctx.pathing.distanceTo(portal.getLocation()) > 4) {
				Variables.STATUS = "Walking path to portal";
				ctx.pathing.step(Config.getB("ownHouse") ? portal.getLocation() : post.getLocation());
				return;
			}
			if (Config.getB("ownHouse")) {
				Variables.STATUS = "Entering own house";
				if (portal.validateInteractable() && portal.click("Home"))
					ctx.onCondition(() -> ctx.getClient().isInInstancedRegion());
			} else if (VALID_HOST) {
				Variables.STATUS = "Entering last visited house";
				if (post.validateInteractable() && post.click("Visit-Last"))
					ctx.onCondition(() -> ctx.getClient().isInInstancedRegion());
			} else {
				SimpleWidget houses = ctx.widgets.getWidget(52, 8);
				if (houses != null && houses.visibleOnScreen()) {
					SimpleWidget houseList = validHouse();
					if (houseList != null && houseList.visibleOnScreen()) {
						Variables.STATUS = "Entering house";
						if (houseList.click(0)) {
							VALID_HOST = true;
							ctx.onCondition(() -> ctx.getClient().isInInstancedRegion());
						}
					} else {
						Variables.STATUS = "No valid hosts.. refreshing";
						SimpleWidget refresh = ctx.widgets.getWidget(52, 30);
						if (refresh != null && refresh.visibleOnScreen()) {
							if (refresh.click(0)) {
								ctx.sleep(7000, 10000);
							}
						}
					}
				} else {
					if (post != null && post.validateInteractable()) {
						if (post.click("View")) ctx.onCondition(() -> ctx.widgets.getWidget(52, 8) != null);
					}
				}
			}

		} else if (ctx.getClient().isInInstancedRegion()) {
			if (ctx.widgets.getWidget(71, 5) != null) return;
			SimpleObject altar = ctx.objects.populate().filter("Altar").nearest().next();
			SimpleItem bone = ctx.inventory.populate().filter(Pattern.compile("(.*) bones")).next();
			if (altar == null) {
				Variables.STATUS = "Can't find altar";
				VALID_HOST = false;
				if (!Config.getB("ownHouse")) teleportHome();
				return;
			}
			if (bone == null) {
				teleportHome();
				return;
			}
			if (Config.getB("doLight")) {
				SimpleObject unlit = ctx.objects.populate().filter(13212).nearest().next();
				if (unlit != null && ctx.inventory.populate().filter("Marrentill").population() > 0
						&& ctx.inventory.populate().filter("Tinderbox").population() > 0) {
					Variables.STATUS = "Relighting burners";
					if (unlit.click("Light")) ctx.onCondition(() -> ctx.players.getLocal().getAnimation() != -1);
					return;
				}
			}
			if (ctx.players.getLocal().getAnimation() == 896) {
				Variables.STATUS = "Gaining some experience";
				return;
			}

			if (altar.validateInteractable() && bone.click("Use")) {
				Variables.STATUS = "Using bones on altar";
				ctx.onCondition(() -> ctx.inventory.itemSelectionState() == 1);
				if (altar.click(0)) ctx.onCondition(() -> ctx.players.getLocal().getAnimation() == 896);
			}
		}
	}

	@Override
	public int loopDuration() {
		return 200;
	}

	@Override
	public void onTerminate() {
		VALID_HOST = false;

		if (frame != null) frame.dispose();
		ctx.log("Shutting down.. Thank you for using the script");
		Variables.reset();
		Config.clear();
	}

	@Override
	public void paint(Graphics Graphs) {
		if (panel != null) panel.update(Variables.STATUS);
	}

	final String[] STOP_MESSAGES = { "not be found:" };

	@Override
	public void onChatMessage(ChatMessage msg) {
		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			if (msg.getMessage().contains("don't have any recent") || msg.getMessage().contains("owner is not at home")) {
				VALID_HOST = false;
			}
			if (!Variables.STOP) {
				Variables.STOP = Stream.of(STOP_MESSAGES).anyMatch(msg1 -> msg.getMessage().contains(msg1));
			}
		}
	}

	public void teleportHome() {
		Variables.STATUS = "Teleporting home";
		ctx.magic.castSpellOnce("Home");
		ctx.onCondition(() -> ctx.pathing.inArea(EDGEVILLE));
	}

	public void bank() {
		SimpleObject bank = ctx.objects.populate().filter("Bank booth").nearest().next();
		if (bank == null || bank.distanceTo(ctx.players.getLocal()) > 5) {
			Variables.STATUS = "Walking path to bank";
			ctx.pathing.step(bank.getLocation());
		} else if (bank.validateInteractable()) {
			Variables.STATUS = "Getting last preset";
			if (bank.click("Last-preset")) {
				ctx.onCondition(() -> ctx.inventory.populate().population() > 0, 500);
			}
		}
	}

}

'''
'''--- simple/api/EventDispatcher.java ---
package simple.api;

import java.util.ArrayList;
import java.util.EventListener;
import java.util.EventObject;
import java.util.List;

import simple.api.listeners.ConfigChangeEvent;
import simple.api.listeners.ConfigChangeListener;

public class EventDispatcher {
	private final List<EventListener> listeners;
	private final Object syncLock = new Object();
	private volatile boolean running;

	public EventDispatcher() {
		this.listeners = new ArrayList<EventListener>();
		this.running = true;
	}

	public void addListener(EventListener listener) {
		synchronized (syncLock) {
			listeners.add(listener);
		}
	}

	public void removeListener(EventListener listener) {
		synchronized (syncLock) {
			listeners.remove(listener);
		}
	}

	public EventDispatcher clearListeners() {
		synchronized (syncLock) {
			listeners.clear();
		}
		return this;
	}

	public void fireEvent(EventObject event) {
		synchronized (syncLock) {
			for (EventListener listener : listeners) {
				if (listener instanceof ConfigChangeListener) {
					((ConfigChangeListener) listener).onChange((ConfigChangeEvent) event);
				}
			}
		}
	}

	public boolean isRunning() {
		return running;
	}

	public EventDispatcher setRunning(boolean running) {
		this.running = running;
		return this;
	}

}
'''
'''--- simple/api/Locations.java ---
package simple.api;

import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

public class Locations {

	public final static WorldArea EDGEVILLE_AREA = new WorldArea(new WorldPoint(3074, 3515, 0), new WorldPoint(3105, 3480, 0));

	public static final WorldArea BARROWS_HILLS = new WorldArea(
			new WorldPoint[] { new WorldPoint(3565, 3314, 0), new WorldPoint(3543, 3299, 0), new WorldPoint(3547, 3270, 0),
					new WorldPoint(3566, 3266, 0), new WorldPoint(3584, 3275, 0), new WorldPoint(3583, 3306, 0) });

	public static final WorldArea BARROWS_FINAL_SARCO = new WorldArea(new WorldPoint(3547, 9700, 0),
			new WorldPoint(3558, 9690, 0));

}

'''
'''--- simple/api/Timer.java ---
package simple.api;

import lombok.Getter;
import simple.robot.util.Time;

public class Timer {
	@Getter
	public long start;

	private long period;

	private long end;

	public String toElapsedString() {
		return Time.formatTime(getElapsed());
	}

	public long setEndIn(long l) {
		this.end = System.currentTimeMillis() + l;
		return this.end;
	}

	public String toRemainingString() {
		return Time.formatTime(getRemaining());
	}

	public void reset() {
		this.end = System.currentTimeMillis() + this.period;
	}

	public Timer() {
		this.period = this.start = System.currentTimeMillis();
	}

	public void restart() {
		this.period = this.start = System.currentTimeMillis();
	}

	public Timer(long l) {
		this.period = l;
		this.start = System.currentTimeMillis();
		this.end = this.start + l;
	}

	public long getElapsed() {
		return System.currentTimeMillis() - this.start;
	}

	public long getRemaining() {
		if (isRunning()) return this.end - System.currentTimeMillis();
		return 0L;
	}

	public boolean isRunning() {
		return System.currentTimeMillis() < this.end;
	}
}
'''
'''--- simple/api/Utils.java ---
package simple.api;

import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.annotation.Annotation;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.imageio.ImageIO;

import net.runelite.api.coords.WorldPoint;
import simple.hooks.simplebot.Game.Tab;
import simple.hooks.simplebot.Magic.SpellBook;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.api.ClientContext;
import simple.robot.utils.WorldArea;

public class Utils {

	public static boolean openBank() {
		if (!ClientContext.instance().bank.bankOpen()) {
			if (ClientContext.instance().inventory.itemSelectionState() == 1) {
				ClientContext.instance().pathing.running(!ClientContext.instance().pathing.running());
				return false;
			}
			SimpleObject bank = ClientContext.instance().objects.populate().filter("Bank booth", "Bank Chest").nearest().next();
			if (bank != null && bank.validateInteractable() && (bank.click("Bank") || bank.click("Use")))
				ClientContext.instance().onCondition(() -> ClientContext.instance().bank.bankOpen());
		}
		return ClientContext.instance().bank.bankOpen();
	}

	public static String formatString(String... str) {
		return Arrays.asList(str).stream().map(t -> t.substring(0, 1).toUpperCase() + t.substring(1).toLowerCase())
				.collect(Collectors.joining(" "));
	}

	public static boolean directTeleport(String teleport) {
		ClientContext ctx = ClientContext.instance();
		ctx.bank.closeBank();
		ctx.shop.closeShop();

		openTab(Tab.MAGIC);
		SimpleWidget widget = ctx.widgets.getWidget(218, ctx.magic.spellBook() == SpellBook.MODERN ? 5 : 99);
		Variables.STATUS = "Teleporting to " + teleport;
		String[] actions = widget.getWidget().getActions();
		boolean action = actions.length > 0 && actions[actions.length - 1].contains(teleport);
		if (!action) return false;
		if (widget.click(3)) {
			ctx.sleep(450);
			ctx.sleepCondition(() -> ctx.players.getLocal().getAnimation() != -1, 450);
			ctx.sleepCondition(() -> ctx.players.getLocal().getAnimation() == -1, 550);
			ctx.sleep(1500);

		}
		return true;
	}

	public static void openTab(Tab tab) {
		if (!isTabOpen(tab)) ClientContext.instance().game.tab(tab);
	}

	public static boolean isTabOpen(Tab tab) {
		return ClientContext.instance().game.tab().equals(tab);
	}

	public static boolean license(String url) throws Exception {
		URLConnection conn = new URL(url).openConnection();
		List<Integer> ids = new ArrayList<Integer>();
		try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
			reader.lines().mapToInt(Integer::parseInt).forEach(ids::add);
		}
		return ids.contains(ClientContext.instance().user.forumsId());
	}

	public static WorldArea makeArea(int x, int y, int x2, int y2, int z) {
		return new WorldArea(new WorldPoint(x, y, z), new WorldPoint(x2, y2, z));
	}

	public static String formatNumber(long num) {
		String[] suffix = new String[] { "K", "M", "B", "T" };
		int size = (num != 0) ? (int) Math.log10(num) : 0;
		if (size >= 3) {
			while (size % 3 != 0) {
				size = size - 1;
			}
		}
		String ret = (size >= 3) ? (+(Math.round((num / Math.pow(10, size)) * 10) / 10d) + suffix[(size / 3) - 1]) : +num + "";
		if (!ret.endsWith("B") || ret.endsWith("0B")) ret = ret.replaceAll("\\.\\d+", "");
		return ret;

	}

	public static String getValue(Class<?> reflectClass, String val) {
		Annotation[] anno = reflectClass.getAnnotations();
		Class<? extends Annotation> type = anno[0].annotationType();
		return (String) Stream.of(type.getDeclaredMethods()).filter(m -> m.getName().equalsIgnoreCase(val)).map(m -> {
			try {
				return m.invoke(anno[0], (Object[]) null);
			} catch (Exception e) {
				e.printStackTrace();
				return "";
			}
		}).findFirst().orElse(null);
	}

	public static void setZoom(int zoom) {
		ClientContext ctx = ClientContext.instance();
		ctx.viewport.pitch(100);
		ctx.viewport.angle(0);

		openTab(Tab.OPTIONS);

		SimpleWidget widget = ctx.widgets.getWidget(261, 8 + zoom);
		if (widget != null && widget.visibleOnScreen()) widget.click(0);
	}

	public static BufferedImage getImage(String path, String url) {
		try {
			String[] split = url.split("/");
			return ImageIO.read(new File(path + split[split.length - 1]));
		} catch (IOException e) {
			return downloadImage(path, url);
		}
	}

	public static BufferedImage downloadImage(String path, String str) {
		BufferedImage image = null;
		try {
			final URL url = new URL(str);
			final HttpURLConnection connection = (HttpURLConnection) url.openConnection();
			connection.setRequestProperty("User-Agent",
					"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.65 Safari/537.31");
			image = ImageIO.read(connection.getInputStream());
			if (image != null) {
				String[] split = str.split("/");
				ImageIO.write(image, "png", new File(path + "/" + split[split.length - 1]));
			}
			return image;
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}
	}

	public static boolean validWidget(SimpleWidget w) {
		return w != null && w.visibleOnScreen();
	}

}

'''
'''--- simple/api/Variables.java ---
package simple.api;

public class Variables {

	public static String DEBUG = "";
	public static Timer START_TIME = new Timer();
	public static String STATUS = "Booting up";
	public static boolean STOP;
	public static boolean STARTED;
	public static boolean PAUSED;

	public static EventDispatcher DISPATCHER;

	public static int COUNT = 0;
	public static boolean[] CACHED_BOOLEANS = new boolean[10];
	public static String LAST_MESSAGE = "";

	public static void reset() {
		START_TIME.restart();
		LAST_MESSAGE = "";
		DISPATCHER = new EventDispatcher();
		STOP = false;
		STARTED = false;
		PAUSED = true;
		COUNT = 0;
		DEBUG = "";
		CACHED_BOOLEANS = new boolean[10];
		STATUS = "Booting up";
	}

}

'''
'''--- simple/api/listeners/ConfigChangeEvent.java ---
package simple.api.listeners;

import java.util.EventObject;

import lombok.Getter;
import simple.api.panel.Config;

@SuppressWarnings("serial")
public class ConfigChangeEvent extends EventObject {

	public ConfigChangeEvent(Config newConfig, Config oldConfig) {
		super(newConfig);
		this.newConfig = newConfig;
		this.oldConfig = oldConfig;
	}

	@Getter
	public Config newConfig;
	@Getter
	public Config oldConfig;
}

'''
'''--- simple/api/listeners/ConfigChangeListener.java ---
package simple.api.listeners;

import java.util.EventListener;

public interface ConfigChangeListener extends EventListener {
	void onChange(ConfigChangeEvent event);
}

'''
'''--- simple/api/panel/Config.java ---
package simple.api.panel;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.Rectangle;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;

import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.util.ColorUtil;
import simple.api.panel.options.Range;

@Getter
@RequiredArgsConstructor
public class Config {

	public static List<Tabs> TABS = new ArrayList<>();

	public static List<Config> CONFIGURATION = new ArrayList<>();

	@NonNull
	private int section;
	@NonNull
	private Object type;
	@NonNull
	@Setter
	private Object value;
	@NonNull
	private String text, tooltip, keyName;

	private Range range;
	private boolean changeable = true;
	private int cached = -1;

	public Config(int section, Object type, Object defaultValue, String text, String tooltip, String keyName, Range range) {
		this.section = section;
		this.type = type;
		this.keyName = keyName;
		this.text = text;
		this.value = defaultValue;
		this.tooltip = tooltip;
		this.range = range;
	}

	public Config(int section, Object type, Object defaultValue, String text, String tooltip, String keyName,
			boolean changeable) {
		this.section = section;
		this.type = type;
		this.keyName = keyName;
		this.text = text;
		this.value = defaultValue;
		this.tooltip = tooltip;
		this.changeable = changeable;
	}

	public Config(int section, Object type, Object defaultValue, String text, String tooltip, String keyName, int cached) {
		this.section = section;
		this.type = type;
		this.keyName = keyName;
		this.text = text;
		this.value = defaultValue;
		this.tooltip = tooltip;
		this.cached = cached;
	}

	public static void clear() {
		CONFIGURATION.clear();
		TABS.clear();
	}

	public static Config getItem(String keyName) {
		return Config.CONFIGURATION.stream().filter(val -> val.getKeyName().equals(keyName)).findFirst().orElse(null);
	}

	public static <T> T getValue(String keyName) {
		Config value = getItem(keyName);
		try {
			return (T) stringToObject(value.getValue().toString(), (Class<?>) value.getType());
		} catch (Exception e) {
			System.out.println(e);
		}
		return null;
	}

	public static Object stringToObject(String str, Class<?> type) {
		if (type == boolean.class || type == Boolean.class) { return Boolean.parseBoolean(str); }
		if (type == int.class) { return Integer.parseInt(str); }
		if (type == Color.class) { return ColorUtil.fromString(str); }
		if (type.isEnum()) { return Enum.valueOf((Class<? extends Enum>) type, str); }
		if (type == Instant.class) { return Instant.parse(str); }
		if (type == WorldPoint.class) {
			String[] splitStr = str.split(":");
			int x = Integer.parseInt(splitStr[0]);
			int y = Integer.parseInt(splitStr[1]);
			int plane = Integer.parseInt(splitStr[2]);
			return new WorldPoint(x, y, plane);
		}
		return str;
	}

	public static String objectToString(Object object) {
		if (object instanceof Color) { return String.valueOf(((Color) object).getRGB()); }
		if (object instanceof Enum) { return ((Enum) object).name(); }
		if (object instanceof Dimension) {
			Dimension d = (Dimension) object;
			return d.width + "x" + d.height;
		}
		if (object instanceof Point) {
			Point p = (Point) object;
			return p.x + ":" + p.y;
		}
		if (object instanceof Rectangle) {
			Rectangle r = (Rectangle) object;
			return r.x + ":" + r.y + ":" + r.width + ":" + r.height;
		}
		if (object instanceof Instant) { return ((Instant) object).toString(); }
		if (object instanceof WorldPoint) {
			WorldPoint wp = (WorldPoint) object;
			return wp.getX() + ":" + wp.getY() + ":" + wp.getPlane();
		}
		if (object instanceof Duration) { return Long.toString(((Duration) object).toMillis()); }
		if (object instanceof byte[]) { return Base64.getUrlEncoder().encodeToString((byte[]) object); }
		return object == null ? null : object.toString();
	}

	public static boolean getB(String val) {
		return Config.getValue(val);
	}

	public static int getI(String val) {
		return Config.getValue(val);
	}

	public static String getS(String val) {
		return Config.getValue(val);
	}

	@Getter
	@Setter
	public static boolean configChanged;
}

'''
'''--- simple/api/panel/Panel.java ---
package simple.api.panel;

import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.ItemEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;

import javax.imageio.ImageIO;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JFormattedTextField;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSpinner;
import javax.swing.JTextArea;
import javax.swing.SpinnerModel;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingUtilities;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import javax.swing.text.JTextComponent;

import com.google.common.base.Strings;
import com.google.common.primitives.Ints;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.ComboBoxListRenderer;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;
import net.runelite.client.util.Text;
import simple.api.Variables;
import simple.api.listeners.ConfigChangeEvent;
import simple.api.panel.options.Range;
import simple.robot.api.ClientContext;
import simple.robot.utils.ScriptUtils;

public class Panel extends PluginPanel {

	private static ImageIcon SECTION_EXPAND_ICON;
	private static ImageIcon SECTION_EXPAND_ICON_HOVER;
	private static ImageIcon SECTION_RETRACT_ICON;
	private static ImageIcon SECTION_RETRACT_ICON_HOVER;

	private static final int SPINNER_FIELD_WIDTH = 6;

	static {
		try {
			BufferedImage sectionRetractIcon = ImageIO
					.read(Panel.class.getClassLoader().getResource("resources/arrow_right.png"));
			sectionRetractIcon = ImageUtil.luminanceOffset(sectionRetractIcon, -121);
			SECTION_EXPAND_ICON = new ImageIcon(sectionRetractIcon);
			SECTION_EXPAND_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(sectionRetractIcon, -100));
			final BufferedImage sectionExpandIcon = ImageUtil.rotateImage(sectionRetractIcon, Math.PI / 2);
			SECTION_RETRACT_ICON = new ImageIcon(sectionExpandIcon);
			SECTION_RETRACT_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(sectionExpandIcon, -100));
		} catch (Exception e) {
			ClientContext.instance().log(e.getMessage());
		}
	}

	public Panel() {
		add(getHeader());

		Config.TABS.forEach(tab -> {
			JPanel t = buildTab(tab.getTitle(), tab.getDescription());
			buildConfig(tab.getIndex(), t);
			add(t);
			add(Box.createRigidArea(new Dimension(0, 10)));
		});
		add(getButton());
	}

	private JFrame frame;

	public JFrame init(String title, Panel panel) throws IOException {
		frame = new JFrame();
		BufferedImage icon = ImageIO.read(getClass().getClassLoader().getResource("resources/KS.png"));
		JScrollPane scroller = new JScrollPane(panel);
		scroller.setViewportView(panel);
		scriptName.setText(title);
		frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		frame.setTitle("KS GUI");
		frame.setIconImage(icon);
		frame.setResizable(false);
		frame.setMinimumSize(new Dimension(275, 0));
		frame.add(scroller);
		frame.pack();
		frame.repaint();
		frame.setVisible(true);

		frame.addWindowListener(new WindowAdapter() {
			@Override
			public void windowClosing(WindowEvent windowEvent) {
				if (JOptionPane.showConfirmDialog(frame, "Are you sure you want to close this window?", "Close Window?",
						JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION) {
					ClientContext.instance().stopScript();
				}
			}
		});
		return frame;
	}

	private JLabel scriptName, status, runTime, count;

	private JPanel getHeader() {
		JPanel pan = new JPanel();
		pan.setLayout(new GridLayout(0, 1));
		pan.setMinimumSize(new Dimension(PANEL_WIDTH, 25));

		scriptName = new JLabel("", 0);
		scriptName.setForeground(new Color(199, 201, 201));
		pan.add(scriptName);

		status = new JLabel("Booting up...", 0);
		status.setForeground(new Color(199, 201, 201));
		pan.add(status);

		runTime = new JLabel("00:00:00", 0);
		runTime.setForeground(new Color(199, 201, 201));
		pan.add(runTime);

		count = new JLabel("", 0);
		count.setForeground(new Color(199, 201, 201));
		pan.add(count);
		pan.setBorder(
				new CompoundBorder(new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR), new EmptyBorder(0, 0, 3, 1)));
		return pan;
	}

	public void update(String text) {
		status.setText("<html>" + text + "</html>");
		runTime.setText(Variables.START_TIME.toElapsedString());
		if (Variables.COUNT > 0) count.setText(String.format("Count: %s (%s p/hr)", Variables.COUNT, ScriptUtils
				.getValuePerHour(Variables.START_TIME.getStart(), Variables.START_TIME.getElapsed(), (int) Variables.COUNT)));
	}

	private void toggleSection(JButton button, JPanel contents) {
		boolean newState = !contents.isVisible();
		contents.setVisible(newState);
		button.setIcon(newState ? SECTION_RETRACT_ICON : SECTION_EXPAND_ICON);
		button.setRolloverIcon(newState ? SECTION_RETRACT_ICON_HOVER : SECTION_EXPAND_ICON_HOVER);
		button.setToolTipText(newState ? "Retract" : "Expand");
		SwingUtilities.invokeLater(contents::revalidate);
	}

	private JPanel buildTab(String name, String desc) {
		final boolean isOpen = name.equals("Script Config");
		final JPanel section = new JPanel();
		section.setLayout(new BoxLayout(section, BoxLayout.Y_AXIS));
		section.setMinimumSize(new Dimension(PANEL_WIDTH, 0));

		final JPanel sectionHeader = new JPanel();
		sectionHeader.setBorder(
				new CompoundBorder(new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR), new EmptyBorder(0, 0, 3, 1)));
		section.add(sectionHeader, BorderLayout.NORTH);

		final JButton sectionToggle = new JButton(isOpen ? SECTION_RETRACT_ICON : SECTION_EXPAND_ICON);
		sectionToggle.setRolloverIcon(isOpen ? SECTION_RETRACT_ICON_HOVER : SECTION_EXPAND_ICON_HOVER);
		sectionToggle.setBorder(new EmptyBorder(0, 0, 0, 5));
		sectionToggle.setToolTipText("Expand");
		SwingUtil.removeButtonDecorations(sectionToggle);
		sectionHeader.add(sectionToggle, BorderLayout.WEST);

		final JLabel sectionName = new JLabel(name);
		sectionName.setForeground(ColorScheme.BRAND_ORANGE);
		sectionName.setFont(FontManager.getRunescapeBoldFont());
		sectionName.setAlignmentX(JLabel.WEST);
		sectionName.setToolTipText("<html>" + name + ":<br>" + desc + "</html>");
		sectionHeader.add(sectionName, BorderLayout.CENTER);

		final JPanel sectionContents = new JPanel();
		sectionContents.setLayout(new DynamicGridLayout(0, 1, 0, 5));
		sectionContents.setMinimumSize(new Dimension(PANEL_WIDTH, 0));
		sectionContents.setVisible(isOpen);
		section.add(sectionContents, BorderLayout.SOUTH);

		final MouseAdapter adapter = new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				toggleSection(sectionToggle, sectionContents);
				repaint();
				frame.pack();
			}
		};
		sectionToggle.addMouseListener(adapter);
		sectionName.addMouseListener(adapter);
		sectionHeader.addMouseListener(adapter);

		return section;
	}

	private JPanel buildConfig(int i, JPanel section) {
		Config.CONFIGURATION.forEach(config -> {
			if (i != config.getSection()) return;
			JPanel item = new JPanel();
			item.setLayout(new BorderLayout());
			item.setMinimumSize(new Dimension(PANEL_WIDTH, 0));

			String name = config.getText();
			if (config.getType() != Button.class) {
				JLabel configEntryName = new JLabel(name);
				configEntryName.setForeground(Color.WHITE);
				configEntryName.setToolTipText("<html>" + name + ":<br>" + config.getTooltip() + "</html>");
				item.add(configEntryName, BorderLayout.CENTER);
			}

			if (config.getType() == boolean.class) {
				JCheckBox checkbox = new JCheckBox();
				checkbox.setBackground(ColorScheme.LIGHT_GRAY_COLOR);
				checkbox.setSelected((boolean) config.getValue());
				checkbox.addActionListener(ae -> changeConfiguration(checkbox, config));
				item.add(checkbox, BorderLayout.EAST);
			}

			if (config.getType() == String.class) {
				JTextComponent textField;
				final JTextArea textArea = new JTextArea();
				textArea.setLineWrap(true);
				textArea.setWrapStyleWord(true);
				textField = textArea;
				textField.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
				textField.setText("");

				textField.addFocusListener(new FocusAdapter() {
					@Override
					public void focusLost(FocusEvent e) {
						changeConfiguration(textField, config);
					}
				});
				item.add(textField, BorderLayout.SOUTH);
			}

			if (config.getType() == Button.class) {
				final JButton button = new JButton(name);
				item.add(button, BorderLayout.SOUTH);
				button.addActionListener(ct -> onButtonClick(button, config));
			}

			if (config.getType() == int.class) {
				int value = (int) config.getValue();
				Range range = config.getRange();
				int min = 0, max = Integer.MAX_VALUE;
				if (range != null) {
					min = range.getMin();
					max = range.getMax();
				}
				value = Ints.constrainToRange(value, min, max);

				SpinnerModel model = new SpinnerNumberModel(value, min, max, 1);
				JSpinner spinner = new JSpinner(model);
				Component editor = spinner.getEditor();
				JFormattedTextField spinnerTextField = ((JSpinner.DefaultEditor) editor).getTextField();
				spinnerTextField.setColumns(SPINNER_FIELD_WIDTH);
				spinner.addChangeListener(ce -> changeConfiguration(spinner, config));
				item.add(spinner, BorderLayout.EAST);
			}

			if (((Class<? extends Enum>) config.getType()).isEnum()) {
				Class<? extends Enum> type = (Class<? extends Enum>) config.getType();
				JComboBox box = new JComboBox(type.getEnumConstants());
				box.setPreferredSize(new Dimension(box.getPreferredSize().width, 25));
				box.setRenderer(new ComboBoxListRenderer());
				box.setForeground(Color.WHITE);
				box.setFocusable(false);
				box.setPrototypeDisplayValue("XXXXXXXX");
				try {
					Config val = Config.getItem(config.getKeyName());
					Enum selectedItem = Enum.valueOf(type, (String) val.getValue());
					box.setSelectedItem(selectedItem);
					box.setToolTipText(Text.titleCase(selectedItem));
				} catch (IllegalArgumentException ex) {
					ClientContext.instance().log("invalid selected item", ex);
				}
				box.addItemListener(e -> {
					if (e.getStateChange() == ItemEvent.SELECTED) {
						changeConfiguration(box, config);
						box.setToolTipText(Text.titleCase((Enum) box.getSelectedItem()));
					}
				});
				item.add(box, BorderLayout.EAST);
			}

			JPanel p = (JPanel) section.getComponent(1);
			p.add(item);
		});
		return this;
	}

	private void onButtonClick(Object component, Config config) {
		if (config == null) return;

		final Config oldConfig = config;

		if (component instanceof JButton) {
			JButton button = (JButton) component;

			int cached = config.getCached();
			if (cached > -1) Variables.CACHED_BOOLEANS[cached] = true;

			if (config.getKeyName().equals("testHook")) {
				String url = Config.getValue("discordURL");
				if (Strings.isNullOrEmpty(url)) return;
			}
		}

		ClientContext.instance().log("Clicked " + config.getText() + " button");
		Variables.DISPATCHER.fireEvent(new ConfigChangeEvent(config, oldConfig));
	}

	private Object changeConfiguration(Object component, Config config) {
		if (config == null) return null;

		final Config oldConfig = config;

		if (component instanceof JCheckBox) {
			JCheckBox checkbox = (JCheckBox) component;
			if (Config.isConfigChanged() && !config.isChangeable()) {
				JOptionPane.showMessageDialog(frame, "This setting cannot be changed after run time");
				checkbox.setSelected(!checkbox.isSelected());
				return null;
			}

			config.setValue(checkbox.isSelected());
		} else if (component instanceof JSpinner) {
			JSpinner spinner = (JSpinner) component;
			config.setValue(spinner.getValue());
		} else if (component instanceof JTextComponent) {
			JTextComponent textField = (JTextComponent) component;
			config.setValue(textField.getText());
		} else if (component instanceof JComboBox) {
			JComboBox jComboBox = (JComboBox) component;
			config.setValue(((Enum) jComboBox.getSelectedItem()).name());
		}
		ClientContext.instance().log("Changed " + config.getText() + " option");
		Variables.DISPATCHER.fireEvent(new ConfigChangeEvent(config, oldConfig));
		Config.setConfigChanged(true);
		return null;
	}

	public JPanel getButton() {
		JPanel panel = new JPanel();
		panel.setLayout(new BorderLayout());
		panel.setBorder(
				new CompoundBorder(new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR), new EmptyBorder(0, 0, 3, 1)));
		final JButton start = new JButton("Start");
		start.addActionListener((e) -> {
			if (!Variables.STARTED) {
				Variables.STARTED = true;
				Variables.PAUSED = false;
				start.setText("Pause");
			} else {
				Variables.PAUSED = !Variables.PAUSED;
				start.setText(Variables.PAUSED ? "Resume" : "Pause");
			}

		});
		panel.add(start, BorderLayout.SOUTH);
		return panel;
	}
}

'''
'''--- simple/api/panel/Tabs.java ---
package simple.api.panel;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class Tabs {

	private final int index;
	private final String title, description;

}

'''
'''--- simple/api/panel/options/Range.java ---
package simple.api.panel.options;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class Range {

	private int min, max;

}

'''
'''--- simple/api/panel/options/WebhookMessage.java ---
package simple.api.panel.options;

public class WebhookMessage {
	public String content;

	public String username;

	public String avatar_url;

	public boolean tts;

	public Object file;

	public Object[] embeds;

	public WebhookMessage(String username, String content) {
		this.content = content;
		this.username = username;
	}
}

'''
'''--- smithing/AnvilSmither.java ---
package smithing;

import java.awt.Graphics;
import java.util.regex.Pattern;
import java.util.stream.IntStream;

import javax.swing.JFrame;

import net.runelite.api.ChatMessageType;
import net.runelite.api.widgets.WidgetInfo;
import simple.api.Timer;
import simple.api.Utils;
import simple.api.Variables;
import simple.api.panel.Config;
import simple.api.panel.Panel;
import simple.api.panel.Tabs;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleObject;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.script.Script;
import smithing.data.Smithable;

@ScriptManifest(author = "KremeSickle", category = Category.SMITHING, description = "<br>This script uses the Varrock smithing anvil<br><br>Start the script at the bank with your last-preset containing a hammer and your bars<br><br>The script will create the item of your choice and rebank when needed<br><br>Please make sure you have the required smithing level to make the item<br><br>Please message me on discord with any questions/concerns", discord = "Datev#0660", name = "KS | Anvil Smither", servers = {
		"Zaros" }, version = "1")
public class AnvilSmither extends Script implements LoopingScript {

	private JFrame frame;
	private Panel panel;

	@Override
	public void onExecute() {
		try {
			Variables.reset();
			addConfig();
			String title = Utils.getValue(getClass(), "name") + " v" + Utils.getValue(getClass(), "version");
			panel = new Panel();
			frame = panel.init(title, panel);
			Utils.setZoom(1);
		} catch (Exception e) {
			ctx.log(e.getMessage());
			e.printStackTrace();
		}
	}

	private boolean FORCE_BANK = true;
	private Timer LAST_ANIM = new Timer(1);

	public void addConfig() {
		Config.TABS.add(new Tabs(0, "Script Config", "Choose your configuration"));
		Config.CONFIGURATION.add(new Config(0, Smithable.class, "DAGGER", "Smith", "Choose which item to smith", "smithable"));
		Config.CONFIGURATION.add(new Config(0, boolean.class, false, "Logout on finish", "Logout on finish?", "logout"));
		Config.setConfigChanged(true);
	}

	@Override
	public void onProcess() {
		if (Variables.PAUSED) return;
		if (Variables.STOP && ctx.inventory.populate().filter(Pattern.compile("(.*) bar")).isEmpty()) {
			if (Config.getB("logout")) ctx.sendLogout();
			else ctx.stopScript();
			return;
		}
		if (!Variables.STARTED) {
			Variables.STATUS = "Waiting to be started";
			return;
		}

		if (ctx.inventory.populate().filter(Pattern.compile("(.*) bar")).isEmpty() || FORCE_BANK) {
			bank();
		} else {
			if (ctx.players.getLocal().getAnimation() == 898) {
				Variables.STATUS = "Gaining some experience";
				LAST_ANIM = new Timer(1000);
			}
			if (ctx.dialogue.dialogueOpen()) {
				if (!ctx.dialogue.populate().filterContains("ou don't have enough").isEmpty()) {
					Variables.STATUS = "Out of bars";
					FORCE_BANK = true;
				} else if (!ctx.dialogue.populate().filterContains("need a Smithing level").isEmpty()) {
					Variables.STATUS = "Need higher level to smith";
					ctx.log("You need a higher level to smith this item");
					Variables.STOP = true;
				}
				return;
			}

			if (LAST_ANIM.isRunning()) return;

			if (ctx.widgets.getWidget(WidgetInfo.SMITHING_INVENTORY_ITEMS_CONTAINER) != null) {
				Variables.STATUS = "Clicking on widget";
				if (getSmithable().click(0))
					ctx.onCondition(() -> ctx.players.getLocal().getAnimation() == 898 || ctx.dialogue.dialogueOpen());
			} else {
				anvil();
			}
		}
	}

	public void anvil() {
		SimpleObject anvil = ctx.objects.populate().filter("Anvil").nearest().next();
		if (anvil != null) {
			if (anvil.distanceTo(ctx.players.getLocal()) > 5) {
				Variables.STATUS = "Walking to anvil";
				ctx.pathing.step(anvil.getLocation());
			} else if (anvil.validateInteractable()) {
				Variables.STATUS = "Clicking anvil";
				if (anvil.click("Smith"))
					ctx.onCondition(() -> ctx.widgets.getWidget(WidgetInfo.SMITHING_INVENTORY_ITEMS_CONTAINER) != null);
			}
		}
	}

	public void bank() {
		SimpleObject bank = ctx.objects.populate().filter("Bank booth").nearest().next();
		if (bank != null) {
			if (bank.distanceTo(ctx.players.getLocal()) > 5) {
				Variables.STATUS = "Walking path to bank";
				ctx.pathing.step(bank.getLocation());
			} else if (bank.validateInteractable()) {
				Variables.STATUS = "Getting last preset";
				if (bank.click("Last-preset")) {
					FORCE_BANK = false;
					ctx.onCondition(() -> LAST_MESSAGE.contains("our preset is being"), 500);
				}
			}
		}
	}

	@Override
	public int loopDuration() {
		return 200;
	}

	@Override
	public void onTerminate() {
		if (frame != null) frame.dispose();
		ctx.log("Shutting down.. Thank you for using the script");
		Variables.reset();
		Config.clear();
	}

	@Override
	public void paint(Graphics Graphs) {
		if (panel != null) panel.update(Variables.STATUS);
	}

	final String[] STOP_MESSAGES = { "be found:" };
	private String LAST_MESSAGE = "";

	@Override
	public void onChatMessage(ChatMessage msg) {
		if (msg.getType() == ChatMessageType.GAMEMESSAGE) {
			LAST_MESSAGE = msg.getMessage();

			if (msg.getMessage().contains("be found:") && ctx.inventory.populate().filter(Pattern.compile("(.*) bar")).isEmpty())
				Variables.STOP = true;
		}
	}

	public SimpleWidget getSmithable() {
		SimpleWidget inter = ctx.widgets.getWidget(312, 9);
		if (inter != null && inter.visibleOnScreen()) {
			int index = IntStream.range(9, 45).filter(c -> {
				SimpleWidget w = ctx.widgets.getWidget(312, c);
				return w != null && w.visibleOnScreen() && w.getChild(0).getText() != null
						&& w.getChild(0).getText().contains(smith().getFriendlyName());
			}).findFirst().orElse(-1);

			if (index == -1) {
				Variables.STATUS = "REPORT AS BUG - CAN'T FIND ITEM";
				return null;
			}
			return ctx.widgets.getWidget(312, index);
		}
		return null;
	}

	public Smithable smith() {
		return Config.getValue("smithable");
	}

}

'''
'''--- smithing/data/Smithable.java ---
package smithing.data;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum Smithable {
	DAGGER("Dagger", 1),
	AXE("Axe", 1),
	MEDIUM_HELMET("Medium Helm", 1),
	CROSSBOW_BOLTS("Crossbow Bolts", 1),
	SWORD("Sword", 1),
	DART_TIPS("Dart tips", 1),
	NAILS("Nails", 1),
	ARROWTIPS("Arrowtips", 1),
	JAVELIN_HEADS("Javelin Heads", 1),
	THROWING_KNIVES("Throwing Knives", 1),
	CROSSBOW_LIMBS("Limbs", 1),
	STUDS("Studs", 1),
	BULLSEYE_LAMP("Bullseye lamp", 1),
	OIL_LAMP("Oil lamp", 1),
	GRAPLLE_TIP("Grapple tip", 1),
	IRON_SPIT("Iron spit", 1),
	SCIMITAR("Scimitar", 2),
	LONGSWORD("Longsword", 2),
	FULL_HELMET("Full Helm", 2),
	SQUARE_SHIELD("Square Shield", 2),
	CLAWS("Claws", 2),
	WARHAMMER("Warhammer", 3),
	BATTLEAXE("Battle axe", 3),
	CHAINBODY("Chain body", 3),
	KITESHIELD("Kite shield", 3),
	TWO_HANDED_SWORD("2-hand Sword", 3),
	PLATELEGS("Plate legs", 3),
	PLATESKIRT("Plate skirt", 3),
	PLATEBODY("Plate body", 5);

	private final String friendlyName;
	private final int barCount;

	@Override
	public String toString() {
		return friendlyName;
	}
}
'''
'''--- vorkath/Vorkath.java ---
package vorkath;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;

import api.Locations;
import api.Tasks;
import api.Variables;
import api.utils.Timer;
import api.utils.Utils;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Projectile;
import simple.hooks.filters.SimplePrayers.Prayers;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.scripts.listeners.ProjectileMovedEvent;
import simple.hooks.scripts.listeners.ProjectileMovedListener;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.simplebot.Magic.SpellBook;
import simple.robot.script.Script;
import vorkath.data.Constants;
import vorkath.methods.DeathHandler;
import vorkath.methods.Methods;
import vorkath.methods.Pathing;
import vorkath.methods.VorkathHandler;

@ScriptManifest(author = "KremeSickle", category = Category.COMBAT, description = "Does vorkath", name = "KS_ Vorkath", servers = {
		"Zaros" }, version = "0.1", discord = "")

public class Vorkath extends Script implements LoopingScript, ProjectileMovedListener {

	@Override
	public void paint(Graphics Graphs) {

		Graphics2D g = (Graphics2D) Graphs;

		g.setColor(Color.BLACK);
		g.fillRect(0, 230, 170, 75);
		g.setColor(Color.BLACK);
		g.drawRect(0, 230, 170, 75);
		g.setColor(Color.white);

		g.drawString("Private Vorkath v0.1", 7, 245);
		g.drawString("Uptime: " + Variables.START_TIME.toElapsedString(), 7, 257);
		g.drawString("Status: " + Variables.STATUS, 7, 269);

		g.drawString("Vorkath kills: " + Variables.COUNT + " ("
				+ ctx.paint.valuePerHour((int) Variables.COUNT, Variables.START_TIME.getStart()) + ")", 7, 281);

	}

	@Override
	public void onChatMessage(ChatMessage e) {
		if (e.getType() == ChatMessageType.GAMEMESSAGE) {
			Variables.LAST_MESSAGE = e.getMessage();
			if (e.getMessage().contains("antifire potion has expired")) Tasks.getSupplies().antiFire = new Timer(1);

			if (e.getMessage().contains("you are dead")) Constants.RECOLLECT_ITEMS = true;
			if (e.getMessage().contains("kill count")) Variables.COUNT++;
			if (e.getMessage().contains("not be found")) ctx.stopScript();
		}
	}

	@Getter
	private Methods methods;
	@Getter
	private Pathing path;
	@Getter
	private DeathHandler death;
	@Getter
	private VorkathHandler vorkath;

	@Override
	public void onExecute() {
		try {
			Variables.reset();
			Tasks.init(ctx);
			methods = new Methods(ctx, this);
			path = new Pathing(ctx, this);
			death = new DeathHandler(ctx, this);
			vorkath = new VorkathHandler(ctx, this);
			Utils.setZoom(1);
			doChecks();
			Tasks.getSkill().addPrayer(Prayers.PROTECT_FROM_MAGIC);
			Tasks.getSkill().addPrayer(Prayers.EAGLE_EYE);
			Constants.RECOLLECT_ITEMS = false;
			Variables.FORCE_BANK = ctx.pathing.inArea(Locations.EDGEVILLE_AREA);
			Variables.STARTED = true;
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private void doChecks() {
		boolean stop = false;
		if (ctx.magic.spellBook() != SpellBook.MODERN) {
			ctx.log("Please switch to normal spellbook");
			stop = true;
		}
		if (!Tasks.getInventory().containsAll("Chaos rune", "Earth rune", "Air rune")) {
			ctx.log("Please have required runes in\n inventory:\n%s, %s, %s", "Chaos rune", "Earth rune", "Air rune");
			stop = true;
		}

		if (stop) ctx.stopScript();
	}

	@Override
	public void onProcess() {
		if (!Variables.STARTED || Variables.STOP) return;
		if ((!ctx.pathing.inArea(Locations.EDGEVILLE_AREA) && Tasks.getAntiban().staffNearby())
				|| (Tasks.getAntiban().staffUnder() && !ctx.pathing.inArea(Locations.EDGEVILLE_BANK))) {
			Variables.STOP = true;
			return;
		}

		if (ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
			Tasks.getSkill().disablePrayers();
			if (Constants.RECOLLECT_ITEMS) {
				getDeath().handle();
				return;
			}
			if (!Tasks.getBanking().heal()) return;
			if (!Tasks.getBanking().usePreset()) return;
			if (!Utils.directTeleport("Vorkath") && Tasks.getTeleporter().open())
				Tasks.getTeleporter().teleportStringPath("Bossing", "Vorkath");
		} else if (ctx.pathing.inArea(Locations.VORKATH_START_AREA)) {
			Constants.PATH_SET = false;
			Constants.CURRENT_ACID_TILES.clear();
			Tasks.getSkill().disablePrayers();
			if (Constants.RECOLLECT_ITEMS) getDeath().handle();
			else getVorkath().enterInstance();
		} else if (ctx.getClient().isInInstancedRegion()) {
			if (getMethods().shouldRestock()) getMethods().teleportHome();
			else getVorkath().handle();
		}

	}

	@Override
	public void onChange(ProjectileMovedEvent proj) {
		if (proj == null) return;
		Projectile p = proj.getProjectile();
		if (p == null || p.getId() != 1483) return;
		System.out.println(p.getId());
		System.out.println(proj.getPosition());
		if (!Constants.CURRENT_ACID_TILES.contains(proj.getPosition())) Constants.CURRENT_ACID_TILES.add(proj.getPosition());

	}

	@Override
	public void onTerminate() {
		Tasks.getSkill().removeAll();
		Variables.reset();
	}

	@Override
	public int loopDuration() {
		return 150;
	}
}

'''
'''--- vorkath/VorkathG.java ---
package vorkath;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.stream.Stream;

import api.Locations;
import api.Tasks;
import api.Variables;
import api.simple.KSNPC;
import api.utils.Timer;
import api.utils.Utils;
import net.runelite.api.ChatMessageType;
import net.runelite.api.NpcID;
import net.runelite.api.ObjectID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimplePrayers.Prayers;
import simple.hooks.queries.SimpleEntityQuery;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.LoopingScript;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleGroundItem;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.script.Script;
import simple.robot.utils.WorldArea;

@ScriptManifest(author = "KremeSickle", category = Category.COMBAT, description = "Does vorkath", name = "Glitch Vorkath", servers = {
		"Zaros" }, version = "0.1", discord = "")

public class VorkathG extends Script implements LoopingScript {

	public boolean RECOLLECT_ITEMS = false;
	public Timer LAST_FIRE_BALL = new Timer(2000);

	@Override
	public void paint(Graphics Graphs) {

		Graphics2D g = (Graphics2D) Graphs;

		g.setColor(Color.BLACK);
		g.fillRect(0, 230, 170, 75);
		g.setColor(Color.BLACK);
		g.drawRect(0, 230, 170, 75);
		g.setColor(Color.white);

		g.drawString("Private Vorkath v0.3", 7, 245);
		g.drawString("Uptime: " + Variables.START_TIME.toElapsedString(), 7, 257);
		g.drawString("Status: " + Variables.STATUS, 7, 269);

		g.drawString("Vorkath kills: " + Variables.COUNT + " ("
				+ ctx.paint.valuePerHour((int) Variables.COUNT, Variables.START_TIME.getStart()) + ")", 7, 281);

	}

	@Override
	public void onChatMessage(ChatMessage e) {
		if (e.getType() == ChatMessageType.GAMEMESSAGE) {
			if (e.getMessage().contains("you are dead")) {
				Variables.STOP = true;
			}
			if (e.getMessage().contains("kill count")) Variables.COUNT++;
			if (e.getMessage().contains("not be found")) ctx.stopScript();
		}
	}

	@Override
	public void onExecute() {
		try {
			Variables.reset();
			Tasks.init(ctx);
			Utils.setZoom(1);
			Tasks.getSkill().addPrayer(Prayers.PROTECT_FROM_MAGIC);
			Tasks.getSkill().addPrayer(Prayers.EAGLE_EYE);
			Variables.FORCE_BANK = ctx.pathing.inArea(Locations.EDGEVILLE_AREA);
			Variables.STARTED = true;
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	WorldArea area = new WorldArea(new WorldPoint(3098, 3487, 0), new WorldPoint(3090, 3499, 0));

	@Override
	public void onProcess() {

		if (!Variables.STARTED) return;
		if (Variables.STOP) {
			Tasks.getAntiban().panic();
			return;
		}

		if ((!ctx.pathing.inArea(Locations.EDGEVILLE_AREA) && Tasks.getAntiban().staffNearby())
				|| (Tasks.getAntiban().staffUnder() && !ctx.pathing.inArea(area))) {
			ctx.log("Staff found at " + ctx.players.getLocal().getLocation());
			Variables.STOP = true;
			return;
		}

		if (ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {

		} else if (ctx.pathing.inArea(Locations.VORKATH_START_AREA)) {

		} else if (ctx.getClient().isInInstancedRegion()) {
			if (loot()) return;
			/*
			 * if (getAlch() != null) {
			 * ctx.magic.castSpellOnItem("High Level Alchemy",
			 * getAlch().getId()); ctx.onCondition(() ->
			 * ctx.players.getLocal().getAnimation() != -1); ctx.onCondition(()
			 * -> ctx.players.getLocal().getAnimation() == -1); return; }
			 */
			if (!setup()) return;
			if (containsAcid(ctx.players.getLocal().getLocation())) {
				ctx.pathing.step(getSortedPoint());
			}
			SimpleNpc zombified = ctx.npcs.populate().filter(NpcID.ZOMBIFIED_SPAWN_8063).next();
			if (zombified != null) {
				Tasks.getCombat().attack(zombified);
			} else if (ctx.players.getLocal().getInteracting() == null) Tasks.getCombat().attack("Vorkath");
		}

	}

	public boolean containsAcid(WorldPoint w) {
		SimpleEntityQuery<SimpleObject> acids = ctx.objects.populate().filter(ObjectID.ACID_POOL_32000).filter(w);
		return acids.size() > 0;
	}

	private String[] v = { "ragon battleaxe", "ragon longsword", "ragon plateleg", "ragon plateskirt", "visage", "decay",
			"necklace" };

	private String[] bad = { "diamond", "ruby", "watermelon", "seed", "chaos", "dragonhide", "crushed", "bolt tip",
			"adamantite ore", "wrath", "magic log" };

	public SimpleItem getAlch() {
		return Tasks.getInventory().getItem("ragon battleaxe", "ragon longsword", "ragon plateleg", "ragon plateskirt");
	}

	public boolean valid(SimpleGroundItem item) {
		if (Stream.of(bad).anyMatch(val2 -> item.getName().toLowerCase().contains(val2))) return false;
		if (item.isStackable()) return true;
		return Stream.of(v).anyMatch(val -> item.getName().toLowerCase().contains(val));
	}

	public boolean loot() {
		SimpleEntityQuery<SimpleGroundItem> possible = ctx.groundItems.populate();
		if (possible.population() == 0) return false;

		SimpleGroundItem loot = possible.populate().filter(item -> valid(item)).next();

		if (loot == null) return false;

		if (ctx.inventory.canPickupItem(loot)) {
			Variables.STATUS = "Picking up loot " + loot.getName();
			int population = ctx.inventory.populate().filter(loot.getId()).population(true);

			if (Tasks.getMenuAction().get(loot, "Take").invoke()) {
				ctx.sleep(200);
				ctx.onCondition(() -> population != ctx.inventory.populate().filter(loot.getId()).population(true));
				return true;
			}
		} else if (ctx.inventory.inventoryFull()) {
			Variables.STOP = true;
			ctx.sendLogout();
			return true;
		}
		return false;

	}

	private boolean setup() {
		SimpleNpc vorkath = ctx.npcs.populate().filter(NpcID.VORKATH_8059).next();
		if (vorkath == null) return true;

		Variables.STATUS = "Waking up vorkath";
		if (new KSNPC(vorkath).click("Poke")) {
			WorldPoint initial = ctx.players.getLocal().getLocation();
			ctx.sleepCondition(() -> vorkath.distanceTo(ctx.players.getLocal()) <= 5, 5000);
			ctx.sleep(1000);
			WorldPoint newWP = new WorldPoint(initial.getX(), initial.getY() - 5, initial.getPlane());
			ctx.pathing.step(newWP);
		}
		return false;
	}

	public WorldArea getArea() {
		WorldArea w = null;
		if (ctx.getClient().isInInstancedRegion()) {
			SimpleObject rock = ctx.objects.populate().filter(ObjectID.ICE_CHUNKS_31990).next();
			if (rock != null) {
				WorldPoint southWest = new WorldPoint(rock.getLocation().getX() - 10, rock.getLocation().getY() + 1, 0);
				WorldPoint northEast = new WorldPoint(rock.getLocation().getX() + 10, rock.getLocation().getY() + 24, 0);
				w = new WorldArea(southWest, northEast);
			}
		}
		return w;
	}

	public ArrayList<WorldPoint> getStartingPointAcid() {
		ArrayList<WorldPoint> safe = new ArrayList<WorldPoint>();
		WorldArea a = getArea();

		for (WorldPoint w : a.getWorldPoints()) {
			if (w.distanceTo(ctx.players.getLocal().getLocation()) >= 8) {
				continue;
			}

			if (containsAcid(w)) {
				continue;
			}

			WorldPoint east1 = new WorldPoint(w.getX() + 1, w.getY(), 0);
			if (containsAcid(east1)) {
				continue;
			}

			WorldPoint east2 = new WorldPoint(w.getX() + 2, w.getY(), 0);
			if (containsAcid(east2)) {
				continue;
			}

			WorldPoint east3 = new WorldPoint(w.getX() + 3, w.getY(), 0);
			if (containsAcid(east3)) {
				continue;
			}

			WorldPoint east4 = new WorldPoint(w.getX() + 4, w.getY(), 0);
			if (containsAcid(east4)) {
				continue;
			}

			safe.add(w);

		}
		return safe;
	}

	public WorldPoint getSortedPoint() {
		ArrayList<WorldPoint> wl = this.getStartingPointAcid();
		if (wl != null && wl.size() > 0) {
			Collections.sort(wl, new Comparator<WorldPoint>() {
				@Override
				public int compare(WorldPoint z1, WorldPoint z2) {
					if (z1.distanceTo(ctx.players.getLocal().getLocation()) > z2.distanceTo(ctx.players.getLocal().getLocation()))
						return 1;
					if (z1.distanceTo(ctx.players.getLocal().getLocation()) < z2.distanceTo(ctx.players.getLocal().getLocation()))
						return -1;
					return 0;
				}
			});
			return wl.get(0);
		}
		return null;
	}

	@Override
	public void onTerminate() {
		Tasks.getSkill().disablePrayers();
		Variables.reset();
	}

	@Override
	public int loopDuration() {
		return 150;
	}
}

'''
'''--- vorkath/data/Constants.java ---
package vorkath.data;

import java.util.ArrayList;
import java.util.List;

import api.utils.Timer;
import net.runelite.api.coords.WorldPoint;

public class Constants {

	public static List<WorldPoint> CURRENT_ACID_TILES = new ArrayList<WorldPoint>();
	public static boolean RECOLLECT_ITEMS = false;
	public static Timer LAST_FIRE_BALL = new Timer(2000);

	public static boolean PATH_SET = false;

}

'''
'''--- vorkath/methods/DeathHandler.java ---
package vorkath.methods;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import api.Locations;
import api.Tasks;
import api.Variables;
import api.simple.KSNPC;
import api.utils.Utils;
import lombok.AllArgsConstructor;
import simple.hooks.queries.SimpleItemQuery;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleWidget;
import simple.robot.api.ClientContext;
import vorkath.Vorkath;
import vorkath.data.Constants;

@AllArgsConstructor
public class DeathHandler {

	private ClientContext ctx;
	private Vorkath core;

	private final String[] food = { "shark", "pizza", "fish", "angler", "manta" };
	private final Predicate<SimpleWidget> ignoreFood = widget -> !Stream.of(food)
			.anyMatch(val -> widget.getName().toLowerCase().contains(val));

	public void handle() {
		if (teleport() && collect()) ctx.magic.castSpellOnce("Home Teleport");
	}

	private boolean teleport() {
		if (!ctx.pathing.inArea(Locations.VORKATH_START_AREA)) {
			if (!Utils.directTeleport("Vorkath") && Tasks.getTeleporter().open())
				Tasks.getTeleporter().teleportStringPath("Bosses", "Vorkath");
		}
		return ctx.pathing.inArea(Locations.VORKATH_START_AREA);
	}

	private boolean collect() {
		if (!screenOpen()) {
			openRecoverScreen();
			return false;
		}

		if (isLocked()) {
			if (!ctx.dialogue.dialogueOpen()) openDialogue();
			else if (!ctx.dialogue.populate().filterContains("500k").isEmpty()) {
				ctx.log("Don't have enough coins");
				ctx.sendLogout();
			} else {
				ctx.keyboard.sendKeys("1", false);
				ctx.onCondition(() -> !isLocked());
			}
			return false;
		}

		List<SimpleWidget> items = getItems();
		List<SimpleWidget> noFood = items.stream().filter(ignoreFood).collect(Collectors.toList());

		if (items.size() == 0) {
			Constants.RECOLLECT_ITEMS = false;
			Variables.FORCE_BANK = true;
		} else if (noFood.size() > 0) {
			if (ctx.inventory.inventoryFull()) Tasks.getSupplies().eat();
			else noFood.forEach(item -> item.click(0));
		} else {
			SimpleItemQuery<SimpleItem> equippable = ctx.inventory.populate().filterHasAction("Wear");
			if (equippable.size() > 0) equippable.forEach(item -> item.click(0));
			else if (items.size() > 0) {
				if (ctx.inventory.inventoryFull()) Tasks.getSupplies().eat();
				else items.stream().filter(distinctByKey(p -> p.getName())).forEach(item -> item.click(0));
			}
		}

		return items.size() == 0;
	}

	private static <T> Predicate<T> distinctByKey(Function<? super T, Object> keyExtractor) {
		Map<Object, Boolean> map = new ConcurrentHashMap<>();
		return t -> map.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
	}

	private void openDialogue() {
		SimpleWidget w = ctx.widgets.getWidget(602, 7);
		if (Utils.validWidget(w) && w.click(0)) ctx.onCondition(() -> ctx.dialogue.dialogueOpen());
	}

	private void openRecoverScreen() {
		KSNPC torfin = new KSNPC(ctx.npcs.populate().filter("Torfinn").next());
		if (torfin != null && torfin.validateInteractable() && torfin.click("Collect")) {
			ctx.onCondition(() -> screenOpen(), 3500);
			if (!ctx.dialogue.populate().filterContains("There are no items").isEmpty()) Constants.RECOLLECT_ITEMS = false;
		}
	}

	private boolean screenOpen() {
		return Utils.validWidget(ctx.widgets.getWidget(602, 3));
	}

	private boolean isLocked() {
		SimpleWidget w = ctx.widgets.getWidget(602, 7);
		return Utils.validWidget(w) && w.getSpriteId() != 1226;
	}

	private List<SimpleWidget> getItems() {
		SimpleWidget w = ctx.widgets.getWidget(602, 3);
		if (!Utils.validWidget(w)) return new ArrayList<SimpleWidget>();
		return Arrays.stream(w.getDynamicChildren()).filter(widget -> !widget.isHidden()).collect(Collectors.toList());
	}

}

'''
'''--- vorkath/methods/Methods.java ---
package vorkath.methods;

import api.Locations;
import api.Tasks;
import api.Variables;
import lombok.AllArgsConstructor;
import net.runelite.api.ObjectID;
import net.runelite.api.ProjectileID;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.wrappers.SimpleItem;
import simple.robot.api.ClientContext;
import vorkath.Vorkath;
import vorkath.data.Constants;

@AllArgsConstructor
public class Methods {

	private ClientContext ctx;
	private Vorkath core;

	public boolean shouldRestock() {
		boolean bank = false;
		if (Tasks.getSkill().getPercentage(Skills.HITPOINTS) < 20
				|| (Tasks.getSkill().getPercentage(Skills.HITPOINTS) < 40 && !Tasks.getSupplies().hasFood()))
			bank = true;
		// if (!Tasks.getSupplies().hasFood()) bank = true;
		if (Variables.FORCE_BANK) bank = true;
		if (bank) Variables.FORCE_BANK = true;
		return bank;
	}

	public void switchBolts() {
		int vorkathHealth = core.getVorkath().getHealth();
		if (vorkathHealth == -1) return;

		SimpleItem rubyBolt = Tasks.getInventory().getItem("Ruby bolts");
		SimpleItem diamondBolt = Tasks.getInventory().getItem("Diamond bolts");

		if (rubyBolt != null && vorkathHealth >= 35) {
			Variables.STATUS = "Switching bolts";
			if (rubyBolt.click(0)) ctx.onCondition(() -> Tasks.getInventory().isWearing(EquipmentSlot.AMMO, rubyBolt.getName()));
		} else if (diamondBolt != null && vorkathHealth < 35) {
			Variables.STATUS = "Switching diamond bolts";
			if (diamondBolt.click(0))
				ctx.onCondition(() -> Tasks.getInventory().isWearing(EquipmentSlot.AMMO, diamondBolt.getName()));
		}
	}

	public boolean zombieActive() {
		return zombieProjectile() || Tasks.getCombat().getNPC(false, "Zombified Spawn") != null;
	}

	public boolean acidActive() {
		return ctx.objects.populate().filter(ObjectID.ACID_POOL_32000).size() > 0 && Constants.CURRENT_ACID_TILES.size() > 0;
	}

	public boolean zombieProjectile() {
		return activeProjectile(ProjectileID.VORKATH_SPAWN_AOE);
	}

	public boolean fireballProjectile() {
		return activeProjectile(ProjectileID.VORKATH_BOMB_AOE);
	}

	public boolean acidProjectile() {
		return activeProjectile(ProjectileID.VORKATH_POISON_POOL_AOE);
	}

	public void teleportHome() {
		if (!ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) {
			if (ctx.magic.castHomeTeleport()) ctx.onCondition(() -> ctx.pathing.inArea(Locations.EDGEVILLE_AREA));
			Variables.FORCE_BANK = true;
		}
	}

	public boolean activeProjectile(int id) {
		return ctx.projectiles.projectileActive(id);
	}
}

'''
'''--- vorkath/methods/Pathing.java ---
package vorkath.methods;

import java.util.Arrays;

import api.Tasks;
import api.utils.Utils;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ObjectID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;
import simple.robot.utils.WorldArea;
import vorkath.Vorkath;
import vorkath.data.Constants;

@RequiredArgsConstructor
public class Pathing {

	@NonNull
	private ClientContext ctx;
	@NonNull
	private Vorkath core;

	public WorldArea getInstancedArea() {
		SimpleObject chunk = ctx.objects.populate().filter(ObjectID.ICE_CHUNKS_31990).next();
		if (chunk == null) return null;
		int x = chunk.getLocation().getX();
		int y = chunk.getLocation().getY();
		return Utils.makeArea(x - 10, y + 1, x + 10, y + 24, 0);
	}

	public WorldPoint getFireBallTile() {
		WorldPoint loc = ctx.players.getLocal().getPlayer().getWorldLocation();
		WorldPoint east = new WorldPoint(loc.getX() + 3, loc.getY(), loc.getPlane());
		WorldPoint west = new WorldPoint(loc.getX() - 3, loc.getY(), loc.getPlane());
		return ctx.pathing.reachable(east) ? east : west;
	}

	public WorldPoint start, west, east;

	public void handleAcid() {
		while (ctx.getClient().isInInstancedRegion() && core.getMethods().acidActive()) {
			if (!Constants.PATH_SET) {
				ctx.log("Path is not set");
				start = west = east = null;
				ctx.log(Constants.CURRENT_ACID_TILES.size() + "");
				int distance = 4;
				start = Arrays.stream(getInstancedArea().getWorldPoints()).filter(tile -> ctx.pathing.distanceTo(tile) < 10)
						.filter(tile -> {
							return Arrays.stream(getTiles(tile, distance))
									.noneMatch(point -> Constants.CURRENT_ACID_TILES.contains(point));
						}).sorted((a, b) -> (int) ctx.pathing.distanceTo(a) - (int) ctx.pathing.distanceTo(b)).findFirst()
						.orElse(null);
				if (start != null) {
					Constants.PATH_SET = true;
					ctx.log("Set path");
					west = new WorldPoint(start.getX() - distance, start.getY(), start.getPlane());
					east = new WorldPoint(start.getX() + distance, start.getY(), start.getPlane());
					System.out.println(west);
				} else {
					ctx.log("NONE");
				}
			} else {
				if (Tasks.getSkill().getPercentage(Skills.HITPOINTS) < 20) core.getMethods().teleportHome();
				if (ctx.players.getLocal().getLocation().getX() != start.getX()) ctx.pathing.step(start);
				else if (ctx.pathing.distanceTo(east) <= 1) ctx.pathing.step(start);
				else if (ctx.pathing.distanceTo(start) >= 1) ctx.pathing.step(east);
				if (Tasks.getSkill().getPercentage(Skills.HITPOINTS) < 40) Tasks.getSupplies().eat();
			}
		}
		Constants.PATH_SET = false;
	}

	public WorldPoint[] getTiles(WorldPoint loc, int range) {
		WorldPoint[] locs = new WorldPoint[range * 2 + 1];
		for (int i = -range; i <= range; i++)
			locs[i + range] = new WorldPoint(loc.getX() + i, loc.getY(), loc.getPlane());
		return locs;
	}

}

'''
'''--- vorkath/methods/VorkathHandler.java ---
package vorkath.methods;

import api.Tasks;
import api.Variables;
import api.simple.KSNPC;
import api.simple.KSObject;
import api.tasks.Supplies.PotionType;
import lombok.RequiredArgsConstructor;
import net.runelite.api.NpcID;
import net.runelite.api.ObjectID;
import net.runelite.api.coords.WorldPoint;
import simple.hooks.filters.SimpleEquipment.EquipmentSlot;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.wrappers.SimpleNpc;
import simple.robot.api.ClientContext;
import simple.robot.utils.Random;
import vorkath.Vorkath;
import vorkath.data.Constants;

@RequiredArgsConstructor
public class VorkathHandler {

	private final ClientContext ctx;
	private final Vorkath core;

	public boolean enterInstance() {
		if (!ctx.getClient().isInInstancedRegion()) {
			Variables.STATUS = "Entering instance";
			KSObject rock = new KSObject(ctx.objects.populate().filter(ObjectID.ICE_CHUNKS_31990).next());
			if (rock != null && rock.validateInteractable() && rock.click("Climb-over"))
				ctx.sleepCondition(() -> ctx.getClient().isInInstancedRegion(), 5500);
		}
		return ctx.getClient().isInInstancedRegion();
	}

	public void handle() {
		if (Tasks.getLoot().loot()) return;
		if (!setup()) return;

		Tasks.getCombat().checkPots();

		Tasks.getSkill().flickPrayer(true);

		if (core.getMethods().fireballProjectile()) handleFireBall();
		if (core.getMethods().zombieActive()) handleZombie();
		if (core.getMethods().acidActive()) handleAcid();

		else {
			if (Tasks.getSkill().getPercentage(Skills.HITPOINTS) < 70) Tasks.getSupplies().eat();

			if (!Tasks.getInventory().isWearing(EquipmentSlot.WEAPON, "crossbow")) Tasks.getInventory().equip(true, "crossbow");
			// core.getMethods().switchBolts();
			Variables.STATUS = "Killing Vorkath";
			if (ctx.players.getLocal().getInteracting() == null) Tasks.getCombat().attack("Vorkath");
		}
	}

	private void handleZombie() {
		SimpleNpc zombified = ctx.npcs.populate().filter(NpcID.ZOMBIFIED_SPAWN_8063).filter(npc -> !npc.isDead()).next();
		if (zombified == null) return;
		Variables.STATUS = "Zombified active";

		Tasks.getInventory().equip(true, "staff");

		if (Tasks.getInventory().isWearing(EquipmentSlot.WEAPON, "staff")) Tasks.getCombat().attack(zombified);
		else ctx.magic.castSpellOnNPC("Crumble Undead", zombified);
	}

	private void handleAcid() {
		Variables.STATUS = "Handling Acid";
		core.getPath().handleAcid();
	}

	private void handleFireBall() {
		if (Constants.LAST_FIRE_BALL.isRunning()) return;

		Variables.STATUS = "Fire ball active";

		WorldPoint tile = core.getPath().getFireBallTile();

		if (tile == null) return;

		while (ctx.pathing.reachable(tile) && !ctx.pathing.onTile(tile))
			ctx.pathing.step(tile);
		Constants.LAST_FIRE_BALL.reset();
		Tasks.getCombat().attack("Vorkath");
	}

	private boolean setup() {
		SimpleNpc vorkath = ctx.npcs.populate().filter(NpcID.VORKATH_8059).next();
		if (vorkath == null) return true;

		if (Tasks.getInventory().contains("bones")) Variables.FORCE_BANK = true;
		else {
			Variables.STATUS = "Waking up vorkath";
			if (new KSNPC(vorkath).click("Poke")) {
				ctx.onCondition(() -> ctx.players.getLocal().getAnimation() != -1, 2000);
				ctx.onCondition(() -> ctx.players.getLocal().getAnimation() == -1);
				Variables.STATUS = "Gaining some distance";

				WorldPoint loc = ctx.players.getLocal().getLocation();
				WorldPoint next = new WorldPoint(loc.getX(), loc.getY() - Random.between(2, 5), loc.getPlane());

				if (ctx.pathing.step(next)) ctx.sleep(400, 600);

				Tasks.getSkill().flickPrayer(true);
				Tasks.getSupplies().drink(PotionType.ANTIFIRE);

			}
		}
		return false;
	}

	public int getHealth() {
		SimpleNpc vorkath = Tasks.getCombat().getNPC(NpcID.VORKATH_8061);
		return vorkath != null ? vorkath.getHealthRatio() : -1;
	}
}

'''
'''--- warriorguild/WarriorGuild.java ---
package warriorguild;

import java.awt.Graphics;
import java.util.regex.Pattern;

import javax.swing.JFrame;

import lombok.Getter;
import simple.api.Locations;
import simple.api.Utils;
import simple.api.Variables;
import simple.api.panel.Config;
import simple.api.panel.Panel;
import simple.api.panel.Tabs;
import simple.api.panel.options.Range;
import simple.hooks.filters.SimplePrayers.Prayers;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.scripts.Category;
import simple.hooks.scripts.ScriptManifest;
import simple.hooks.simplebot.ChatMessage;
import simple.hooks.wrappers.SimpleItem;
import simple.robot.script.Script;
import warriorguild.data.Constants;
import warriorguild.data.Methods;

@ScriptManifest(author = "KremeSickle", category = Category.MINIGAMES, description = "<br>This script will get you tokens and defenders<br><br>Start the script at the warrior guild<br<br>If you're getting tokens, start with (Rune full helm, platebody, platelegs) in inventory (ONLY RUNE IS SUPPORTED)<br><br>If using food or prayer potions, have them in inventory as there is no banking (Uses Melee protection only)<br><br>If using attack cape instead of tokens, have cape equipped<br><br>Script will shut down once Rune defender (or) Dragon defender has been achieved<br><br>Please message me on discord with any questions/concerns", discord = "Datev#0660", name = "KS | Warrior Guild", servers = {
		"Zaros" }, version = "3", vip = true)
public class WarriorGuild extends Script {

	private JFrame frame;
	private Panel panel;

	@Override
	public void onExecute() {
		try {
			Variables.reset();
			addConfig();
			String title = Utils.getValue(getClass(), "name") + " v" + Utils.getValue(getClass(), "version");
			panel = new Panel();
			frame = panel.init(title, panel);
			Utils.setZoom(1);
		} catch (Exception e) {
			ctx.log(e.getMessage());
			e.printStackTrace();
		}
	}

	@Getter
	private Methods methods;

	public void addConfig() {
		methods = new Methods(ctx, this);
		Config.TABS.add(new Tabs(0, "Script Config", "Choose your configuration"));
		Config.TABS.add(new Tabs(1, "Combat Config", "Choose your combat configuration"));

		Config.CONFIGURATION
				.add(new Config(0, boolean.class, true, "Gather Tokens", "Gather Warrior guild tokens when needed", "getToken"));
		Config.CONFIGURATION
				.add(new Config(0, boolean.class, true, "Gather Defenders", "Gather Bronze - Rune defender", "getDefender"));
		Config.CONFIGURATION.add(
				new Config(0, boolean.class, true, "Gather Dragon defenders", "Gather Dragon defender", "getDragonDefender"));
		Config.CONFIGURATION.add(new Config(0, boolean.class, true, "Stop on defender obtain",
				"Stop the script when selected defenders are obtained", "finish"));
		Config.CONFIGURATION.add(new Config(0, boolean.class, false, "Logout on finish", "Logout on finish?", "logout"));

		Config.CONFIGURATION.add(new Config(1, boolean.class, false, "Eat Food", "Eat any food in inventory", "useFood"));
		Config.CONFIGURATION
				.add(new Config(1, int.class, 40, "Eat At %", "Eat at this % of hitpoints", "eatHP", new Range(1, 100)));
		Config.CONFIGURATION.add(new Config(1, boolean.class, false, "Use Prayer",
				"Drink prayer/super restore potions in inventory", "usePrayer"));
		Config.CONFIGURATION
				.add(new Config(1, int.class, 40, "Drink At %", "Drink at this % of prayer", "drinkPrayer", new Range(1, 100)));

		Config.setConfigChanged(true);
	}

	public void setBooleans() {
		SimpleItem tokens = ctx.inventory.populate().filter(8851).next();
		SimpleItem defender = ctx.inventory.populate().filter("Rune defender").next();
		if (Config.getB("getToken") && !getMethods().hasAttackCape() && (tokens == null || tokens.getQuantity() < 100))
			Constants.CURRENT_TASK = 0;
		else if (Config.getB("getDefender") && defender == null) Constants.CURRENT_TASK = 1;
		else if (Config.getB("getDragonDefender")) Constants.CURRENT_TASK = 2;
	}

	@Override
	public void onProcess() {
		if (Variables.PAUSED) return;
		if (Variables.STOP) {
			if (Config.getB("logout")) ctx.sendLogout();
			else ctx.stopScript();
			return;
		}
		if (!Variables.STARTED) {
			Variables.STATUS = "Waiting to be started";
			return;
		}

		if (Variables.STOP) {
			if (Config.getB("logout")) {
				if (!ctx.pathing.inArea(Locations.EDGEVILLE_AREA)) ctx.magic.castSpellOnce("Home Teleport");
				else ctx.sendLogout();
			} else ctx.stopScript();
			return;
		}

		if (Config.isConfigChanged()) {
			setBooleans();
			Config.setConfigChanged(false);
		}

		if (!getMethods().insideWarriorGuild()) {
			Variables.STATUS = "Please enter the Warrior's guild";
			return;
		}

		if (!ctx.combat.autoRetaliate()) ctx.combat.toggleAutoRetaliate(true);

		if (ctx.skills.level(Skills.HITPOINTS) < Config.getI("eatHP")) {
			SimpleItem food = ctx.inventory.populate().filterHasAction("Eat").next();
			if (food != null && food.click(0)) ctx.sleep(150, 200);
		}

		if (ctx.skills.level(Skills.PRAYER) < Config.getI("drinkPrayer")) {
			SimpleItem potion = ctx.inventory.populate().filter(Pattern.compile("Prayer potion(.*)")).next();
			if (potion == null) ctx.inventory.populate().filter(Pattern.compile("Super restore (.*)")).next();
			if (potion != null && potion.click(0)) ctx.sleep(150, 200);
		}

		if (Constants.CURRENT_TASK == 0) {
			boolean obtain = Config.getB("getToken");

			if (Config.getB("finish") && getMethods().has("Rune defender") && !Config.getB("getDragonDefender")) {
				Variables.STOP = true;
				return;
			}

			if (getMethods().hasAttackCape()) {
				ctx.log("Resetting.. has attack cape");
				Config.getItem("getToken").setValue(false);
				setBooleans();
				return;
			}

			if (!obtain) {
				Variables.STATUS = "Please adjust your settings";
				return;
			}

			if (getMethods().getTokens() > 300) {
				ctx.log("Resetting.. has enough tokens");
				setBooleans();
				return;
			}
			if (!getMethods().loot("Rune platebody", "Rune full helm", "Rune platelegs", "Warrior guild token"))
				getMethods().handleTokens();
		} else if (Constants.CURRENT_TASK == 1) {
			if (getMethods().has("Rune defender")) {
				if (Config.getB("getDragonDefender")) setBooleans();
				else if (Config.getB("finish")) return;
			}
			if (!getMethods().loot("Bronze defender", "Iron defender", "Steel defender", "Black defender", "Mithril defender",
					"Adamant defender", "Rune defender"))
				getMethods().handleDefenders();
		} else if (Constants.CURRENT_TASK == 2) {
			if (Config.getB("finish") && getMethods().has("Dragon defender")) {
				Variables.STOP = true;
				return;
			}
			if (!getMethods().loot("Dragon defender")) getMethods().handleDefenders();
		} else {
			Variables.STOP = true;
		}
	}

	@Override
	public void onTerminate() {
		ctx.prayers.prayer(Prayers.PROTECT_FROM_MELEE, false);
		if (frame != null) frame.dispose();
		ctx.log("Shutting down.. Thank you for using the script");
		Variables.reset();
		Config.clear();
	}

	@Override
	public void paint(Graphics Graphs) {
		if (panel != null) panel.update(Variables.STATUS);
	}

	@Override
	public void onChatMessage(ChatMessage e) {
	}
}

'''
'''--- warriorguild/data/Constants.java ---
package warriorguild.data;

import net.runelite.api.coords.WorldPoint;
import simple.robot.utils.WorldArea;

public class Constants {

	public static int CURRENT_TASK = 0;

	public final static WorldPoint LEVEL_3_DOOR = new WorldPoint(2847, 3540, 2);
	public final static WorldArea TOKEN_AREA = new WorldArea(new WorldPoint(2849, 3546, 0), new WorldPoint(2861, 3534, 0));

	public final static WorldArea CYCLOPS_AREA = new WorldArea(new WorldPoint(2836, 3557, 2), new WorldPoint(2876, 3533, 2));
	public final static WorldArea CYCLOPS_ENTRY = new WorldArea(new WorldPoint(2838, 3543, 2), new WorldPoint(2847, 3536, 2));

	public final static WorldArea CYCLOPS2_AREA = new WorldArea(new WorldPoint(2905, 9974, 0), new WorldPoint(2941, 9957, 0));
	public final static WorldArea CYCLOPS2_ENTRY = new WorldArea(new WorldPoint(2905, 9974, 0), new WorldPoint(2912, 9966, 0));

	public final static int RUNE_ANIMATED_ARMOR = 5432;
	public final static int TOKEN_DOOR = 24306;

}

'''
'''--- warriorguild/data/Methods.java ---
package warriorguild.data;

import java.util.function.Predicate;
import java.util.regex.Pattern;

import net.runelite.api.coords.WorldPoint;
import simple.api.Variables;
import simple.api.panel.Config;
import simple.hooks.filters.SimplePrayers.Prayers;
import simple.hooks.filters.SimpleSkills.Skills;
import simple.hooks.queries.SimpleEntityQuery;
import simple.hooks.wrappers.SimpleGroundItem;
import simple.hooks.wrappers.SimpleItem;
import simple.hooks.wrappers.SimpleNpc;
import simple.hooks.wrappers.SimpleObject;
import simple.robot.api.ClientContext;
import warriorguild.WarriorGuild;

public class Methods {

	private ClientContext ctx;
	private WarriorGuild core;

	public Methods(ClientContext ctx, WarriorGuild core) {
		this.ctx = ctx;
		this.core = core;
	}

	Predicate<SimpleNpc> GET_AGGRESSOR = npc -> !npc.isDead()
			&& (npc.getInteracting() == null || npc.getInteracting().equals(ctx.players.getLocal().getPlayer()));

	public void handleTokens() {
		if (!ctx.pathing.inArea(Constants.TOKEN_AREA)) {
			travel(false);
			return;
		}

		SimpleNpc enemy = ctx.npcs.populate().filter(Constants.RUNE_ANIMATED_ARMOR).filter(GET_AGGRESSOR).nearest().next();
		if (enemy != null) {
			if (Config.getB("usePrayer")) enablePrayer();
			Variables.STATUS = "Killing animated armor";
			if (ctx.players.getLocal().getInteracting() == null && enemy.click("Attack"))
				ctx.onCondition(() -> ctx.players.getLocal().getInteracting() != null);
		} else if (hasArmorSet()) {
			Variables.STATUS = "Spawning animated armor";
			SimpleObject statue = ctx.objects.populate().filter("Magical animator").nearest().next();
			if (statue != null && statue.validateInteractable() && statue.click(0))
				ctx.onCondition(() -> ctx.players.getLocal().getInteracting() != null, 100);
		} else {
			Variables.STATUS = "You have no full armor sets";
		}
	}

	public void handleDefenders() {

		if (Constants.CURRENT_TASK == 0) return;

		if (Config.getB("getToken") && !hasAttackCape()) {
			if (getTokens() > 300) {
				if (ctx.pathing.inArea(Constants.CYCLOPS_ENTRY)) Constants.CURRENT_TASK = 0;
				else if (ctx.pathing.inArea(Constants.CYCLOPS2_ENTRY)) Variables.STOP = true;
			}
		}
		if (Constants.CURRENT_TASK == 2
				&& (!ctx.pathing.inArea(Constants.CYCLOPS2_AREA) || ctx.pathing.inArea(Constants.CYCLOPS2_ENTRY))) {
			travelToDragonCyclops();
		} else if (Constants.CURRENT_TASK == 1
				&& (!ctx.pathing.inArea(Constants.CYCLOPS_AREA) || ctx.pathing.inArea(Constants.CYCLOPS_ENTRY))) {
					travel(true);
				} else {
					if (Config.getB("usePrayer")) enablePrayer();
					SimpleNpc enemy = ctx.npcs.populate().filter("Cyclops").filter(GET_AGGRESSOR).nearest().next();
					Variables.STATUS = "Killing cyclops";
					if (enemy != null && ctx.players.getLocal().getInteracting() == null) {
						Variables.STATUS = "Attacking cyclops";
						if (enemy.click("Attack")) ctx.onCondition(() -> ctx.players.getLocal().getInteracting() != null);
					}

				}
	}

	public boolean insideWarriorGuild() {
		WorldPoint loc = ctx.players.getLocal().getLocation();
		return (loc.getX() >= 2832 && loc.getX() <= 2876) && (loc.getY() >= 3534 && loc.getY() <= 3555)
				|| ctx.pathing.inArea(Constants.CYCLOPS2_AREA);
	}

	public void thirdFloor(boolean up) {
		if (!up && !ctx.pathing.inArea(Constants.CYCLOPS_ENTRY)) {
			if (ctx.pathing.distanceTo(Constants.LEVEL_3_DOOR) > 10) {
				Variables.STATUS = "Walking closer to door";
				ctx.pathing.walkPath(ctx.pathing.createLocalPath(Constants.LEVEL_3_DOOR));
				ctx.onCondition(() -> ctx.pathing.distanceTo(Constants.LEVEL_3_DOOR) > 5);
				return;
			}
			Variables.STATUS = "Going through cyclops door";
			SimpleObject door = ctx.objects.populate().filter(Constants.LEVEL_3_DOOR).nearest().next();
			if (door != null && door.validateInteractable() && door.click("Open"))
				ctx.onCondition(() -> ctx.pathing.inArea(Constants.CYCLOPS_ENTRY));
			return;
		}

		if (ctx.pathing.inArea(Constants.CYCLOPS_ENTRY)) {
			if (up) {
				Variables.STATUS = "Entering cyclops door";
				SimpleObject door = ctx.objects.populate().filter(Constants.LEVEL_3_DOOR).nearest().next();
				if (door != null && door.validateInteractable() && door.click("Open"))
					ctx.onCondition(() -> !ctx.pathing.inArea(Constants.CYCLOPS_ENTRY));
			} else {
				Variables.STATUS = "Going down first stairs";
				SimpleObject stairs = ctx.objects.populate().filter(24303).nearest().next();
				if (stairs != null && stairs.validateInteractable() && stairs.click("Climb-down"))
					ctx.onCondition(() -> !ctx.pathing.inArea(Constants.CYCLOPS_ENTRY));
			}
		}
	}

	public void secondFloor(boolean up) {
		String action = up ? "up" : "down";
		Variables.STATUS = "Going " + action + " second stairs";
		SimpleObject stairs = ctx.objects.populate().filter(16672).nearest().next();
		if (stairs != null && stairs.validateInteractable() && stairs.click("Climb-" + action))
			ctx.onCondition(() -> ctx.players.getLocal().getLocation().getPlane() != 1);
	}

	private final WorldPoint STAIRS_1 = new WorldPoint(2839, 3537, 0);

	public void firstFloor(boolean up) {
		if (up) {
			if (ctx.pathing.inArea(Constants.TOKEN_AREA)) {
				SimpleObject tokenDoor = ctx.objects.populate().filter(Constants.TOKEN_DOOR).nearest().next();
				if (tokenDoor != null && tokenDoor.validateInteractable() && tokenDoor.click("Open"))
					ctx.onCondition(() -> !ctx.pathing.inArea(Constants.TOKEN_AREA));
			}
			Variables.STATUS = "Walking up first stairs";
			SimpleObject stairs = ctx.objects.populate().filter(16671).nearest().next();
			if (stairs == null || ctx.pathing.distanceTo(stairs.getLocation()) > 10) {
				ctx.pathing.step(STAIRS_1);
				ctx.onCondition(() -> !ctx.pathing.inMotion());
			} else if (stairs.validateInteractable() && stairs.click("Climb-up"))
				ctx.onCondition(() -> ctx.players.getLocal().getLocation().getPlane() == 1);
		} else {
			if (ctx.pathing.inArea(Constants.TOKEN_AREA)) {
				SimpleObject tokenDoor = ctx.objects.populate().filter(Constants.TOKEN_DOOR).nearest().next();
				if (tokenDoor != null && tokenDoor.validateInteractable() && tokenDoor.click("Open"))
					ctx.onCondition(() -> !ctx.pathing.inArea(Constants.TOKEN_AREA));
				return;
			}
			Variables.STATUS = "Walking to token door";
			SimpleObject tokenDoor = ctx.objects.populate().filter(Constants.TOKEN_DOOR).nearest().next();
			if (tokenDoor != null && tokenDoor.validateInteractable() && tokenDoor.click("Open"))
				ctx.onCondition(() -> ctx.pathing.inArea(Constants.TOKEN_AREA));
		}
	}

	public void travel(boolean up) {
		ctx.prayers.prayer(Prayers.PROTECT_FROM_MELEE, false);
		int plane = ctx.players.getLocal().getLocation().getPlane();
		if (plane == 2) thirdFloor(up);
		else if (plane == 1) secondFloor(up);
		else firstFloor(up);
	}

	private void travelToDragonCyclops() {
		if (ctx.players.getLocal().getLocation().getPlane() != 0 || ctx.pathing.inArea(Constants.TOKEN_AREA)) {
			travel(false);
			return;
		}

		if (ctx.pathing.inArea(Constants.CYCLOPS2_ENTRY)) {
			Variables.STATUS = "Entering cyclops door";
			SimpleObject door2 = ctx.objects.populate().filter(10043).filterHasAction("Open").nearest().next();
			if (door2 != null && door2.validateInteractable() && door2.click("Open"))
				ctx.onCondition(() -> !ctx.pathing.inArea(Constants.CYCLOPS2_ENTRY));
			return;
		}

		SimpleObject firstDoor = ctx.objects.populate().filter(new WorldPoint(2837, 3549, 0)).filterHasAction("Open").nearest()
				.next();
		if (ctx.players.getLocal().getLocation().getX() > 2837 && firstDoor != null) {
			Variables.STATUS = "Walking to first door";
			if (firstDoor.validateInteractable() && firstDoor.click("Open"))
				ctx.onCondition(() -> ctx.players.getLocal().getLocation().getX() == 2838);
			return;
		}

		Variables.STATUS = "Walking to ladder";
		SimpleObject secondDoor = ctx.objects.populate().filter(10042).nearest().next();
		if (secondDoor != null && secondDoor.validateInteractable() && secondDoor.click("Climb-down"))
			ctx.onCondition(() -> ctx.pathing.inArea(Constants.CYCLOPS2_ENTRY));
	}

	public boolean hasArmorSet() {
		boolean helm = ctx.inventory.populate().filter(Pattern.compile("Rune full helm")).population() > 0;
		boolean plate = ctx.inventory.populate().filter(Pattern.compile("Rune platebody")).population() > 0;
		boolean legs = ctx.inventory.populate().filter(Pattern.compile("Rune platelegs")).population() > 0;
		return helm && plate && legs;
	}

	public boolean hasAttackCape() {
		return ctx.equipment.populate().filter(Pattern.compile("Attack cape(.*)")).population() > 0;
	}

	public int getTokens() {
		SimpleItem tokens = ctx.inventory.populate().filter(8851).next();
		return tokens != null ? tokens.getQuantity() : 0;
	}

	public boolean has(String name) {
		return ctx.inventory.populate().filter(name).population() > 0;
	}

	public boolean loot(String... strings) {
		SimpleEntityQuery<SimpleGroundItem> possible = ctx.groundItems.populate();
		if (possible.population() == 0) return false;

		SimpleGroundItem loot = possible.filter(strings).nearest().next();
		if (loot == null) return false;

		SimpleItem food = ctx.inventory.populate().filterHasAction("Eat").next();

		if (ctx.inventory.canPickupItem(loot)) {
			Variables.STATUS = "Picking up loot";
			int population = ctx.inventory.populate().filter(loot.getId()).population(true);
			if (loot.click("Take"))
				ctx.onCondition(() -> population != ctx.inventory.populate().filter(loot.getId()).population(true), 75);
			return true;
		} else if (ctx.inventory.inventoryFull() && food != null) {
			if (food.click(0)) ctx.sleep(150, 200);
			return true;
		}
		return false;
	}

	public void enablePrayer() {
		if (ctx.skills.level(Skills.PRAYER) == 0 && ctx.skills.realLevel(Skills.PRAYER) >= 43) return;
		ctx.prayers.prayer(Prayers.PROTECT_FROM_MELEE, true);
	}

}

'''